;; Autogenerated code, don't edit! ;;
(ns csound.opcodes
  (:require [cljs.spec.alpha :as s]
            [cljs.spec.test.alpha :as stest]
            [csound.core :refer [*global*
                                 ast-node
                                 AudioSignal 
                                 ControlSignal
                                 FrequencySignal
                                 Variable String 
                                 AudioArray 
                                 ControlArray
                                 VariableArray 
                                 StringArray IO
                                 ScoreParameter
                                 valid-f? valid-f?*
                                 valid-x? valid-x?*
                                 valid-S? valid-S?*
                                 valid-SArr? valid-SArr?*
                                 valid-kArr? valid-kArr?*
                                 valid-ar? valid-ar?*
                                 valid-i? valid-i?*
                                 valid-kr? valid-kr?*
                                 valid-aArr? valid-aArr?*
                                 valid-iArr? valid-iArr?*]]))

(defn mac
  {:arglists '([& karg1* aarg2* karg3* aarg4* karg5* aarg6* karg7* aarg8* karg9* aarg10* karg11* aarg12* karg13* aarg14* karg15* aarg16*])}
  [& [ arg1* arg2* arg3* arg4* arg5* arg6* arg7* arg8* arg9* arg10* arg11* arg12* arg13* arg14* arg15* arg16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "mac"
                      [arg1* arg2* arg3* arg4* arg5* arg6* arg7* arg8* arg9* arg10* arg11* arg12* arg13* arg14* arg15* arg16*]
                      *global*)]
    (new out-types ast)))

(s/fdef mac
  :args (s/cat :arg1* (s/? valid-kr?*) :arg2* (s/? valid-ar?*) :arg3* (s/? valid-kr?*) :arg4* (s/? valid-ar?*) :arg5* (s/? valid-kr?*) :arg6* (s/? valid-ar?*) :arg7* (s/? valid-kr?*) :arg8* (s/? valid-ar?*) :arg9* (s/? valid-kr?*) :arg10* (s/? valid-ar?*) :arg11* (s/? valid-kr?*) :arg12* (s/? valid-ar?*) :arg13* (s/? valid-kr?*) :arg14* (s/? valid-ar?*) :arg15* (s/? valid-kr?*) :arg16* (s/? valid-ar?*) ))
(stest/instrument `mac)

(defn phaser2
  {:arglists '([asig kfreq kq kord kmode ksep kfeedback])}
  [sig freq q ord mode sep feedback]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "phaser2"
                      [sig freq q ord mode sep feedback]
                      *global*)]
    (new out-types ast)))

(s/fdef phaser2
  :args (s/cat :sig valid-ar? :freq valid-kr? :q valid-kr? :ord valid-kr? :mode valid-kr? :sep valid-kr? :feedback valid-kr? ))
(stest/instrument `phaser2)

(defn release
  {:arglists '()}
  []
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "release"
                      []
                      *global*)]
    (new out-types ast)))


(defn outletkid
  {:arglists '([Sname SinstanceID ksignal])}
  [name instanceID signal]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outletkid"
                      [name instanceID signal]
                      *global*)]
    (new out-types ast)))

(s/fdef outletkid
  :args (s/cat :name valid-S? :instanceID valid-S? :signal valid-kr? ))
(stest/instrument `outletkid)

(defn chebyshevpoly
  {:arglists '([ain & karg1* karg2* karg3* karg4* karg5* karg6* karg7* karg8* karg9* karg10* karg11* karg12* karg13* karg14* karg15* karg16*])}
  [in & [ arg1* arg2* arg3* arg4* arg5* arg6* arg7* arg8* arg9* arg10* arg11* arg12* arg13* arg14* arg15* arg16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "chebyshevpoly"
                      [in arg1* arg2* arg3* arg4* arg5* arg6* arg7* arg8* arg9* arg10* arg11* arg12* arg13* arg14* arg15* arg16*]
                      *global*)]
    (new out-types ast)))

(s/fdef chebyshevpoly
  :args (s/cat :in valid-ar? :arg1* (s/? valid-kr?*) :arg2* (s/? valid-kr?*) :arg3* (s/? valid-kr?*) :arg4* (s/? valid-kr?*) :arg5* (s/? valid-kr?*) :arg6* (s/? valid-kr?*) :arg7* (s/? valid-kr?*) :arg8* (s/? valid-kr?*) :arg9* (s/? valid-kr?*) :arg10* (s/? valid-kr?*) :arg11* (s/? valid-kr?*) :arg12* (s/? valid-kr?*) :arg13* (s/? valid-kr?*) :arg14* (s/? valid-kr?*) :arg15* (s/? valid-kr?*) :arg16* (s/? valid-kr?*) ))
(stest/instrument `chebyshevpoly)

(defn tab_i
  {:arglists '([iindex itable & imode*])}
  [index table & [ mode* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "tab_i"
                      [index table mode*]
                      *global*)]
    (new out-types ast)))

(s/fdef tab_i
  :args (s/cat :index valid-i? :table valid-i? :mode* (s/? valid-i?*) ))
(stest/instrument `tab_i)

(defn lpf18
  {:arglists '([asig xcutoff-frequency xresonance xdistortion & iskip*])}
  [sig cutoff-frequency resonance distortion & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "lpf18"
                      [sig cutoff-frequency resonance distortion skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef lpf18
  :args (s/cat :sig valid-ar? :cutoff-frequency valid-x? :resonance valid-x? :distortion valid-x? :skip* (s/? valid-i?*) ))
(stest/instrument `lpf18)

(defn table
  {:arglists '([xindex itable & ixmode* ixoff* iwrap*] [iindex itable & ixmode* ixoff* iwrap*] [xindex itable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "table"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef table
  :args (s/alt
         :iiiii (s/cat :index valid-i? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) )
         :xiiii (s/cat :index valid-x? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) )
         ))
(stest/instrument `table)

(defn table:a
  {:arglists '([xindex itable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "table"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef table:a
  :args (s/cat :index valid-x? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) ))
(stest/instrument `table:a)

(defn table:i
  {:arglists '([iindex itable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "table"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef table:i
  :args (s/cat :index valid-i? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) ))
(stest/instrument `table:i)

(defn table:k
  {:arglists '([xindex itable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "table"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef table:k
  :args (s/cat :index valid-x? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) ))
(stest/instrument `table:k)

(defn ftloadk
  {:arglists '([Sfilename ktrig iflag & ifn1* ifn2* ifn3* ifn4* ifn5* ifn6* ifn7* ifn8* ifn9* ifn10* ifn11* ifn12* ifn13* ifn14* ifn15* ifn16*] [ifilename ktrig iflag & ifn1* ifn2* ifn3* ifn4* ifn5* ifn6* ifn7* ifn8* ifn9* ifn10* ifn11* ifn12* ifn13* ifn14* ifn15* ifn16*])}
  [filename trig flag & [ fn1* fn2* fn3* fn4* fn5* fn6* fn7* fn8* fn9* fn10* fn11* fn12* fn13* fn14* fn15* fn16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "ftloadk"
                      [filename trig flag fn1* fn2* fn3* fn4* fn5* fn6* fn7* fn8* fn9* fn10* fn11* fn12* fn13* fn14* fn15* fn16*]
                      *global*)]
    (new out-types ast)))

(s/fdef ftloadk
  :args (s/alt
         :ikiiiiiiiiiiiiiiiii (s/cat :filename valid-i? :trig valid-kr? :flag valid-i? :fn1* (s/? valid-i?*) :fn2* (s/? valid-i?*) :fn3* (s/? valid-i?*) :fn4* (s/? valid-i?*) :fn5* (s/? valid-i?*) :fn6* (s/? valid-i?*) :fn7* (s/? valid-i?*) :fn8* (s/? valid-i?*) :fn9* (s/? valid-i?*) :fn10* (s/? valid-i?*) :fn11* (s/? valid-i?*) :fn12* (s/? valid-i?*) :fn13* (s/? valid-i?*) :fn14* (s/? valid-i?*) :fn15* (s/? valid-i?*) :fn16* (s/? valid-i?*) )
         :Skiiiiiiiiiiiiiiiii (s/cat :filename valid-S? :trig valid-kr? :flag valid-i? :fn1* (s/? valid-i?*) :fn2* (s/? valid-i?*) :fn3* (s/? valid-i?*) :fn4* (s/? valid-i?*) :fn5* (s/? valid-i?*) :fn6* (s/? valid-i?*) :fn7* (s/? valid-i?*) :fn8* (s/? valid-i?*) :fn9* (s/? valid-i?*) :fn10* (s/? valid-i?*) :fn11* (s/? valid-i?*) :fn12* (s/? valid-i?*) :fn13* (s/? valid-i?*) :fn14* (s/? valid-i?*) :fn15* (s/? valid-i?*) :fn16* (s/? valid-i?*) )
         ))
(stest/instrument `ftloadk)

(defn fink
  {:arglists '([Sfilename iskipframes iformat & kin1* kin2* kin3* kin4* kin5* kin6* kin7* kin8* kin9* kin10* kin11* kin12* kin13* kin14* kin15* kin16*] [ifilename iskipframes iformat & kin1* kin2* kin3* kin4* kin5* kin6* kin7* kin8* kin9* kin10* kin11* kin12* kin13* kin14* kin15* kin16*])}
  [filename skipframes format & [ in1* in2* in3* in4* in5* in6* in7* in8* in9* in10* in11* in12* in13* in14* in15* in16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "fink"
                      [filename skipframes format in1* in2* in3* in4* in5* in6* in7* in8* in9* in10* in11* in12* in13* in14* in15* in16*]
                      *global*)]
    (new out-types ast)))

(s/fdef fink
  :args (s/alt
         :iiikkkkkkkkkkkkkkkk (s/cat :filename valid-i? :skipframes valid-i? :format valid-i? :in1* (s/? valid-kr?*) :in2* (s/? valid-kr?*) :in3* (s/? valid-kr?*) :in4* (s/? valid-kr?*) :in5* (s/? valid-kr?*) :in6* (s/? valid-kr?*) :in7* (s/? valid-kr?*) :in8* (s/? valid-kr?*) :in9* (s/? valid-kr?*) :in10* (s/? valid-kr?*) :in11* (s/? valid-kr?*) :in12* (s/? valid-kr?*) :in13* (s/? valid-kr?*) :in14* (s/? valid-kr?*) :in15* (s/? valid-kr?*) :in16* (s/? valid-kr?*) )
         :Siikkkkkkkkkkkkkkkk (s/cat :filename valid-S? :skipframes valid-i? :format valid-i? :in1* (s/? valid-kr?*) :in2* (s/? valid-kr?*) :in3* (s/? valid-kr?*) :in4* (s/? valid-kr?*) :in5* (s/? valid-kr?*) :in6* (s/? valid-kr?*) :in7* (s/? valid-kr?*) :in8* (s/? valid-kr?*) :in9* (s/? valid-kr?*) :in10* (s/? valid-kr?*) :in11* (s/? valid-kr?*) :in12* (s/? valid-kr?*) :in13* (s/? valid-kr?*) :in14* (s/? valid-kr?*) :in15* (s/? valid-kr?*) :in16* (s/? valid-kr?*) )
         ))
(stest/instrument `fink)

(defn reson
  {:arglists '([asig xcenter-frequency xbandwidth & iscale* iskip*])}
  [sig center-frequency bandwidth & [ scale* skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "reson"
                      [sig center-frequency bandwidth scale* skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef reson
  :args (s/cat :sig valid-ar? :center-frequency valid-x? :bandwidth valid-x? :scale* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `reson)

(defn inq
  {:arglists '()}
  []
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "inq"
                      []
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))


(defn sensekey
  {:arglists '()}
  []
  (let [out-types-quoted '[ControlSignal ControlSignal]
        out-types [ControlSignal ControlSignal]
        ast (ast-node out-types-quoted
                      "sensekey"
                      []
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))


(defn cosseg
  {:arglists '([ia idur2 & ib1* idur2* ic3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*] [ia idur2 & ib1* idur2* ic3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a dur2 & [ b1* dur2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "cosseg"
                      [a dur2 b1* dur2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef cosseg
  :args (s/alt
         :iiiiiiiiiiiiiiiiii (s/cat :a valid-i? :dur2 valid-i? :b1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :c3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) )
         ))
(stest/instrument `cosseg)

(defn cosseg:a
  {:arglists '([ia idur2 & ib1* idur2* ic3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a dur2 & [ b1* dur2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "cosseg"
                      [a dur2 b1* dur2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef cosseg:a
  :args (s/cat :a valid-i? :dur2 valid-i? :b1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :c3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) ))
(stest/instrument `cosseg:a)

(defn cosseg:k
  {:arglists '([ia idur2 & ib1* idur2* ic3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a dur2 & [ b1* dur2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "cosseg"
                      [a dur2 b1* dur2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef cosseg:k
  :args (s/cat :a valid-i? :dur2 valid-i? :b1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :c3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) ))
(stest/instrument `cosseg:k)

(defn imagesize
  {:arglists '([iimagenum])}
  [imagenum]
  (let [out-types-quoted '[Variable Variable]
        out-types [Variable Variable]
        ast (ast-node out-types-quoted
                      "imagesize"
                      [imagenum]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef imagesize
  :args (s/cat :imagenum valid-i? ))
(stest/instrument `imagesize)

(defn ampmidi
  {:arglists '([iscal & itable*])}
  [scal & [ table* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "ampmidi"
                      [scal table*]
                      *global*)]
    (new out-types ast)))

(s/fdef ampmidi
  :args (s/cat :scal valid-i? :table* (s/? valid-i?*) ))
(stest/instrument `ampmidi)

(defn delay1
  {:arglists '([asig & iskip*])}
  [sig & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "delay1"
                      [sig skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef delay1
  :args (s/cat :sig valid-ar? :skip* (s/? valid-i?*) ))
(stest/instrument `delay1)

(defn areson
  {:arglists '([asig acenter-frequency abandwidth & iscale* iskip*] [asig acenter-frequency kbandwidth & iscale* iskip*] [asig kcenter-frequency abandwidth & iscale* iskip*] [asig kcenter-frequency kbandwidth & iscale* iskip*])}
  [sig center-frequency bandwidth & [ scale* skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "areson"
                      [sig center-frequency bandwidth scale* skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef areson
  :args (s/alt
         :akkii (s/cat :sig valid-ar? :center-frequency valid-kr? :bandwidth valid-kr? :scale* (s/? valid-i?*) :skip* (s/? valid-i?*) )
         :akaii (s/cat :sig valid-ar? :center-frequency valid-kr? :bandwidth valid-ar? :scale* (s/? valid-i?*) :skip* (s/? valid-i?*) )
         :aakii (s/cat :sig valid-ar? :center-frequency valid-ar? :bandwidth valid-kr? :scale* (s/? valid-i?*) :skip* (s/? valid-i?*) )
         :aaaii (s/cat :sig valid-ar? :center-frequency valid-ar? :bandwidth valid-ar? :scale* (s/? valid-i?*) :skip* (s/? valid-i?*) )
         ))
(stest/instrument `areson)

(defn oscilikts
  {:arglists '([xamp xcps ktable async kphase & istor*])}
  [amp cps table sync phase & [ stor* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "oscilikts"
                      [amp cps table sync phase stor*]
                      *global*)]
    (new out-types ast)))

(s/fdef oscilikts
  :args (s/cat :amp valid-x? :cps valid-x? :table valid-kr? :sync valid-ar? :phase valid-kr? :stor* (s/? valid-i?*) ))
(stest/instrument `oscilikts)

(defn outipb
  {:arglists '([ichn ivalue imin imax])}
  [chn value min max]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outipb"
                      [chn value min max]
                      *global*)]
    (new out-types ast)))

(s/fdef outipb
  :args (s/cat :chn valid-i? :value valid-i? :min valid-i? :max valid-i? ))
(stest/instrument `outipb)

(defn window
  {:arglists '([kinArr & koff* itype*])}
  [in & [ off* type* ]]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "window"
                      [in off* type*]
                      *global*)]
    (new out-types ast)))

(s/fdef window
  :args (s/cat :in valid-kArr? :off* (s/? valid-kr?*) :type* (s/? valid-i?*) ))
(stest/instrument `window)

(defn compress
  {:arglists '([aasig acsig kthresh kloknee khiknee kratio katt krel ilook])}
  [asig csig thresh loknee hiknee ratio att rel look]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "compress"
                      [asig csig thresh loknee hiknee ratio att rel look]
                      *global*)]
    (new out-types ast)))

(s/fdef compress
  :args (s/cat :asig valid-ar? :csig valid-ar? :thresh valid-kr? :loknee valid-kr? :hiknee valid-kr? :ratio valid-kr? :att valid-kr? :rel valid-kr? :look valid-i? ))
(stest/instrument `compress)

(defn tablefilteri
  {:arglists '([iouttable iintatble imode iparam])}
  [outtable intatble mode param]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "tablefilteri"
                      [outtable intatble mode param]
                      *global*)]
    (new out-types ast)))

(s/fdef tablefilteri
  :args (s/cat :outtable valid-i? :intatble valid-i? :mode valid-i? :param valid-i? ))
(stest/instrument `tablefilteri)

(defn adsynt2
  {:arglists '([kamp kcps iwfn ifreqfn iampfn icnt & iphase*])}
  [amp cps wfn freqfn ampfn cnt & [ phase* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "adsynt2"
                      [amp cps wfn freqfn ampfn cnt phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef adsynt2
  :args (s/cat :amp valid-kr? :cps valid-kr? :wfn valid-i? :freqfn valid-i? :ampfn valid-i? :cnt valid-i? :phase* (s/? valid-i?*) ))
(stest/instrument `adsynt2)

(defn sumarray
  {:arglists '([iarrayArr] [karrayArr])}
  [array]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "sumarray"
                      [array]
                      *global*)]
    (new out-types ast)))

(s/fdef sumarray
  :args (s/alt
         :kArr (s/cat :array valid-kArr? )
         :iArr (s/cat :array valid-iArr? )
         ))
(stest/instrument `sumarray)

(defn sumarray:i
  {:arglists '([iarrayArr])}
  [array]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "sumarray"
                      [array]
                      *global*)]
    (new out-types ast)))

(s/fdef sumarray:i
  :args (s/cat :array valid-iArr? ))
(stest/instrument `sumarray:i)

(defn sumarray:k
  {:arglists '([karrayArr])}
  [array]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "sumarray"
                      [array]
                      *global*)]
    (new out-types ast)))

(s/fdef sumarray:k
  :args (s/cat :array valid-kArr? ))
(stest/instrument `sumarray:k)

(defn paulstretch
  {:arglists '([istretch iwindowsize ift])}
  [stretch windowsize ft]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "paulstretch"
                      [stretch windowsize ft]
                      *global*)]
    (new out-types ast)))

(s/fdef paulstretch
  :args (s/cat :stretch valid-i? :windowsize valid-i? :ft valid-i? ))
(stest/instrument `paulstretch)

(defn dam
  {:arglists '([asig kthreshold icomp3 icomp4 irtime iftime])}
  [sig threshold comp3 comp4 rtime ftime]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "dam"
                      [sig threshold comp3 comp4 rtime ftime]
                      *global*)]
    (new out-types ast)))

(s/fdef dam
  :args (s/cat :sig valid-ar? :threshold valid-kr? :comp3 valid-i? :comp4 valid-i? :rtime valid-i? :ftime valid-i? ))
(stest/instrument `dam)

(defn midichn
  {:arglists '()}
  []
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "midichn"
                      []
                      *global*)]
    (new out-types ast)))


(defn pvsvoc
  {:arglists '([famp fexc kdepth kgain & kcoefs*])}
  [amp exc depth gain & [ coefs* ]]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvsvoc"
                      [amp exc depth gain coefs*]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsvoc
  :args (s/cat :amp valid-f? :exc valid-f? :depth valid-kr? :gain valid-kr? :coefs* (s/? valid-kr?*) ))
(stest/instrument `pvsvoc)

(defn chanctrl
  {:arglists '([ichnl ictlno & ilow* ihigh*] [ichnl ictlno & ilow* ihigh*])}
  [chnl ctlno & [ low* high* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "chanctrl"
                      [chnl ctlno low* high*]
                      *global*)]
    (new out-types ast)))

(s/fdef chanctrl
  :args (s/alt
         :iiii (s/cat :chnl valid-i? :ctlno valid-i? :low* (s/? valid-i?*) :high* (s/? valid-i?*) )
         ))
(stest/instrument `chanctrl)

(defn chanctrl:i
  {:arglists '([ichnl ictlno & ilow* ihigh*])}
  [chnl ctlno & [ low* high* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "chanctrl"
                      [chnl ctlno low* high*]
                      *global*)]
    (new out-types ast)))

(s/fdef chanctrl:i
  :args (s/cat :chnl valid-i? :ctlno valid-i? :low* (s/? valid-i?*) :high* (s/? valid-i?*) ))
(stest/instrument `chanctrl:i)

(defn chanctrl:k
  {:arglists '([ichnl ictlno & ilow* ihigh*])}
  [chnl ctlno & [ low* high* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "chanctrl"
                      [chnl ctlno low* high*]
                      *global*)]
    (new out-types ast)))

(s/fdef chanctrl:k
  :args (s/cat :chnl valid-i? :ctlno valid-i? :low* (s/? valid-i?*) :high* (s/? valid-i?*) ))
(stest/instrument `chanctrl:k)

(defn scalearray
  {:arglists '([iarrayArr imin imax & kleft* kright*] [karrayArr kmin kmax & kleft* kright*])}
  [array min max & [ left* right* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "scalearray"
                      [array min max left* right*]
                      *global*)]
    (new out-types ast)))

(s/fdef scalearray
  :args (s/alt
         :kArrkkkk (s/cat :array valid-kArr? :min valid-kr? :max valid-kr? :left* (s/? valid-kr?*) :right* (s/? valid-kr?*) )
         :iArriikk (s/cat :array valid-iArr? :min valid-i? :max valid-i? :left* (s/? valid-kr?*) :right* (s/? valid-kr?*) )
         ))
(stest/instrument `scalearray)

(defn pvsceps
  {:arglists '([fsig & icoefs*])}
  [sig & [ coefs* ]]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "pvsceps"
                      [sig coefs*]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsceps
  :args (s/cat :sig valid-f? :coefs* (s/? valid-i?*) ))
(stest/instrument `pvsceps)

(defn midinoteonpch
  {:arglists '([xpch xvelocity])}
  [pch velocity]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "midinoteonpch"
                      [pch velocity]
                      *global*)]
    (new out-types ast)))

(s/fdef midinoteonpch
  :args (s/cat :pch valid-x? :velocity valid-x? ))
(stest/instrument `midinoteonpch)

(defn strcmp
  {:arglists '([Sarg1 Sarg2])}
  [arg1 arg2]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "strcmp"
                      [arg1 arg2]
                      *global*)]
    (new out-types ast)))

(s/fdef strcmp
  :args (s/cat :arg1 valid-S? :arg2 valid-S? ))
(stest/instrument `strcmp)

(defn MixerClear
  {:arglists '()}
  []
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "MixerClear"
                      []
                      *global*)]
    (new out-types ast)))


(defn imagefree
  {:arglists '([iimagenum])}
  [imagenum]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "imagefree"
                      [imagenum]
                      *global*)]
    (new out-types ast)))

(s/fdef imagefree
  :args (s/cat :imagenum valid-i? ))
(stest/instrument `imagefree)

(defn dust
  {:arglists '([kamp kdensity] [kamp kdensity] [kamp kdensity])}
  [amp density]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "dust"
                      [amp density]
                      *global*)]
    (new out-types ast)))

(s/fdef dust
  :args (s/alt
         :kk (s/cat :amp valid-kr? :density valid-kr? )
         ))
(stest/instrument `dust)

(defn dust:a
  {:arglists '([kamp kdensity])}
  [amp density]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "dust"
                      [amp density]
                      *global*)]
    (new out-types ast)))

(s/fdef dust:a
  :args (s/cat :amp valid-kr? :density valid-kr? ))
(stest/instrument `dust:a)

(defn dust:k
  {:arglists '([kamp kdensity] [kamp kdensity])}
  [amp density]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "dust"
                      [amp density]
                      *global*)]
    (new out-types ast)))

(s/fdef dust:k
  :args (s/alt
         :kk (s/cat :amp valid-kr? :density valid-kr? )
         ))
(stest/instrument `dust:k)

(defn osciliktp
  {:arglists '([kcps ktable kphase & istor*])}
  [cps table phase & [ stor* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "osciliktp"
                      [cps table phase stor*]
                      *global*)]
    (new out-types ast)))

(s/fdef osciliktp
  :args (s/cat :cps valid-kr? :table valid-kr? :phase valid-kr? :stor* (s/? valid-i?*) ))
(stest/instrument `osciliktp)

(defn limit1
  {:arglists '([iargArr] [kargArr])}
  [arg]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "limit1"
                      [arg]
                      *global*)]
    (new out-types ast)))

(s/fdef limit1
  :args (s/alt
         :kArr (s/cat :arg valid-kArr? )
         :iArr (s/cat :arg valid-iArr? )
         ))
(stest/instrument `limit1)

(defn limit1:iArr
  {:arglists '([iargArr])}
  [arg]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "limit1"
                      [arg]
                      *global*)]
    (new out-types ast)))

(s/fdef limit1:iArr
  :args (s/cat :arg valid-iArr? ))
(stest/instrument `limit1:iArr)

(defn limit1:kArr
  {:arglists '([kargArr])}
  [arg]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "limit1"
                      [arg]
                      *global*)]
    (new out-types ast)))

(s/fdef limit1:kArr
  :args (s/cat :arg valid-kArr? ))
(stest/instrument `limit1:kArr)

(defn strtolk
  {:arglists '([Sindex])}
  [index]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "strtolk"
                      [index]
                      *global*)]
    (new out-types ast)))

(s/fdef strtolk
  :args (s/cat :index valid-S? ))
(stest/instrument `strtolk)

(defn mincer
  {:arglists '([atimpt kamp kpitch ktab klock & ifftsize* idecim*])}
  [timpt amp pitch tab lock & [ fftsize* decim* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "mincer"
                      [timpt amp pitch tab lock fftsize* decim*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef mincer
  :args (s/cat :timpt valid-ar? :amp valid-kr? :pitch valid-kr? :tab valid-kr? :lock valid-kr? :fftsize* (s/? valid-i?*) :decim* (s/? valid-i?*) ))
(stest/instrument `mincer)

(defn ptrack
  {:arglists '([asig ihopsize & ipeaks*])}
  [sig hopsize & [ peaks* ]]
  (let [out-types-quoted '[ControlSignal ControlSignal]
        out-types [ControlSignal ControlSignal]
        ast (ast-node out-types-quoted
                      "ptrack"
                      [sig hopsize peaks*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef ptrack
  :args (s/cat :sig valid-ar? :hopsize valid-i? :peaks* (s/? valid-i?*) ))
(stest/instrument `ptrack)

(defn xscanu
  {:arglists '([init irate ifnvel ifnmass Sfnstif ifncentr ifndamp kmass kstif kcentr kdamp ileft iright kpos kstrngth ain idisp id] [init irate ifnvel ifnmass ifnstif ifncentr ifndamp kmass kstif kcentr kdamp ileft iright kpos kstrngth ain idisp id])}
  [nit rate fnvel fnmass fnstif fncentr fndamp mass stif centr damp left right pos strngth in disp d]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "xscanu"
                      [nit rate fnvel fnmass fnstif fncentr fndamp mass stif centr damp left right pos strngth in disp d]
                      *global*)]
    (new out-types ast)))

(s/fdef xscanu
  :args (s/alt
         :iiiiiiikkkkiikkaii (s/cat :nit valid-i? :rate valid-i? :fnvel valid-i? :fnmass valid-i? :fnstif valid-i? :fncentr valid-i? :fndamp valid-i? :mass valid-kr? :stif valid-kr? :centr valid-kr? :damp valid-kr? :left valid-i? :right valid-i? :pos valid-kr? :strngth valid-kr? :in valid-ar? :disp valid-i? :d valid-i? )
         :iiiiSiikkkkiikkaii (s/cat :nit valid-i? :rate valid-i? :fnvel valid-i? :fnmass valid-i? :fnstif valid-S? :fncentr valid-i? :fndamp valid-i? :mass valid-kr? :stif valid-kr? :centr valid-kr? :damp valid-kr? :left valid-i? :right valid-i? :pos valid-kr? :strngth valid-kr? :in valid-ar? :disp valid-i? :d valid-i? )
         ))
(stest/instrument `xscanu)

(defn trscale
  {:arglists '([fin & kpitch1* kgain2* kgain3* kgain4* kgain5* kgain6* kgain7* kgain8* kgain9* kgain10* kgain11* kgain12* kgain13* kgain14* kgain15* kgain16*])}
  [in & [ pitch1* gain2* gain3* gain4* gain5* gain6* gain7* gain8* gain9* gain10* gain11* gain12* gain13* gain14* gain15* gain16* ]]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "trscale"
                      [in pitch1* gain2* gain3* gain4* gain5* gain6* gain7* gain8* gain9* gain10* gain11* gain12* gain13* gain14* gain15* gain16*]
                      *global*)]
    (new out-types ast)))

(s/fdef trscale
  :args (s/cat :in valid-f? :pitch1* (s/? valid-kr?*) :gain2* (s/? valid-kr?*) :gain3* (s/? valid-kr?*) :gain4* (s/? valid-kr?*) :gain5* (s/? valid-kr?*) :gain6* (s/? valid-kr?*) :gain7* (s/? valid-kr?*) :gain8* (s/? valid-kr?*) :gain9* (s/? valid-kr?*) :gain10* (s/? valid-kr?*) :gain11* (s/? valid-kr?*) :gain12* (s/? valid-kr?*) :gain13* (s/? valid-kr?*) :gain14* (s/? valid-kr?*) :gain15* (s/? valid-kr?*) :gain16* (s/? valid-kr?*) ))
(stest/instrument `trscale)

(defn vecdelay
  {:arglists '([itable ifnIn ifnDel ielements imaxdel & iskip*])}
  [table fnIn fnDel elements maxdel & [ skip* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vecdelay"
                      [table fnIn fnDel elements maxdel skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef vecdelay
  :args (s/cat :table valid-i? :fnIn valid-i? :fnDel valid-i? :elements valid-i? :maxdel valid-i? :skip* (s/? valid-i?*) ))
(stest/instrument `vecdelay)

(defn pvsfwrite
  {:arglists '([fsig Sfile] [fsig ifile])}
  [sig file]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "pvsfwrite"
                      [sig file]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsfwrite
  :args (s/alt
         :fi (s/cat :sig valid-f? :file valid-i? )
         :fS (s/cat :sig valid-f? :file valid-S? )
         ))
(stest/instrument `pvsfwrite)

(defn tvconv
  {:arglists '([asig1 asig2 xfreez3 xfreez4 iparts ifils])}
  [sig1 sig2 freez3 freez4 parts fils]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "tvconv"
                      [sig1 sig2 freez3 freez4 parts fils]
                      *global*)]
    (new out-types ast)))

(s/fdef tvconv
  :args (s/cat :sig1 valid-ar? :sig2 valid-ar? :freez3 valid-x? :freez4 valid-x? :parts valid-i? :fils valid-i? ))
(stest/instrument `tvconv)

(defn getrow
  {:arglists '([kinArr krow])}
  [in row]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "getrow"
                      [in row]
                      *global*)]
    (new out-types ast)))

(s/fdef getrow
  :args (s/cat :in valid-kArr? :row valid-kr? ))
(stest/instrument `getrow)

(defn ino
  {:arglists '()}
  []
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "ino"
                      []
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))


(defn pvoc
  {:arglists '([ktimpnt kfmod Sfilcod & ispecwp* iextractmode* ifreqlim* igatefn*] [ktimpnt kfmod ifilcod & ispecwp* iextractmode* ifreqlim* igatefn*])}
  [timpnt fmod filcod & [ specwp* extractmode* freqlim* gatefn* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "pvoc"
                      [timpnt fmod filcod specwp* extractmode* freqlim* gatefn*]
                      *global*)]
    (new out-types ast)))

(s/fdef pvoc
  :args (s/alt
         :kkiiiii (s/cat :timpnt valid-kr? :fmod valid-kr? :filcod valid-i? :specwp* (s/? valid-i?*) :extractmode* (s/? valid-i?*) :freqlim* (s/? valid-i?*) :gatefn* (s/? valid-i?*) )
         :kkSiiii (s/cat :timpnt valid-kr? :fmod valid-kr? :filcod valid-S? :specwp* (s/? valid-i?*) :extractmode* (s/? valid-i?*) :freqlim* (s/? valid-i?*) :gatefn* (s/? valid-i?*) )
         ))
(stest/instrument `pvoc)

(defn vbapgmove
  {:arglists '([idur ispread ifldnum & ifld1* ifld2* ifld3* ifld4* ifld5* ifld6* ifld7* ifld8* ifld9* ifld10* ifld11* ifld12* ifld13* ifld14* ifld15* ifld16*] [idur ispread ifldnum & ifld1* ifld2* ifld3* ifld4* ifld5* ifld6* ifld7* ifld8* ifld9* ifld10* ifld11* ifld12* ifld13* ifld14* ifld15* ifld16*])}
  [dur spread fldnum & [ fld1* fld2* fld3* fld4* fld5* fld6* fld7* fld8* fld9* fld10* fld11* fld12* fld13* fld14* fld15* fld16* ]]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "vbapgmove"
                      [dur spread fldnum fld1* fld2* fld3* fld4* fld5* fld6* fld7* fld8* fld9* fld10* fld11* fld12* fld13* fld14* fld15* fld16*]
                      *global*)]
    (new out-types ast)))

(s/fdef vbapgmove
  :args (s/alt
         :iiiiiiiiiiiiiiiiiii (s/cat :dur valid-i? :spread valid-i? :fldnum valid-i? :fld1* (s/? valid-i?*) :fld2* (s/? valid-i?*) :fld3* (s/? valid-i?*) :fld4* (s/? valid-i?*) :fld5* (s/? valid-i?*) :fld6* (s/? valid-i?*) :fld7* (s/? valid-i?*) :fld8* (s/? valid-i?*) :fld9* (s/? valid-i?*) :fld10* (s/? valid-i?*) :fld11* (s/? valid-i?*) :fld12* (s/? valid-i?*) :fld13* (s/? valid-i?*) :fld14* (s/? valid-i?*) :fld15* (s/? valid-i?*) :fld16* (s/? valid-i?*) )
         ))
(stest/instrument `vbapgmove)

(defn vbapgmove:kArr
  {:arglists '([idur ispread ifldnum & ifld1* ifld2* ifld3* ifld4* ifld5* ifld6* ifld7* ifld8* ifld9* ifld10* ifld11* ifld12* ifld13* ifld14* ifld15* ifld16*])}
  [dur spread fldnum & [ fld1* fld2* fld3* fld4* fld5* fld6* fld7* fld8* fld9* fld10* fld11* fld12* fld13* fld14* fld15* fld16* ]]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "vbapgmove"
                      [dur spread fldnum fld1* fld2* fld3* fld4* fld5* fld6* fld7* fld8* fld9* fld10* fld11* fld12* fld13* fld14* fld15* fld16*]
                      *global*)]
    (new out-types ast)))

(s/fdef vbapgmove:kArr
  :args (s/cat :dur valid-i? :spread valid-i? :fldnum valid-i? :fld1* (s/? valid-i?*) :fld2* (s/? valid-i?*) :fld3* (s/? valid-i?*) :fld4* (s/? valid-i?*) :fld5* (s/? valid-i?*) :fld6* (s/? valid-i?*) :fld7* (s/? valid-i?*) :fld8* (s/? valid-i?*) :fld9* (s/? valid-i?*) :fld10* (s/? valid-i?*) :fld11* (s/? valid-i?*) :fld12* (s/? valid-i?*) :fld13* (s/? valid-i?*) :fld14* (s/? valid-i?*) :fld15* (s/? valid-i?*) :fld16* (s/? valid-i?*) ))
(stest/instrument `vbapgmove:kArr)

(defn vbapgmove:k
  {:arglists '([idur ispread ifldnum & ifld1* ifld2* ifld3* ifld4* ifld5* ifld6* ifld7* ifld8* ifld9* ifld10* ifld11* ifld12* ifld13* ifld14* ifld15* ifld16*])}
  [dur spread fldnum & [ fld1* fld2* fld3* fld4* fld5* fld6* fld7* fld8* fld9* fld10* fld11* fld12* fld13* fld14* fld15* fld16* ]]
  (let [out-types-quoted '[ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal]
        out-types [ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal]
        ast (ast-node out-types-quoted
                      "vbapgmove"
                      [dur spread fldnum fld1* fld2* fld3* fld4* fld5* fld6* fld7* fld8* fld9* fld10* fld11* fld12* fld13* fld14* fld15* fld16*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef vbapgmove:k
  :args (s/cat :dur valid-i? :spread valid-i? :fldnum valid-i? :fld1* (s/? valid-i?*) :fld2* (s/? valid-i?*) :fld3* (s/? valid-i?*) :fld4* (s/? valid-i?*) :fld5* (s/? valid-i?*) :fld6* (s/? valid-i?*) :fld7* (s/? valid-i?*) :fld8* (s/? valid-i?*) :fld9* (s/? valid-i?*) :fld10* (s/? valid-i?*) :fld11* (s/? valid-i?*) :fld12* (s/? valid-i?*) :fld13* (s/? valid-i?*) :fld14* (s/? valid-i?*) :fld15* (s/? valid-i?*) :fld16* (s/? valid-i?*) ))
(stest/instrument `vbapgmove:k)

(defn filescal
  {:arglists '([ktimescal kamp kpitch Sfile klock & ifftsize* idecim* kthresh* kthresh* kthresh*])}
  [timescal amp pitch file lock & [ fftsize* decim* thresh* thresh* thresh* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "filescal"
                      [timescal amp pitch file lock fftsize* decim* thresh* thresh* thresh*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef filescal
  :args (s/cat :timescal valid-kr? :amp valid-kr? :pitch valid-kr? :file valid-S? :lock valid-kr? :fftsize* (s/? valid-i?*) :decim* (s/? valid-i?*) :thresh* (s/? valid-kr?*) :thresh* (s/? valid-kr?*) :thresh* (s/? valid-kr?*) ))
(stest/instrument `filescal)

(defn pvbufread
  {:arglists '([ktimpnt Sfile] [ktimpnt ifile])}
  [timpnt file]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "pvbufread"
                      [timpnt file]
                      *global*)]
    (new out-types ast)))

(s/fdef pvbufread
  :args (s/alt
         :ki (s/cat :timpnt valid-kr? :file valid-i? )
         :kS (s/cat :timpnt valid-kr? :file valid-S? )
         ))
(stest/instrument `pvbufread)

(defn inletk
  {:arglists '([Sname])}
  [name]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "inletk"
                      [name]
                      *global*)]
    (new out-types ast)))

(s/fdef inletk
  :args (s/cat :name valid-S? ))
(stest/instrument `inletk)

(defn exprand
  {:arglists '([klambda] [klambda] [klambda])}
  [lambda]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "exprand"
                      [lambda]
                      *global*)]
    (new out-types ast)))

(s/fdef exprand
  :args (s/alt
         :k (s/cat :lambda valid-kr? )
         ))
(stest/instrument `exprand)

(defn exprand:a
  {:arglists '([klambda])}
  [lambda]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "exprand"
                      [lambda]
                      *global*)]
    (new out-types ast)))

(s/fdef exprand:a
  :args (s/cat :lambda valid-kr? ))
(stest/instrument `exprand:a)

(defn exprand:i
  {:arglists '([klambda])}
  [lambda]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "exprand"
                      [lambda]
                      *global*)]
    (new out-types ast)))

(s/fdef exprand:i
  :args (s/cat :lambda valid-kr? ))
(stest/instrument `exprand:i)

(defn exprand:k
  {:arglists '([klambda])}
  [lambda]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "exprand"
                      [lambda]
                      *global*)]
    (new out-types ast)))

(s/fdef exprand:k
  :args (s/cat :lambda valid-kr? ))
(stest/instrument `exprand:k)

(defn strchark
  {:arglists '([Sstr & kpos*])}
  [str & [ pos* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "strchark"
                      [str pos*]
                      *global*)]
    (new out-types ast)))

(s/fdef strchark
  :args (s/cat :str valid-S? :pos* (s/? valid-kr?*) ))
(stest/instrument `strchark)

(defn tabrec
  {:arglists '([ktrig_start ktrig_stop knumtics ktable & kin1* kin2* kinN3* kinN4* kinN5* kinN6* kinN7* kinN8* kinN9* kinN10* kinN11* kinN12* kinN13* kinN14* kinN15* kinN16*])}
  [trig_start trig_stop numtics table & [ in1* in2* inN3* inN4* inN5* inN6* inN7* inN8* inN9* inN10* inN11* inN12* inN13* inN14* inN15* inN16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "tabrec"
                      [trig_start trig_stop numtics table in1* in2* inN3* inN4* inN5* inN6* inN7* inN8* inN9* inN10* inN11* inN12* inN13* inN14* inN15* inN16*]
                      *global*)]
    (new out-types ast)))

(s/fdef tabrec
  :args (s/cat :trig_start valid-kr? :trig_stop valid-kr? :numtics valid-kr? :table valid-kr? :in1* (s/? valid-kr?*) :in2* (s/? valid-kr?*) :inN3* (s/? valid-kr?*) :inN4* (s/? valid-kr?*) :inN5* (s/? valid-kr?*) :inN6* (s/? valid-kr?*) :inN7* (s/? valid-kr?*) :inN8* (s/? valid-kr?*) :inN9* (s/? valid-kr?*) :inN10* (s/? valid-kr?*) :inN11* (s/? valid-kr?*) :inN12* (s/? valid-kr?*) :inN13* (s/? valid-kr?*) :inN14* (s/? valid-kr?*) :inN15* (s/? valid-kr?*) :inN16* (s/? valid-kr?*) ))
(stest/instrument `tabrec)

(defn gogobel
  {:arglists '([kamp kfreq ihrd ipos imp kvibf kvamp ivfn])}
  [amp freq hrd pos mp vibf vamp vfn]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "gogobel"
                      [amp freq hrd pos mp vibf vamp vfn]
                      *global*)]
    (new out-types ast)))

(s/fdef gogobel
  :args (s/cat :amp valid-kr? :freq valid-kr? :hrd valid-i? :pos valid-i? :mp valid-i? :vibf valid-kr? :vamp valid-kr? :vfn valid-i? ))
(stest/instrument `gogobel)

(defn out32
  {:arglists '([& asig1* asig2* asig3* asig4* asig5* asig6* asig7* asig8* asig9* asig10* asig11* asig12* asig13* asig14* asig15* asig16* asig17* asig18* asig19* asig20* asig21* asig22* asig23* asig24* asig25* asig26* asig27* asig28* asig29* asig30* asig31* asig32*])}
  [& [ sig1* sig2* sig3* sig4* sig5* sig6* sig7* sig8* sig9* sig10* sig11* sig12* sig13* sig14* sig15* sig16* sig17* sig18* sig19* sig20* sig21* sig22* sig23* sig24* sig25* sig26* sig27* sig28* sig29* sig30* sig31* sig32* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "out32"
                      [sig1* sig2* sig3* sig4* sig5* sig6* sig7* sig8* sig9* sig10* sig11* sig12* sig13* sig14* sig15* sig16* sig17* sig18* sig19* sig20* sig21* sig22* sig23* sig24* sig25* sig26* sig27* sig28* sig29* sig30* sig31* sig32*]
                      *global*)]
    (new out-types ast)))

(s/fdef out32
  :args (s/cat :sig1* (s/? valid-ar?*) :sig2* (s/? valid-ar?*) :sig3* (s/? valid-ar?*) :sig4* (s/? valid-ar?*) :sig5* (s/? valid-ar?*) :sig6* (s/? valid-ar?*) :sig7* (s/? valid-ar?*) :sig8* (s/? valid-ar?*) :sig9* (s/? valid-ar?*) :sig10* (s/? valid-ar?*) :sig11* (s/? valid-ar?*) :sig12* (s/? valid-ar?*) :sig13* (s/? valid-ar?*) :sig14* (s/? valid-ar?*) :sig15* (s/? valid-ar?*) :sig16* (s/? valid-ar?*) :sig17* (s/? valid-ar?*) :sig18* (s/? valid-ar?*) :sig19* (s/? valid-ar?*) :sig20* (s/? valid-ar?*) :sig21* (s/? valid-ar?*) :sig22* (s/? valid-ar?*) :sig23* (s/? valid-ar?*) :sig24* (s/? valid-ar?*) :sig25* (s/? valid-ar?*) :sig26* (s/? valid-ar?*) :sig27* (s/? valid-ar?*) :sig28* (s/? valid-ar?*) :sig29* (s/? valid-ar?*) :sig30* (s/? valid-ar?*) :sig31* (s/? valid-ar?*) :sig32* (s/? valid-ar?*) ))
(stest/instrument `out32)

(defn cauchyi
  {:arglists '([klambda xamp xcps] [klambda xamp xcps] [klambda xamp xcps])}
  [lambda amp cps]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "cauchyi"
                      [lambda amp cps]
                      *global*)]
    (new out-types ast)))

(s/fdef cauchyi
  :args (s/alt
         :kxx (s/cat :lambda valid-kr? :amp valid-x? :cps valid-x? )
         ))
(stest/instrument `cauchyi)

(defn cauchyi:a
  {:arglists '([klambda xamp xcps])}
  [lambda amp cps]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "cauchyi"
                      [lambda amp cps]
                      *global*)]
    (new out-types ast)))

(s/fdef cauchyi:a
  :args (s/cat :lambda valid-kr? :amp valid-x? :cps valid-x? ))
(stest/instrument `cauchyi:a)

(defn cauchyi:i
  {:arglists '([klambda xamp xcps])}
  [lambda amp cps]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "cauchyi"
                      [lambda amp cps]
                      *global*)]
    (new out-types ast)))

(s/fdef cauchyi:i
  :args (s/cat :lambda valid-kr? :amp valid-x? :cps valid-x? ))
(stest/instrument `cauchyi:i)

(defn cauchyi:k
  {:arglists '([klambda xamp xcps])}
  [lambda amp cps]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "cauchyi"
                      [lambda amp cps]
                      *global*)]
    (new out-types ast)))

(s/fdef cauchyi:k
  :args (s/cat :lambda valid-kr? :amp valid-x? :cps valid-x? ))
(stest/instrument `cauchyi:k)

(defn space
  {:arglists '([asig itable ktime kreverbsend kx ky])}
  [sig table time reverbsend x y]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "space"
                      [sig table time reverbsend x y]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef space
  :args (s/cat :sig valid-ar? :table valid-i? :time valid-kr? :reverbsend valid-kr? :x valid-kr? :y valid-kr? ))
(stest/instrument `space)

(defn distort
  {:arglists '([asig kdistortion itable & ihp* istor*])}
  [sig distortion table & [ hp* stor* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "distort"
                      [sig distortion table hp* stor*]
                      *global*)]
    (new out-types ast)))

(s/fdef distort
  :args (s/cat :sig valid-ar? :distortion valid-kr? :table valid-i? :hp* (s/? valid-i?*) :stor* (s/? valid-i?*) ))
(stest/instrument `distort)

(defn midinoteonoct
  {:arglists '([xoct xvelocity])}
  [oct velocity]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "midinoteonoct"
                      [oct velocity]
                      *global*)]
    (new out-types ast)))

(s/fdef midinoteonoct
  :args (s/cat :oct valid-x? :velocity valid-x? ))
(stest/instrument `midinoteonoct)

(defn random
  {:arglists '([kmin kmax] [imin imax] [kmin kmax])}
  [min max]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "random"
                      [min max]
                      *global*)]
    (new out-types ast)))

(s/fdef random
  :args (s/alt
         :ii (s/cat :min valid-i? :max valid-i? )
         :kk (s/cat :min valid-kr? :max valid-kr? )
         ))
(stest/instrument `random)

(defn random:a
  {:arglists '([kmin kmax])}
  [min max]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "random"
                      [min max]
                      *global*)]
    (new out-types ast)))

(s/fdef random:a
  :args (s/cat :min valid-kr? :max valid-kr? ))
(stest/instrument `random:a)

(defn random:i
  {:arglists '([imin imax])}
  [min max]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "random"
                      [min max]
                      *global*)]
    (new out-types ast)))

(s/fdef random:i
  :args (s/cat :min valid-i? :max valid-i? ))
(stest/instrument `random:i)

(defn random:k
  {:arglists '([kmin kmax])}
  [min max]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "random"
                      [min max]
                      *global*)]
    (new out-types ast)))

(s/fdef random:k
  :args (s/cat :min valid-kr? :max valid-kr? ))
(stest/instrument `random:k)

(defn sndloop
  {:arglists '([ain kpitch ktrig idur ifad])}
  [in pitch trig dur fad]
  (let [out-types-quoted '[AudioSignal ControlSignal]
        out-types [AudioSignal ControlSignal]
        ast (ast-node out-types-quoted
                      "sndloop"
                      [in pitch trig dur fad]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef sndloop
  :args (s/cat :in valid-ar? :pitch valid-kr? :trig valid-kr? :dur valid-i? :fad valid-i? ))
(stest/instrument `sndloop)

(defn oscbnk
  {:arglists '([kcps kamd kfmd kpmd iovrlap iseed kl1minf kl1maxf kl2minf kl2maxf ilfomode keqminf keqmaxf keqminl keqmaxl keqminq keqmaxq ieqmode ktable & il1fn* il2fn* ieqffn* ieqlfn* ieqqfn* itabl* ioutfn*])}
  [cps amd fmd pmd ovrlap seed l1minf l1maxf l2minf l2maxf lfomode eqminf eqmaxf eqminl eqmaxl eqminq eqmaxq eqmode table & [ l1fn* l2fn* eqffn* eqlfn* eqqfn* tabl* outfn* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "oscbnk"
                      [cps amd fmd pmd ovrlap seed l1minf l1maxf l2minf l2maxf lfomode eqminf eqmaxf eqminl eqmaxl eqminq eqmaxq eqmode table l1fn* l2fn* eqffn* eqlfn* eqqfn* tabl* outfn*]
                      *global*)]
    (new out-types ast)))

(s/fdef oscbnk
  :args (s/cat :cps valid-kr? :amd valid-kr? :fmd valid-kr? :pmd valid-kr? :ovrlap valid-i? :seed valid-i? :l1minf valid-kr? :l1maxf valid-kr? :l2minf valid-kr? :l2maxf valid-kr? :lfomode valid-i? :eqminf valid-kr? :eqmaxf valid-kr? :eqminl valid-kr? :eqmaxl valid-kr? :eqminq valid-kr? :eqmaxq valid-kr? :eqmode valid-i? :table valid-kr? :l1fn* (s/? valid-i?*) :l2fn* (s/? valid-i?*) :eqffn* (s/? valid-i?*) :eqlfn* (s/? valid-i?*) :eqqfn* (s/? valid-i?*) :tabl* (s/? valid-i?*) :outfn* (s/? valid-i?*) ))
(stest/instrument `oscbnk)

(defn loscil3
  {:arglists '([xamp kcps & itable* ibas* imod1* ibeg1* iend1* imod1* ibeg1* iend1*])}
  [amp cps & [ table* bas* mod1* beg1* end1* mod1* beg1* end1* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "loscil3"
                      [amp cps table* bas* mod1* beg1* end1* mod1* beg1* end1*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef loscil3
  :args (s/cat :amp valid-x? :cps valid-kr? :table* (s/? valid-i?*) :bas* (s/? valid-i?*) :mod1* (s/? valid-i?*) :beg1* (s/? valid-i?*) :end1* (s/? valid-i?*) :mod1* (s/? valid-i?*) :beg1* (s/? valid-i?*) :end1* (s/? valid-i?*) ))
(stest/instrument `loscil3)

(defn trirand
  {:arglists '([krange] [krange] [krange])}
  [range]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "trirand"
                      [range]
                      *global*)]
    (new out-types ast)))

(s/fdef trirand
  :args (s/alt
         :k (s/cat :range valid-kr? )
         ))
(stest/instrument `trirand)

(defn trirand:a
  {:arglists '([krange])}
  [range]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "trirand"
                      [range]
                      *global*)]
    (new out-types ast)))

(s/fdef trirand:a
  :args (s/cat :range valid-kr? ))
(stest/instrument `trirand:a)

(defn trirand:i
  {:arglists '([krange])}
  [range]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "trirand"
                      [range]
                      *global*)]
    (new out-types ast)))

(s/fdef trirand:i
  :args (s/cat :range valid-kr? ))
(stest/instrument `trirand:i)

(defn trirand:k
  {:arglists '([krange])}
  [range]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "trirand"
                      [range]
                      *global*)]
    (new out-types ast)))

(s/fdef trirand:k
  :args (s/cat :range valid-kr? ))
(stest/instrument `trirand:k)

(defn pvsblur
  {:arglists '([fsigin kblurtime imaxdel])}
  [sigin blurtime maxdel]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvsblur"
                      [sigin blurtime maxdel]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsblur
  :args (s/cat :sigin valid-f? :blurtime valid-kr? :maxdel valid-i? ))
(stest/instrument `pvsblur)

(defn adsyn
  {:arglists '([kamod kfmod ksmod Sfilcod & ifilcod*] [kamod kfmod ksmod ifilcod & ifilcod*])}
  [amod fmod smod filcod & [ filcod* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "adsyn"
                      [amod fmod smod filcod filcod*]
                      *global*)]
    (new out-types ast)))

(s/fdef adsyn
  :args (s/alt
         :kkkii (s/cat :amod valid-kr? :fmod valid-kr? :smod valid-kr? :filcod valid-i? :filcod* (s/? valid-i?*) )
         :kkkSi (s/cat :amod valid-kr? :fmod valid-kr? :smod valid-kr? :filcod valid-S? :filcod* (s/? valid-i?*) )
         ))
(stest/instrument `adsyn)

(defn cosh
  {:arglists '([aarg1] [iarg1] [iarg1Arr] [karg1] [karg1Arr])}
  [arg1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "cosh"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef cosh
  :args (s/alt
         :kArr (s/cat :arg1 valid-kArr? )
         :k (s/cat :arg1 valid-kr? )
         :iArr (s/cat :arg1 valid-iArr? )
         :i (s/cat :arg1 valid-i? )
         :a (s/cat :arg1 valid-ar? )
         ))
(stest/instrument `cosh)

(defn cosh:a
  {:arglists '([aarg1])}
  [arg1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "cosh"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef cosh:a
  :args (s/cat :arg1 valid-ar? ))
(stest/instrument `cosh:a)

(defn cosh:i
  {:arglists '([iarg1])}
  [arg1]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "cosh"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef cosh:i
  :args (s/cat :arg1 valid-i? ))
(stest/instrument `cosh:i)

(defn cosh:iArr
  {:arglists '([iarg1Arr])}
  [arg1]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "cosh"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef cosh:iArr
  :args (s/cat :arg1 valid-iArr? ))
(stest/instrument `cosh:iArr)

(defn cosh:k
  {:arglists '([karg1])}
  [arg1]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "cosh"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef cosh:k
  :args (s/cat :arg1 valid-kr? ))
(stest/instrument `cosh:k)

(defn cosh:kArr
  {:arglists '([karg1Arr])}
  [arg1]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "cosh"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef cosh:kArr
  :args (s/cat :arg1 valid-kArr? ))
(stest/instrument `cosh:kArr)

(defn readk3
  {:arglists '([Sfilname iformat iprd] [ifilname iformat iprd])}
  [filname format prd]
  (let [out-types-quoted '[ControlSignal ControlSignal ControlSignal]
        out-types [ControlSignal ControlSignal ControlSignal]
        ast (ast-node out-types-quoted
                      "readk3"
                      [filname format prd]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef readk3
  :args (s/alt
         :iii (s/cat :filname valid-i? :format valid-i? :prd valid-i? )
         :Sii (s/cat :filname valid-S? :format valid-i? :prd valid-i? )
         ))
(stest/instrument `readk3)

(defn fmwurlie
  {:arglists '([kamp kfreq kc3 kc4 kvdepth kvrate ifn7 ifn8 ifn9 ifn10 ivfn])}
  [amp freq c3 c4 vdepth vrate fn7 fn8 fn9 fn10 vfn]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "fmwurlie"
                      [amp freq c3 c4 vdepth vrate fn7 fn8 fn9 fn10 vfn]
                      *global*)]
    (new out-types ast)))

(s/fdef fmwurlie
  :args (s/cat :amp valid-kr? :freq valid-kr? :c3 valid-kr? :c4 valid-kr? :vdepth valid-kr? :vrate valid-kr? :fn7 valid-i? :fn8 valid-i? :fn9 valid-i? :fn10 valid-i? :vfn valid-i? ))
(stest/instrument `fmwurlie)

(defn outkpat
  {:arglists '([kchn knotenum kvalue kmin kmax])}
  [chn notenum value min max]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outkpat"
                      [chn notenum value min max]
                      *global*)]
    (new out-types ast)))

(s/fdef outkpat
  :args (s/cat :chn valid-kr? :notenum valid-kr? :value valid-kr? :min valid-kr? :max valid-kr? ))
(stest/instrument `outkpat)

(defn vdelayxw
  {:arglists '([ain adl imd iws & ist*])}
  [in dl md ws & [ st* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "vdelayxw"
                      [in dl md ws st*]
                      *global*)]
    (new out-types ast)))

(s/fdef vdelayxw
  :args (s/cat :in valid-ar? :dl valid-ar? :md valid-i? :ws valid-i? :st* (s/? valid-i?*) ))
(stest/instrument `vdelayxw)

(defn getftargs
  {:arglists '([iftno ktrig])}
  [ftno trig]
  (let [out-types-quoted 'String
        out-types String
        ast (ast-node out-types-quoted
                      "getftargs"
                      [ftno trig]
                      *global*)]
    (new out-types ast)))

(s/fdef getftargs
  :args (s/cat :ftno valid-i? :trig valid-kr? ))
(stest/instrument `getftargs)

(defn vdel_k
  {:arglists '([ksig kdelay imaxdelay & imode*])}
  [sig delay maxdelay & [ mode* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "vdel_k"
                      [sig delay maxdelay mode*]
                      *global*)]
    (new out-types ast)))

(s/fdef vdel_k
  :args (s/cat :sig valid-kr? :delay valid-kr? :maxdelay valid-i? :mode* (s/? valid-i?*) ))
(stest/instrument `vdel_k)

(defn tival
  {:arglists '()}
  []
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "tival"
                      []
                      *global*)]
    (new out-types ast)))


(defn copyf2array
  {:arglists '([iabArr iftbl] [kabArr kftbl])}
  [ab ftbl]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "copyf2array"
                      [ab ftbl]
                      *global*)]
    (new out-types ast)))

(s/fdef copyf2array
  :args (s/alt
         :kArrk (s/cat :ab valid-kArr? :ftbl valid-kr? )
         :iArri (s/cat :ab valid-iArr? :ftbl valid-i? )
         ))
(stest/instrument `copyf2array)

(defn lpinterp
  {:arglists '([islot1 islot2 kmix])}
  [slot1 slot2 mix]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "lpinterp"
                      [slot1 slot2 mix]
                      *global*)]
    (new out-types ast)))

(s/fdef lpinterp
  :args (s/cat :slot1 valid-i? :slot2 valid-i? :mix valid-kr? ))
(stest/instrument `lpinterp)

(defn clockon
  {:arglists '([inum])}
  [num]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "clockon"
                      [num]
                      *global*)]
    (new out-types ast)))

(s/fdef clockon
  :args (s/cat :num valid-i? ))
(stest/instrument `clockon)

(defn fmpercfl
  {:arglists '([kamp kfreq kc3 kc4 kvdepth kvrate & ifn1* ifn1* ifn1* ifn1* ivfn*])}
  [amp freq c3 c4 vdepth vrate & [ fn1* fn1* fn1* fn1* vfn* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "fmpercfl"
                      [amp freq c3 c4 vdepth vrate fn1* fn1* fn1* fn1* vfn*]
                      *global*)]
    (new out-types ast)))

(s/fdef fmpercfl
  :args (s/cat :amp valid-kr? :freq valid-kr? :c3 valid-kr? :c4 valid-kr? :vdepth valid-kr? :vrate valid-kr? :fn1* (s/? valid-i?*) :fn1* (s/? valid-i?*) :fn1* (s/? valid-i?*) :fn1* (s/? valid-i?*) :vfn* (s/? valid-i?*) ))
(stest/instrument `fmpercfl)

(defn pvread
  {:arglists '([ktimpnt Sfile ibin] [ktimpnt ifile ibin])}
  [timpnt file bin]
  (let [out-types-quoted '[ControlSignal ControlSignal]
        out-types [ControlSignal ControlSignal]
        ast (ast-node out-types-quoted
                      "pvread"
                      [timpnt file bin]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef pvread
  :args (s/alt
         :kii (s/cat :timpnt valid-kr? :file valid-i? :bin valid-i? )
         :kSi (s/cat :timpnt valid-kr? :file valid-S? :bin valid-i? )
         ))
(stest/instrument `pvread)

(defn zaw
  {:arglists '([asig kindex])}
  [sig index]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "zaw"
                      [sig index]
                      *global*)]
    (new out-types ast)))

(s/fdef zaw
  :args (s/cat :sig valid-ar? :index valid-kr? ))
(stest/instrument `zaw)

(defn balance
  {:arglists '([asig acomp & ihp* iskip*])}
  [sig comp & [ hp* skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "balance"
                      [sig comp hp* skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef balance
  :args (s/cat :sig valid-ar? :comp valid-ar? :hp* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `balance)

(defn tabifd
  {:arglists '([ktimpt kamp kpitch ifftsize ihopsize iwintype itable])}
  [timpt amp pitch fftsize hopsize wintype table]
  (let [out-types-quoted '[FrequencySignal FrequencySignal]
        out-types [FrequencySignal FrequencySignal]
        ast (ast-node out-types-quoted
                      "tabifd"
                      [timpt amp pitch fftsize hopsize wintype table]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef tabifd
  :args (s/cat :timpt valid-kr? :amp valid-kr? :pitch valid-kr? :fftsize valid-i? :hopsize valid-i? :wintype valid-i? :table valid-i? ))
(stest/instrument `tabifd)

(defn filepeak
  {:arglists '([Sfilcod & ichnl*] [ifilcod & ichnl*])}
  [filcod & [ chnl* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "filepeak"
                      [filcod chnl*]
                      *global*)]
    (new out-types ast)))

(s/fdef filepeak
  :args (s/alt
         :ii (s/cat :filcod valid-i? :chnl* (s/? valid-i?*) )
         :Si (s/cat :filcod valid-S? :chnl* (s/? valid-i?*) )
         ))
(stest/instrument `filepeak)

(defn lowpass2
  {:arglists '([asig acenter-frequency aq & iskip*] [asig acenter-frequency kq askip & iskip*] [asig kcenter-frequency aq & iskip*] [asig kcenter-frequency kq & iskip*])}
  [sig center-frequency q & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "lowpass2"
                      [sig center-frequency q skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef lowpass2
  :args (s/alt
         :akki (s/cat :sig valid-ar? :center-frequency valid-kr? :q valid-kr? :skip* (s/? valid-i?*) )
         :akai (s/cat :sig valid-ar? :center-frequency valid-kr? :q valid-ar? :skip* (s/? valid-i?*) )
         :aakai (s/cat :sig valid-ar? :center-frequency valid-ar? :q valid-kr? :skip valid-ar? :skip* (s/? valid-i?*) )
         :aaai (s/cat :sig valid-ar? :center-frequency valid-ar? :q valid-ar? :skip* (s/? valid-i?*) )
         ))
(stest/instrument `lowpass2)

(defn vaddv
  {:arglists '([ifn1 ifn2 kelements & kdstoffset* ksrcoffset* kverbose*])}
  [fn1 fn2 elements & [ dstoffset* srcoffset* verbose* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vaddv"
                      [fn1 fn2 elements dstoffset* srcoffset* verbose*]
                      *global*)]
    (new out-types ast)))

(s/fdef vaddv
  :args (s/cat :fn1 valid-i? :fn2 valid-i? :elements valid-kr? :dstoffset* (s/? valid-kr?*) :srcoffset* (s/? valid-kr?*) :verbose* (s/? valid-kr?*) ))
(stest/instrument `vaddv)

(defn printf
  {:arglists '([Sformatstring & karg1* karg2* karg3* karg4* karg5* karg6* karg7* karg8* karg9* karg10* karg11* karg12* karg13* karg14* karg15* karg16*])}
  [formatstring & [ arg1* arg2* arg3* arg4* arg5* arg6* arg7* arg8* arg9* arg10* arg11* arg12* arg13* arg14* arg15* arg16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "printf"
                      [formatstring arg1* arg2* arg3* arg4* arg5* arg6* arg7* arg8* arg9* arg10* arg11* arg12* arg13* arg14* arg15* arg16*]
                      *global*)]
    (new out-types ast)))

(s/fdef printf
  :args (s/cat :formatstring valid-S? :arg1* (s/? valid-kr?*) :arg2* (s/? valid-kr?*) :arg3* (s/? valid-kr?*) :arg4* (s/? valid-kr?*) :arg5* (s/? valid-kr?*) :arg6* (s/? valid-kr?*) :arg7* (s/? valid-kr?*) :arg8* (s/? valid-kr?*) :arg9* (s/? valid-kr?*) :arg10* (s/? valid-kr?*) :arg11* (s/? valid-kr?*) :arg12* (s/? valid-kr?*) :arg13* (s/? valid-kr?*) :arg14* (s/? valid-kr?*) :arg15* (s/? valid-kr?*) :arg16* (s/? valid-kr?*) ))
(stest/instrument `printf)

(defn tablewkt
  {:arglists '([asig aindex ktable & ixmode* ixoff* iwgmode*] [ksig kindex ktable & ixmode* ixoff* iwgmode*])}
  [sig index table & [ xmode* xoff* wgmode* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "tablewkt"
                      [sig index table xmode* xoff* wgmode*]
                      *global*)]
    (new out-types ast)))

(s/fdef tablewkt
  :args (s/alt
         :kkkiii (s/cat :sig valid-kr? :index valid-kr? :table valid-kr? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wgmode* (s/? valid-i?*) )
         :aakiii (s/cat :sig valid-ar? :index valid-ar? :table valid-kr? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wgmode* (s/? valid-i?*) )
         ))
(stest/instrument `tablewkt)

(defn strcpy
  {:arglists '([Ssource])}
  [source]
  (let [out-types-quoted 'String
        out-types String
        ast (ast-node out-types-quoted
                      "strcpy"
                      [source]
                      *global*)]
    (new out-types ast)))

(s/fdef strcpy
  :args (s/cat :source valid-S? ))
(stest/instrument `strcpy)

(defn inrg
  {:arglists '([kstart & ain1* ain2* ain3* ainN4* ainN5* ainN6* ainN7* ainN8* ainN9* ainN10* ainN11* ainN12* ainN13* ainN14* ainN15* ainN16* ainN17* ainN18* ainN19* ainN20* ainN21* ainN22* ainN23* ainN24* ainN25* ainN26* ainN27* ainN28* ainN29* ainN30* ainN31* ainN32*])}
  [start & [ in1* in2* in3* inN4* inN5* inN6* inN7* inN8* inN9* inN10* inN11* inN12* inN13* inN14* inN15* inN16* inN17* inN18* inN19* inN20* inN21* inN22* inN23* inN24* inN25* inN26* inN27* inN28* inN29* inN30* inN31* inN32* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "inrg"
                      [start in1* in2* in3* inN4* inN5* inN6* inN7* inN8* inN9* inN10* inN11* inN12* inN13* inN14* inN15* inN16* inN17* inN18* inN19* inN20* inN21* inN22* inN23* inN24* inN25* inN26* inN27* inN28* inN29* inN30* inN31* inN32*]
                      *global*)]
    (new out-types ast)))

(s/fdef inrg
  :args (s/cat :start valid-kr? :in1* (s/? valid-ar?*) :in2* (s/? valid-ar?*) :in3* (s/? valid-ar?*) :inN4* (s/? valid-ar?*) :inN5* (s/? valid-ar?*) :inN6* (s/? valid-ar?*) :inN7* (s/? valid-ar?*) :inN8* (s/? valid-ar?*) :inN9* (s/? valid-ar?*) :inN10* (s/? valid-ar?*) :inN11* (s/? valid-ar?*) :inN12* (s/? valid-ar?*) :inN13* (s/? valid-ar?*) :inN14* (s/? valid-ar?*) :inN15* (s/? valid-ar?*) :inN16* (s/? valid-ar?*) :inN17* (s/? valid-ar?*) :inN18* (s/? valid-ar?*) :inN19* (s/? valid-ar?*) :inN20* (s/? valid-ar?*) :inN21* (s/? valid-ar?*) :inN22* (s/? valid-ar?*) :inN23* (s/? valid-ar?*) :inN24* (s/? valid-ar?*) :inN25* (s/? valid-ar?*) :inN26* (s/? valid-ar?*) :inN27* (s/? valid-ar?*) :inN28* (s/? valid-ar?*) :inN29* (s/? valid-ar?*) :inN30* (s/? valid-ar?*) :inN31* (s/? valid-ar?*) :inN32* (s/? valid-ar?*) ))
(stest/instrument `inrg)

(defn rbjeq
  {:arglists '([asig kcutoff-frequency klvl kQ kS & imode*])}
  [sig cutoff-frequency lvl Q S & [ mode* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "rbjeq"
                      [sig cutoff-frequency lvl Q S mode*]
                      *global*)]
    (new out-types ast)))

(s/fdef rbjeq
  :args (s/cat :sig valid-ar? :cutoff-frequency valid-kr? :lvl valid-kr? :Q valid-kr? :S valid-kr? :mode* (s/? valid-i?*) ))
(stest/instrument `rbjeq)

(defn maxalloc
  {:arglists '([Sinsname icount] [iinsname icount])}
  [insname count]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "maxalloc"
                      [insname count]
                      *global*)]
    (new out-types ast)))

(s/fdef maxalloc
  :args (s/alt
         :ii (s/cat :insname valid-i? :count valid-i? )
         :Si (s/cat :insname valid-S? :count valid-i? )
         ))
(stest/instrument `maxalloc)

(defn dssictls
  {:arglists '([ihandle iport kvalue ktrigger])}
  [handle port value trigger]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "dssictls"
                      [handle port value trigger]
                      *global*)]
    (new out-types ast)))

(s/fdef dssictls
  :args (s/cat :handle valid-i? :port valid-i? :value valid-kr? :trigger valid-kr? ))
(stest/instrument `dssictls)

(defn minaccum
  {:arglists '([aAccumulator aInput])}
  [Accumulator Input]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "minaccum"
                      [Accumulator Input]
                      *global*)]
    (new out-types ast)))

(s/fdef minaccum
  :args (s/cat :Accumulator valid-ar? :Input valid-ar? ))
(stest/instrument `minaccum)

(defn fout
  {:arglists '([Sfilename iformat arrayArr] [Sfilename iformat & array1* array2* array3* array4* array5* array6* array7* array8* array9* array10* array11* array12* array13* array14* array15* array16* array17* array18* array19* array20* array21* array22* array23* array24* array25* array26* array27* array28* array29* array30* array31* array32*])}
  [filename format rray]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "fout"
                      [filename format rray]
                      *global*)]
    (new out-types ast)))

(s/fdef fout
  :args (s/alt
         :Siaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa (s/cat :filename valid-S? :format valid-i? :rray1* (s/? valid-ar?*) :rray2* (s/? valid-ar?*) :rray3* (s/? valid-ar?*) :rray4* (s/? valid-ar?*) :rray5* (s/? valid-ar?*) :rray6* (s/? valid-ar?*) :rray7* (s/? valid-ar?*) :rray8* (s/? valid-ar?*) :rray9* (s/? valid-ar?*) :rray10* (s/? valid-ar?*) :rray11* (s/? valid-ar?*) :rray12* (s/? valid-ar?*) :rray13* (s/? valid-ar?*) :rray14* (s/? valid-ar?*) :rray15* (s/? valid-ar?*) :rray16* (s/? valid-ar?*) :rray17* (s/? valid-ar?*) :rray18* (s/? valid-ar?*) :rray19* (s/? valid-ar?*) :rray20* (s/? valid-ar?*) :rray21* (s/? valid-ar?*) :rray22* (s/? valid-ar?*) :rray23* (s/? valid-ar?*) :rray24* (s/? valid-ar?*) :rray25* (s/? valid-ar?*) :rray26* (s/? valid-ar?*) :rray27* (s/? valid-ar?*) :rray28* (s/? valid-ar?*) :rray29* (s/? valid-ar?*) :rray30* (s/? valid-ar?*) :rray31* (s/? valid-ar?*) :rray32* (s/? valid-ar?*) )
         :SiaArr (s/cat :filename valid-S? :format valid-i? :rray valid-aArr? )
         ))
(stest/instrument `fout)

(defn vbapzmove
  {:arglists '([inumchnls istartndx asig idur ispread ifldnum & ifld1* ifld2* ifld3* ifld4* ifld5* ifld6* ifld7* ifld8* ifld9* ifld10* ifld11* ifld12* ifld13* ifld14* ifld15* ifld16*])}
  [numchnls startndx sig dur spread fldnum & [ fld1* fld2* fld3* fld4* fld5* fld6* fld7* fld8* fld9* fld10* fld11* fld12* fld13* fld14* fld15* fld16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vbapzmove"
                      [numchnls startndx sig dur spread fldnum fld1* fld2* fld3* fld4* fld5* fld6* fld7* fld8* fld9* fld10* fld11* fld12* fld13* fld14* fld15* fld16*]
                      *global*)]
    (new out-types ast)))

(s/fdef vbapzmove
  :args (s/cat :numchnls valid-i? :startndx valid-i? :sig valid-ar? :dur valid-i? :spread valid-i? :fldnum valid-i? :fld1* (s/? valid-i?*) :fld2* (s/? valid-i?*) :fld3* (s/? valid-i?*) :fld4* (s/? valid-i?*) :fld5* (s/? valid-i?*) :fld6* (s/? valid-i?*) :fld7* (s/? valid-i?*) :fld8* (s/? valid-i?*) :fld9* (s/? valid-i?*) :fld10* (s/? valid-i?*) :fld11* (s/? valid-i?*) :fld12* (s/? valid-i?*) :fld13* (s/? valid-i?*) :fld14* (s/? valid-i?*) :fld15* (s/? valid-i?*) :fld16* (s/? valid-i?*) ))
(stest/instrument `vbapzmove)

(defn gausstrig
  {:arglists '([kamp kcps kdev & imode* ifrst1*] [kamp kcps kdev & imode* ifrst1*])}
  [amp cps dev & [ mode* frst1* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "gausstrig"
                      [amp cps dev mode* frst1*]
                      *global*)]
    (new out-types ast)))

(s/fdef gausstrig
  :args (s/alt
         :kkkii (s/cat :amp valid-kr? :cps valid-kr? :dev valid-kr? :mode* (s/? valid-i?*) :frst1* (s/? valid-i?*) )
         ))
(stest/instrument `gausstrig)

(defn gausstrig:a
  {:arglists '([kamp kcps kdev & imode* ifrst1*])}
  [amp cps dev & [ mode* frst1* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "gausstrig"
                      [amp cps dev mode* frst1*]
                      *global*)]
    (new out-types ast)))

(s/fdef gausstrig:a
  :args (s/cat :amp valid-kr? :cps valid-kr? :dev valid-kr? :mode* (s/? valid-i?*) :frst1* (s/? valid-i?*) ))
(stest/instrument `gausstrig:a)

(defn gausstrig:k
  {:arglists '([kamp kcps kdev & imode* ifrst1*])}
  [amp cps dev & [ mode* frst1* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "gausstrig"
                      [amp cps dev mode* frst1*]
                      *global*)]
    (new out-types ast)))

(s/fdef gausstrig:k
  :args (s/cat :amp valid-kr? :cps valid-kr? :dev valid-kr? :mode* (s/? valid-i?*) :frst1* (s/? valid-i?*) ))
(stest/instrument `gausstrig:k)

(defn imageload
  {:arglists '([Silename])}
  [ilename]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "imageload"
                      [ilename]
                      *global*)]
    (new out-types ast)))

(s/fdef imageload
  :args (s/cat :ilename valid-S? ))
(stest/instrument `imageload)

(defn samphold
  {:arglists '([xsig xgate & ival* ivstor*] [xsig xgate & ival* ivstor*])}
  [sig gate & [ val* vstor* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "samphold"
                      [sig gate val* vstor*]
                      *global*)]
    (new out-types ast)))

(s/fdef samphold
  :args (s/alt
         :xxii (s/cat :sig valid-x? :gate valid-x? :val* (s/? valid-i?*) :vstor* (s/? valid-i?*) )
         ))
(stest/instrument `samphold)

(defn samphold:a
  {:arglists '([xsig xgate & ival* ivstor*])}
  [sig gate & [ val* vstor* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "samphold"
                      [sig gate val* vstor*]
                      *global*)]
    (new out-types ast)))

(s/fdef samphold:a
  :args (s/cat :sig valid-x? :gate valid-x? :val* (s/? valid-i?*) :vstor* (s/? valid-i?*) ))
(stest/instrument `samphold:a)

(defn samphold:k
  {:arglists '([xsig xgate & ival* ivstor*])}
  [sig gate & [ val* vstor* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "samphold"
                      [sig gate val* vstor*]
                      *global*)]
    (new out-types ast)))

(s/fdef samphold:k
  :args (s/cat :sig valid-x? :gate valid-x? :val* (s/? valid-i?*) :vstor* (s/? valid-i?*) ))
(stest/instrument `samphold:k)

(defn zkwm
  {:arglists '([ksig kindex & imix*])}
  [sig index & [ mix* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "zkwm"
                      [sig index mix*]
                      *global*)]
    (new out-types ast)))

(s/fdef zkwm
  :args (s/cat :sig valid-kr? :index valid-kr? :mix* (s/? valid-i?*) ))
(stest/instrument `zkwm)

(defn streson
  {:arglists '([asig kfr kfdbgain])}
  [sig fr fdbgain]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "streson"
                      [sig fr fdbgain]
                      *global*)]
    (new out-types ast)))

(s/fdef streson
  :args (s/cat :sig valid-ar? :fr valid-kr? :fdbgain valid-kr? ))
(stest/instrument `streson)

(defn oscil
  {:arglists '([aamp acps itableArr & iphase*] [aamp acps & itable* iphase*] [aamp kcps itableArr & iphase*] [aamp kcps & itable* iphase*] [kamp acps itableArr & iphase*] [kamp acps & itable* iphase*] [kamp kcps itableArr & iphase*] [kamp kcps & itable* iphase*] [kamp kcps & itable* iphase*])}
  [amp cps table & [ phase* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "oscil"
                      [amp cps table phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef oscil
  :args (s/alt
         :kkii (s/cat :amp valid-kr? :cps valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :kkiArri (s/cat :amp valid-kr? :cps valid-kr? :table valid-iArr? :phase* (s/? valid-i?*) )
         :kaii (s/cat :amp valid-kr? :cps valid-ar? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :kaiArri (s/cat :amp valid-kr? :cps valid-ar? :table valid-iArr? :phase* (s/? valid-i?*) )
         :akii (s/cat :amp valid-ar? :cps valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :akiArri (s/cat :amp valid-ar? :cps valid-kr? :table valid-iArr? :phase* (s/? valid-i?*) )
         :aaii (s/cat :amp valid-ar? :cps valid-ar? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :aaiArri (s/cat :amp valid-ar? :cps valid-ar? :table valid-iArr? :phase* (s/? valid-i?*) )
         ))
(stest/instrument `oscil)

(defn oscil:a
  {:arglists '([aamp acps itableArr & iphase*] [aamp acps & itable* iphase*] [aamp kcps itableArr & iphase*] [aamp kcps & itable* iphase*] [kamp acps itableArr & iphase*] [kamp acps & itable* iphase*] [kamp kcps itableArr & iphase*] [kamp kcps & itable* iphase*])}
  [amp cps table & [ phase* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "oscil"
                      [amp cps table phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef oscil:a
  :args (s/alt
         :kkii (s/cat :amp valid-kr? :cps valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :kkiArri (s/cat :amp valid-kr? :cps valid-kr? :table valid-iArr? :phase* (s/? valid-i?*) )
         :kaii (s/cat :amp valid-kr? :cps valid-ar? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :kaiArri (s/cat :amp valid-kr? :cps valid-ar? :table valid-iArr? :phase* (s/? valid-i?*) )
         :akii (s/cat :amp valid-ar? :cps valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :akiArri (s/cat :amp valid-ar? :cps valid-kr? :table valid-iArr? :phase* (s/? valid-i?*) )
         :aaii (s/cat :amp valid-ar? :cps valid-ar? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :aaiArri (s/cat :amp valid-ar? :cps valid-ar? :table valid-iArr? :phase* (s/? valid-i?*) )
         ))
(stest/instrument `oscil:a)

(defn oscil:k
  {:arglists '([kamp kcps & itable* iphase*])}
  [amp cps & [ table* phase* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "oscil"
                      [amp cps table* phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef oscil:k
  :args (s/cat :amp valid-kr? :cps valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) ))
(stest/instrument `oscil:k)

(defn statevar
  {:arglists '([ain xcenter-frequency xq & iosamps* istor*])}
  [in center-frequency q & [ osamps* stor* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "statevar"
                      [in center-frequency q osamps* stor*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef statevar
  :args (s/cat :in valid-ar? :center-frequency valid-x? :q valid-x? :osamps* (s/? valid-i?*) :stor* (s/? valid-i?*) ))
(stest/instrument `statevar)

(defn pchbend
  {:arglists '([& imin* imax*] [& imin* imax*])}
  [& [ min* max* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "pchbend"
                      [min* max*]
                      *global*)]
    (new out-types ast)))

(s/fdef pchbend
  :args (s/alt
         :ii (s/cat :min* (s/? valid-i?*) :max* (s/? valid-i?*) )
         ))
(stest/instrument `pchbend)

(defn pchbend:i
  {:arglists '([& imin* imax*])}
  [& [ min* max* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "pchbend"
                      [min* max*]
                      *global*)]
    (new out-types ast)))

(s/fdef pchbend:i
  :args (s/cat :min* (s/? valid-i?*) :max* (s/? valid-i?*) ))
(stest/instrument `pchbend:i)

(defn pchbend:k
  {:arglists '([& imin* imax*])}
  [& [ min* max* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "pchbend"
                      [min* max*]
                      *global*)]
    (new out-types ast)))

(s/fdef pchbend:k
  :args (s/cat :min* (s/? valid-i?*) :max* (s/? valid-i?*) ))
(stest/instrument `pchbend:k)

(defn ATSaddnz
  {:arglists '([ktimepnt Satsfile ibands & ibandoffset* ibandincr*] [ktimepnt iatsfile ibands & ibandoffset* ibandincr*])}
  [timepnt atsfile bands & [ bandoffset* bandincr* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "ATSaddnz"
                      [timepnt atsfile bands bandoffset* bandincr*]
                      *global*)]
    (new out-types ast)))

(s/fdef ATSaddnz
  :args (s/alt
         :kiiii (s/cat :timepnt valid-kr? :atsfile valid-i? :bands valid-i? :bandoffset* (s/? valid-i?*) :bandincr* (s/? valid-i?*) )
         :kSiii (s/cat :timepnt valid-kr? :atsfile valid-S? :bands valid-i? :bandoffset* (s/? valid-i?*) :bandincr* (s/? valid-i?*) )
         ))
(stest/instrument `ATSaddnz)

(defn spat3dt
  {:arglists '([ioutft iX iY iZ idistortion ift imode irlen & iftnocl*])}
  [outft X Y Z distortion ft mode rlen & [ ftnocl* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "spat3dt"
                      [outft X Y Z distortion ft mode rlen ftnocl*]
                      *global*)]
    (new out-types ast)))

(s/fdef spat3dt
  :args (s/cat :outft valid-i? :X valid-i? :Y valid-i? :Z valid-i? :distortion valid-i? :ft valid-i? :mode valid-i? :rlen valid-i? :ftnocl* (s/? valid-i?*) ))
(stest/instrument `spat3dt)

(defn ATSbufread
  {:arglists '([ktimepnt kfmod Satsfile ipartials & ipartialoffset* ipartialincr*] [ktimepnt kfmod iatsfile ipartials & ipartialoffset* ipartialincr*])}
  [timepnt fmod atsfile partials & [ partialoffset* partialincr* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "ATSbufread"
                      [timepnt fmod atsfile partials partialoffset* partialincr*]
                      *global*)]
    (new out-types ast)))

(s/fdef ATSbufread
  :args (s/alt
         :kkiiii (s/cat :timepnt valid-kr? :fmod valid-kr? :atsfile valid-i? :partials valid-i? :partialoffset* (s/? valid-i?*) :partialincr* (s/? valid-i?*) )
         :kkSiii (s/cat :timepnt valid-kr? :fmod valid-kr? :atsfile valid-S? :partials valid-i? :partialoffset* (s/? valid-i?*) :partialincr* (s/? valid-i?*) )
         ))
(stest/instrument `ATSbufread)

(defn pitchamdf
  {:arglists '([asig imincps imaxcps & icps* imedi* idowns* iexcps* irmsmedi*])}
  [sig mincps maxcps & [ cps* medi* downs* excps* rmsmedi* ]]
  (let [out-types-quoted '[ControlSignal ControlSignal]
        out-types [ControlSignal ControlSignal]
        ast (ast-node out-types-quoted
                      "pitchamdf"
                      [sig mincps maxcps cps* medi* downs* excps* rmsmedi*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef pitchamdf
  :args (s/cat :sig valid-ar? :mincps valid-i? :maxcps valid-i? :cps* (s/? valid-i?*) :medi* (s/? valid-i?*) :downs* (s/? valid-i?*) :excps* (s/? valid-i?*) :rmsmedi* (s/? valid-i?*) ))
(stest/instrument `pitchamdf)

(defn vibr
  {:arglists '([kAverageAmp kAverageFreq itable])}
  [AverageAmp AverageFreq table]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "vibr"
                      [AverageAmp AverageFreq table]
                      *global*)]
    (new out-types ast)))

(s/fdef vibr
  :args (s/cat :AverageAmp valid-kr? :AverageFreq valid-kr? :table valid-i? ))
(stest/instrument `vibr)

(defn zfilter2
  {:arglists '([asig kdamp kfreq iM iN & ib1* ib2* ibM3* ia4* ia5* iaN6* iaN7* iaN8* iaN9* iaN10* iaN11* iaN12* iaN13* iaN14* iaN15* iaN16*])}
  [sig damp freq M N & [ b1* b2* bM3* a4* a5* aN6* aN7* aN8* aN9* aN10* aN11* aN12* aN13* aN14* aN15* aN16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "zfilter2"
                      [sig damp freq M N b1* b2* bM3* a4* a5* aN6* aN7* aN8* aN9* aN10* aN11* aN12* aN13* aN14* aN15* aN16*]
                      *global*)]
    (new out-types ast)))

(s/fdef zfilter2
  :args (s/cat :sig valid-ar? :damp valid-kr? :freq valid-kr? :M valid-i? :N valid-i? :b1* (s/? valid-i?*) :b2* (s/? valid-i?*) :bM3* (s/? valid-i?*) :a4* (s/? valid-i?*) :a5* (s/? valid-i?*) :aN6* (s/? valid-i?*) :aN7* (s/? valid-i?*) :aN8* (s/? valid-i?*) :aN9* (s/? valid-i?*) :aN10* (s/? valid-i?*) :aN11* (s/? valid-i?*) :aN12* (s/? valid-i?*) :aN13* (s/? valid-i?*) :aN14* (s/? valid-i?*) :aN15* (s/? valid-i?*) :aN16* (s/? valid-i?*) ))
(stest/instrument `zfilter2)

(defn vtablea
  {:arglists '([aindex ktable kinterp ixmode & aout1* aout2* aout3* aoutN4* aoutN5* aoutN6* aoutN7* aoutN8* aoutN9* aoutN10* aoutN11* aoutN12* aoutN13* aoutN14* aoutN15* aoutN16* aoutN17* aoutN18* aoutN19* aoutN20* aoutN21* aoutN22* aoutN23* aoutN24* aoutN25* aoutN26* aoutN27* aoutN28* aoutN29* aoutN30* aoutN31* aoutN32*])}
  [index table interp xmode & [ out1* out2* out3* outN4* outN5* outN6* outN7* outN8* outN9* outN10* outN11* outN12* outN13* outN14* outN15* outN16* outN17* outN18* outN19* outN20* outN21* outN22* outN23* outN24* outN25* outN26* outN27* outN28* outN29* outN30* outN31* outN32* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vtablea"
                      [index table interp xmode out1* out2* out3* outN4* outN5* outN6* outN7* outN8* outN9* outN10* outN11* outN12* outN13* outN14* outN15* outN16* outN17* outN18* outN19* outN20* outN21* outN22* outN23* outN24* outN25* outN26* outN27* outN28* outN29* outN30* outN31* outN32*]
                      *global*)]
    (new out-types ast)))

(s/fdef vtablea
  :args (s/cat :index valid-ar? :table valid-kr? :interp valid-kr? :xmode valid-i? :out1* (s/? valid-ar?*) :out2* (s/? valid-ar?*) :out3* (s/? valid-ar?*) :outN4* (s/? valid-ar?*) :outN5* (s/? valid-ar?*) :outN6* (s/? valid-ar?*) :outN7* (s/? valid-ar?*) :outN8* (s/? valid-ar?*) :outN9* (s/? valid-ar?*) :outN10* (s/? valid-ar?*) :outN11* (s/? valid-ar?*) :outN12* (s/? valid-ar?*) :outN13* (s/? valid-ar?*) :outN14* (s/? valid-ar?*) :outN15* (s/? valid-ar?*) :outN16* (s/? valid-ar?*) :outN17* (s/? valid-ar?*) :outN18* (s/? valid-ar?*) :outN19* (s/? valid-ar?*) :outN20* (s/? valid-ar?*) :outN21* (s/? valid-ar?*) :outN22* (s/? valid-ar?*) :outN23* (s/? valid-ar?*) :outN24* (s/? valid-ar?*) :outN25* (s/? valid-ar?*) :outN26* (s/? valid-ar?*) :outN27* (s/? valid-ar?*) :outN28* (s/? valid-ar?*) :outN29* (s/? valid-ar?*) :outN30* (s/? valid-ar?*) :outN31* (s/? valid-ar?*) :outN32* (s/? valid-ar?*) ))
(stest/instrument `vtablea)

(defn spat3d
  {:arglists '([ain kX kY kZ idistortion ift imode imdel iovr & istor*])}
  [in X Y Z distortion ft mode mdel ovr & [ stor* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "spat3d"
                      [in X Y Z distortion ft mode mdel ovr stor*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef spat3d
  :args (s/cat :in valid-ar? :X valid-kr? :Y valid-kr? :Z valid-kr? :distortion valid-i? :ft valid-i? :mode valid-i? :mdel valid-i? :ovr valid-i? :stor* (s/? valid-i?*) ))
(stest/instrument `spat3d)

(defn foutk
  {:arglists '([Sfilename iformat & kout1* kout2* kout3* koutN4* koutN5* koutN6* koutN7* koutN8* koutN9* koutN10* koutN11* koutN12* koutN13* koutN14* koutN15* koutN16*] [ifilename iformat & kout1* kout2* kout3* koutN4* koutN5* koutN6* koutN7* koutN8* koutN9* koutN10* koutN11* koutN12* koutN13* koutN14* koutN15* koutN16*])}
  [filename format & [ out1* out2* out3* outN4* outN5* outN6* outN7* outN8* outN9* outN10* outN11* outN12* outN13* outN14* outN15* outN16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "foutk"
                      [filename format out1* out2* out3* outN4* outN5* outN6* outN7* outN8* outN9* outN10* outN11* outN12* outN13* outN14* outN15* outN16*]
                      *global*)]
    (new out-types ast)))

(s/fdef foutk
  :args (s/alt
         :iikkkkkkkkkkkkkkkk (s/cat :filename valid-i? :format valid-i? :out1* (s/? valid-kr?*) :out2* (s/? valid-kr?*) :out3* (s/? valid-kr?*) :outN4* (s/? valid-kr?*) :outN5* (s/? valid-kr?*) :outN6* (s/? valid-kr?*) :outN7* (s/? valid-kr?*) :outN8* (s/? valid-kr?*) :outN9* (s/? valid-kr?*) :outN10* (s/? valid-kr?*) :outN11* (s/? valid-kr?*) :outN12* (s/? valid-kr?*) :outN13* (s/? valid-kr?*) :outN14* (s/? valid-kr?*) :outN15* (s/? valid-kr?*) :outN16* (s/? valid-kr?*) )
         :Sikkkkkkkkkkkkkkkk (s/cat :filename valid-S? :format valid-i? :out1* (s/? valid-kr?*) :out2* (s/? valid-kr?*) :out3* (s/? valid-kr?*) :outN4* (s/? valid-kr?*) :outN5* (s/? valid-kr?*) :outN6* (s/? valid-kr?*) :outN7* (s/? valid-kr?*) :outN8* (s/? valid-kr?*) :outN9* (s/? valid-kr?*) :outN10* (s/? valid-kr?*) :outN11* (s/? valid-kr?*) :outN12* (s/? valid-kr?*) :outN13* (s/? valid-kr?*) :outN14* (s/? valid-kr?*) :outN15* (s/? valid-kr?*) :outN16* (s/? valid-kr?*) )
         ))
(stest/instrument `foutk)

(defn syncgrain
  {:arglists '([kamp kfreq kpitch kgrsize kprate ifun6 ifun7 iolaps])}
  [amp freq pitch grsize prate fun6 fun7 olaps]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "syncgrain"
                      [amp freq pitch grsize prate fun6 fun7 olaps]
                      *global*)]
    (new out-types ast)))

(s/fdef syncgrain
  :args (s/cat :amp valid-kr? :freq valid-kr? :pitch valid-kr? :grsize valid-kr? :prate valid-kr? :fun6 valid-i? :fun7 valid-i? :olaps valid-i? ))
(stest/instrument `syncgrain)

(defn reverb
  {:arglists '([asig krvt & iskip*])}
  [sig rvt & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "reverb"
                      [sig rvt skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef reverb
  :args (s/cat :sig valid-ar? :rvt valid-kr? :skip* (s/? valid-i?*) ))
(stest/instrument `reverb)

(defn ATSinfo
  {:arglists '([Satsfile ilocation] [iatsfile ilocation])}
  [atsfile location]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "ATSinfo"
                      [atsfile location]
                      *global*)]
    (new out-types ast)))

(s/fdef ATSinfo
  :args (s/alt
         :ii (s/cat :atsfile valid-i? :location valid-i? )
         :Si (s/cat :atsfile valid-S? :location valid-i? )
         ))
(stest/instrument `ATSinfo)

(defn compress2
  {:arglists '([aasig acsig kthresh kloknee khiknee kratio katt krel ilook])}
  [asig csig thresh loknee hiknee ratio att rel look]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "compress2"
                      [asig csig thresh loknee hiknee ratio att rel look]
                      *global*)]
    (new out-types ast)))

(s/fdef compress2
  :args (s/cat :asig valid-ar? :csig valid-ar? :thresh valid-kr? :loknee valid-kr? :hiknee valid-kr? :ratio valid-kr? :att valid-kr? :rel valid-kr? :look valid-i? ))
(stest/instrument `compress2)

(defn table3
  {:arglists '([xindex itable & ixmode* ixoff* iwrap*] [iindex itable & ixmode* ixoff* iwrap*] [xindex itable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "table3"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef table3
  :args (s/alt
         :iiiii (s/cat :index valid-i? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) )
         :xiiii (s/cat :index valid-x? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) )
         ))
(stest/instrument `table3)

(defn table3:a
  {:arglists '([xindex itable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "table3"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef table3:a
  :args (s/cat :index valid-x? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) ))
(stest/instrument `table3:a)

(defn table3:i
  {:arglists '([iindex itable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "table3"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef table3:i
  :args (s/cat :index valid-i? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) ))
(stest/instrument `table3:i)

(defn table3:k
  {:arglists '([xindex itable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "table3"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef table3:k
  :args (s/cat :index valid-x? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) ))
(stest/instrument `table3:k)

(defn outkpc
  {:arglists '([kchn kprog kmin kmax])}
  [chn prog min max]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outkpc"
                      [chn prog min max]
                      *global*)]
    (new out-types ast)))

(s/fdef outkpc
  :args (s/cat :chn valid-kr? :prog valid-kr? :min valid-kr? :max valid-kr? ))
(stest/instrument `outkpc)

(defn ntom
  {:arglists '([Snote] [Snote])}
  [note]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "ntom"
                      [note]
                      *global*)]
    (new out-types ast)))

(s/fdef ntom
  :args (s/alt
         :S (s/cat :note valid-S? )
         ))
(stest/instrument `ntom)

(defn ntom:i
  {:arglists '([Snote])}
  [note]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "ntom"
                      [note]
                      *global*)]
    (new out-types ast)))

(s/fdef ntom:i
  :args (s/cat :note valid-S? ))
(stest/instrument `ntom:i)

(defn ntom:k
  {:arglists '([Snote])}
  [note]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "ntom"
                      [note]
                      *global*)]
    (new out-types ast)))

(s/fdef ntom:k
  :args (s/cat :note valid-S? ))
(stest/instrument `ntom:k)

(defn wterrain
  {:arglists '([kamp kpch k_xcenter k_ycenter k_xradius k_yradius itabx itaby])}
  [amp pch _xcenter _ycenter _xradius _yradius tabx taby]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "wterrain"
                      [amp pch _xcenter _ycenter _xradius _yradius tabx taby]
                      *global*)]
    (new out-types ast)))

(s/fdef wterrain
  :args (s/cat :amp valid-kr? :pch valid-kr? :_xcenter valid-kr? :_ycenter valid-kr? :_xradius valid-kr? :_yradius valid-kr? :tabx valid-i? :taby valid-i? ))
(stest/instrument `wterrain)

(defn ftsave
  {:arglists '([Sfilename iflag & ifn1* ifn2* ifn3* ifn4* ifn5* ifn6* ifn7* ifn8* ifn9* ifn10* ifn11* ifn12* ifn13* ifn14* ifn15* ifn16*] [ifilename iflag & ifn1* ifn2* ifn3* ifn4* ifn5* ifn6* ifn7* ifn8* ifn9* ifn10* ifn11* ifn12* ifn13* ifn14* ifn15* ifn16*])}
  [filename flag & [ fn1* fn2* fn3* fn4* fn5* fn6* fn7* fn8* fn9* fn10* fn11* fn12* fn13* fn14* fn15* fn16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "ftsave"
                      [filename flag fn1* fn2* fn3* fn4* fn5* fn6* fn7* fn8* fn9* fn10* fn11* fn12* fn13* fn14* fn15* fn16*]
                      *global*)]
    (new out-types ast)))

(s/fdef ftsave
  :args (s/alt
         :iiiiiiiiiiiiiiiiii (s/cat :filename valid-i? :flag valid-i? :fn1* (s/? valid-i?*) :fn2* (s/? valid-i?*) :fn3* (s/? valid-i?*) :fn4* (s/? valid-i?*) :fn5* (s/? valid-i?*) :fn6* (s/? valid-i?*) :fn7* (s/? valid-i?*) :fn8* (s/? valid-i?*) :fn9* (s/? valid-i?*) :fn10* (s/? valid-i?*) :fn11* (s/? valid-i?*) :fn12* (s/? valid-i?*) :fn13* (s/? valid-i?*) :fn14* (s/? valid-i?*) :fn15* (s/? valid-i?*) :fn16* (s/? valid-i?*) )
         :Siiiiiiiiiiiiiiiii (s/cat :filename valid-S? :flag valid-i? :fn1* (s/? valid-i?*) :fn2* (s/? valid-i?*) :fn3* (s/? valid-i?*) :fn4* (s/? valid-i?*) :fn5* (s/? valid-i?*) :fn6* (s/? valid-i?*) :fn7* (s/? valid-i?*) :fn8* (s/? valid-i?*) :fn9* (s/? valid-i?*) :fn10* (s/? valid-i?*) :fn11* (s/? valid-i?*) :fn12* (s/? valid-i?*) :fn13* (s/? valid-i?*) :fn14* (s/? valid-i?*) :fn15* (s/? valid-i?*) :fn16* (s/? valid-i?*) )
         ))
(stest/instrument `ftsave)

(defn vdelayxws
  {:arglists '([ain1 ain2 adl imd iws & ist*])}
  [in1 in2 dl md ws & [ st* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "vdelayxws"
                      [in1 in2 dl md ws st*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef vdelayxws
  :args (s/cat :in1 valid-ar? :in2 valid-ar? :dl valid-ar? :md valid-i? :ws valid-i? :st* (s/? valid-i?*) ))
(stest/instrument `vdelayxws)

(defn midipolyaftertouch
  {:arglists '([xpolyaftertouch xcontrollervalue & ilow* ihigh*])}
  [polyaftertouch controllervalue & [ low* high* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "midipolyaftertouch"
                      [polyaftertouch controllervalue low* high*]
                      *global*)]
    (new out-types ast)))

(s/fdef midipolyaftertouch
  :args (s/cat :polyaftertouch valid-x? :controllervalue valid-x? :low* (s/? valid-i?*) :high* (s/? valid-i?*) ))
(stest/instrument `midipolyaftertouch)

(defn vpvoc
  {:arglists '([ktimpnt kfmod Sfile & ispecwp* itable*] [ktimpnt kfmod ifile & ispecwp* itable*])}
  [timpnt fmod file & [ specwp* table* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "vpvoc"
                      [timpnt fmod file specwp* table*]
                      *global*)]
    (new out-types ast)))

(s/fdef vpvoc
  :args (s/alt
         :kkiii (s/cat :timpnt valid-kr? :fmod valid-kr? :file valid-i? :specwp* (s/? valid-i?*) :table* (s/? valid-i?*) )
         :kkSii (s/cat :timpnt valid-kr? :fmod valid-kr? :file valid-S? :specwp* (s/? valid-i?*) :table* (s/? valid-i?*) )
         ))
(stest/instrument `vpvoc)

(defn rect2pol
  {:arglists '([kinArr])}
  [in]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "rect2pol"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef rect2pol
  :args (s/cat :in valid-kArr? ))
(stest/instrument `rect2pol)

(defn vaset
  {:arglists '([kval kindex avar])}
  [val index var]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vaset"
                      [val index var]
                      *global*)]
    (new out-types ast)))

(s/fdef vaset
  :args (s/cat :val valid-kr? :index valid-kr? :var valid-ar? ))
(stest/instrument `vaset)

(defn pvsynth
  {:arglists '([fsrc & iinit*])}
  [src & [ init* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "pvsynth"
                      [src init*]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsynth
  :args (s/cat :src valid-f? :init* (s/? valid-i?*) ))
(stest/instrument `pvsynth)

(defn fmanal
  {:arglists '([are aim])}
  [re im]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "fmanal"
                      [re im]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef fmanal
  :args (s/cat :re valid-ar? :im valid-ar? ))
(stest/instrument `fmanal)

(defn scoreline_i
  {:arglists '([Sin])}
  [in]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "scoreline_i"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef scoreline_i
  :args (s/cat :in valid-S? ))
(stest/instrument `scoreline_i)

(defn combinv
  {:arglists '([asig krvt ilpt & iskip* insmps*])}
  [sig rvt lpt & [ skip* nsmps* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "combinv"
                      [sig rvt lpt skip* nsmps*]
                      *global*)]
    (new out-types ast)))

(s/fdef combinv
  :args (s/cat :sig valid-ar? :rvt valid-kr? :lpt valid-i? :skip* (s/? valid-i?*) :nsmps* (s/? valid-i?*) ))
(stest/instrument `combinv)

(defn outiat
  {:arglists '([ichn ivalue imin imax])}
  [chn value min max]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outiat"
                      [chn value min max]
                      *global*)]
    (new out-types ast)))

(s/fdef outiat
  :args (s/cat :chn valid-i? :value valid-i? :min valid-i? :max valid-i? ))
(stest/instrument `outiat)

(defn pvsmooth
  {:arglists '([fsigin xacf xfcf])}
  [sigin acf fcf]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvsmooth"
                      [sigin acf fcf]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsmooth
  :args (s/cat :sigin valid-f? :acf valid-x? :fcf valid-x? ))
(stest/instrument `pvsmooth)

(defn hsboscil
  {:arglists '([kamp ktone kbrite ibasfreq iwfn ioctfn & ioctcnt* iphase*])}
  [amp tone brite basfreq wfn octfn & [ octcnt* phase* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "hsboscil"
                      [amp tone brite basfreq wfn octfn octcnt* phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef hsboscil
  :args (s/cat :amp valid-kr? :tone valid-kr? :brite valid-kr? :basfreq valid-i? :wfn valid-i? :octfn valid-i? :octcnt* (s/? valid-i?*) :phase* (s/? valid-i?*) ))
(stest/instrument `hsboscil)

(defn deltap
  {:arglists '([kdlt & idlt*])}
  [dlt & [ dlt* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "deltap"
                      [dlt dlt*]
                      *global*)]
    (new out-types ast)))

(s/fdef deltap
  :args (s/cat :dlt valid-kr? :dlt* (s/? valid-i?*) ))
(stest/instrument `deltap)

(defn turnoff
  {:arglists '( [inst] [knst])}
  []
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "turnoff"
                      []
                      *global*)]
    (new out-types ast)))

(s/fdef turnoff
  :args (s/alt
         :k (s/cat :nst valid-kr? )
         :i (s/cat :nst valid-i? )
         ))
(stest/instrument `turnoff)

(defn wgpluck
  {:arglists '([icps iamp kpick iplk idamp ifilt axcite])}
  [cps amp pick plk damp filt xcite]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "wgpluck"
                      [cps amp pick plk damp filt xcite]
                      *global*)]
    (new out-types ast)))

(s/fdef wgpluck
  :args (s/cat :cps valid-i? :amp valid-i? :pick valid-kr? :plk valid-i? :damp valid-i? :filt valid-i? :xcite valid-ar? ))
(stest/instrument `wgpluck)

(defn sndwarpst
  {:arglists '([xamp xtimewarp xresample ifn4 ibeg iwsize irandw ioverlap ifn9 itimemode])}
  [amp timewarp resample fn4 beg wsize randw overlap fn9 timemode]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "sndwarpst"
                      [amp timewarp resample fn4 beg wsize randw overlap fn9 timemode]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef sndwarpst
  :args (s/cat :amp valid-x? :timewarp valid-x? :resample valid-x? :fn4 valid-i? :beg valid-i? :wsize valid-i? :randw valid-i? :overlap valid-i? :fn9 valid-i? :timemode valid-i? ))
(stest/instrument `sndwarpst)

(defn transegr
  {:arglists '([ia idur itype & ib1* idur2* itype3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*] [ia idur itype & ib1* idur2* itype3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a dur type & [ b1* dur2* type3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "transegr"
                      [a dur type b1* dur2* type3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef transegr
  :args (s/alt
         :iiiiiiiiiiiiiiiiiii (s/cat :a valid-i? :dur valid-i? :type valid-i? :b1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :type3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) )
         ))
(stest/instrument `transegr)

(defn transegr:a
  {:arglists '([ia idur itype & ib1* idur2* itype3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a dur type & [ b1* dur2* type3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "transegr"
                      [a dur type b1* dur2* type3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef transegr:a
  :args (s/cat :a valid-i? :dur valid-i? :type valid-i? :b1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :type3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) ))
(stest/instrument `transegr:a)

(defn transegr:k
  {:arglists '([ia idur itype & ib1* idur2* itype3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a dur type & [ b1* dur2* type3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "transegr"
                      [a dur type b1* dur2* type3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef transegr:k
  :args (s/cat :a valid-i? :dur valid-i? :type valid-i? :b1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :type3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) ))
(stest/instrument `transegr:k)

(defn betarand
  {:arglists '([krange kalpha kbeta] [krange kalpha kbeta] [krange kalpha kbeta])}
  [range alpha beta]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "betarand"
                      [range alpha beta]
                      *global*)]
    (new out-types ast)))

(s/fdef betarand
  :args (s/alt
         :kkk (s/cat :range valid-kr? :alpha valid-kr? :beta valid-kr? )
         ))
(stest/instrument `betarand)

(defn betarand:a
  {:arglists '([krange kalpha kbeta])}
  [range alpha beta]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "betarand"
                      [range alpha beta]
                      *global*)]
    (new out-types ast)))

(s/fdef betarand:a
  :args (s/cat :range valid-kr? :alpha valid-kr? :beta valid-kr? ))
(stest/instrument `betarand:a)

(defn betarand:i
  {:arglists '([krange kalpha kbeta])}
  [range alpha beta]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "betarand"
                      [range alpha beta]
                      *global*)]
    (new out-types ast)))

(s/fdef betarand:i
  :args (s/cat :range valid-kr? :alpha valid-kr? :beta valid-kr? ))
(stest/instrument `betarand:i)

(defn betarand:k
  {:arglists '([krange kalpha kbeta])}
  [range alpha beta]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "betarand"
                      [range alpha beta]
                      *global*)]
    (new out-types ast)))

(s/fdef betarand:k
  :args (s/cat :range valid-kr? :alpha valid-kr? :beta valid-kr? ))
(stest/instrument `betarand:k)

(defn ATSinterpread
  {:arglists '([kfreq])}
  [freq]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "ATSinterpread"
                      [freq]
                      *global*)]
    (new out-types ast)))

(s/fdef ATSinterpread
  :args (s/cat :freq valid-kr? ))
(stest/instrument `ATSinterpread)

(defn vcella
  {:arglists '([ktrig kreinit ioutFunc initStateFunc iRuleFunc ielements irulelen & iradius*])}
  [trig reinit outFunc nitStateFunc RuleFunc elements rulelen & [ radius* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vcella"
                      [trig reinit outFunc nitStateFunc RuleFunc elements rulelen radius*]
                      *global*)]
    (new out-types ast)))

(s/fdef vcella
  :args (s/cat :trig valid-kr? :reinit valid-kr? :outFunc valid-i? :nitStateFunc valid-i? :RuleFunc valid-i? :elements valid-i? :rulelen valid-i? :radius* (s/? valid-i?*) ))
(stest/instrument `vcella)

(defn vpow
  {:arglists '([itable kval kelements & kdstoffset* kverbose*])}
  [table val elements & [ dstoffset* verbose* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vpow"
                      [table val elements dstoffset* verbose*]
                      *global*)]
    (new out-types ast)))

(s/fdef vpow
  :args (s/cat :table valid-i? :val valid-kr? :elements valid-kr? :dstoffset* (s/? valid-kr?*) :verbose* (s/? valid-kr?*) ))
(stest/instrument `vpow)

(defn strindexk
  {:arglists '([Sarg1 Sarg2])}
  [arg1 arg2]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "strindexk"
                      [arg1 arg2]
                      *global*)]
    (new out-types ast)))

(s/fdef strindexk
  :args (s/cat :arg1 valid-S? :arg2 valid-S? ))
(stest/instrument `strindexk)

(defn sflooper
  {:arglists '([ivel inotenum kamp kpitch ipreindex kloopstart kloopend kcrossfade & istart* imode* ifenv* iskip*])}
  [vel notenum amp pitch preindex loopstart loopend crossfade & [ start* mode* fenv* skip* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "sflooper"
                      [vel notenum amp pitch preindex loopstart loopend crossfade start* mode* fenv* skip*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef sflooper
  :args (s/cat :vel valid-i? :notenum valid-i? :amp valid-kr? :pitch valid-kr? :preindex valid-i? :loopstart valid-kr? :loopend valid-kr? :crossfade valid-kr? :start* (s/? valid-i?*) :mode* (s/? valid-i?*) :fenv* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `sflooper)

(defn diskgrain
  {:arglists '([Sfname kamp kfreq kpitch kgrsize kprate ifun iolaps & imaxgrsize* ioffset*])}
  [fname amp freq pitch grsize prate fun olaps & [ maxgrsize* offset* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "diskgrain"
                      [fname amp freq pitch grsize prate fun olaps maxgrsize* offset*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef diskgrain
  :args (s/cat :fname valid-S? :amp valid-kr? :freq valid-kr? :pitch valid-kr? :grsize valid-kr? :prate valid-kr? :fun valid-i? :olaps valid-i? :maxgrsize* (s/? valid-i?*) :offset* (s/? valid-i?*) ))
(stest/instrument `diskgrain)

(defn expon
  {:arglists '([ia idur ib] [ia idur ib])}
  [a dur b]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "expon"
                      [a dur b]
                      *global*)]
    (new out-types ast)))

(s/fdef expon
  :args (s/alt
         :iii (s/cat :a valid-i? :dur valid-i? :b valid-i? )
         ))
(stest/instrument `expon)

(defn expon:a
  {:arglists '([ia idur ib])}
  [a dur b]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "expon"
                      [a dur b]
                      *global*)]
    (new out-types ast)))

(s/fdef expon:a
  :args (s/cat :a valid-i? :dur valid-i? :b valid-i? ))
(stest/instrument `expon:a)

(defn expon:k
  {:arglists '([ia idur ib])}
  [a dur b]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "expon"
                      [a dur b]
                      *global*)]
    (new out-types ast)))

(s/fdef expon:k
  :args (s/cat :a valid-i? :dur valid-i? :b valid-i? ))
(stest/instrument `expon:k)

(defn fmrhode
  {:arglists '([kamp kfreq kc3 kc4 kvdepth kvrate ifn7 ifn8 ifn9 ifn10 ivfn])}
  [amp freq c3 c4 vdepth vrate fn7 fn8 fn9 fn10 vfn]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "fmrhode"
                      [amp freq c3 c4 vdepth vrate fn7 fn8 fn9 fn10 vfn]
                      *global*)]
    (new out-types ast)))

(s/fdef fmrhode
  :args (s/cat :amp valid-kr? :freq valid-kr? :c3 valid-kr? :c4 valid-kr? :vdepth valid-kr? :vrate valid-kr? :fn7 valid-i? :fn8 valid-i? :fn9 valid-i? :fn10 valid-i? :vfn valid-i? ))
(stest/instrument `fmrhode)

(defn strlen
  {:arglists '([Sstr])}
  [str]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "strlen"
                      [str]
                      *global*)]
    (new out-types ast)))

(s/fdef strlen
  :args (s/cat :str valid-S? ))
(stest/instrument `strlen)

(defn vbaplsinit
  {:arglists '([idim ilsnum ilsarrayArr] [idim ilsnum & ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray* ilsarray*])}
  [dim lsnum lsarray]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vbaplsinit"
                      [dim lsnum lsarray]
                      *global*)]
    (new out-types ast)))

(s/fdef vbaplsinit
  :args (s/alt
         :iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii (s/cat :dim valid-i? :lsnum valid-i? :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) :lsarray* (s/? valid-i?*) )
         :iiiArr (s/cat :dim valid-i? :lsnum valid-i? :lsarray valid-iArr? )
         ))
(stest/instrument `vbaplsinit)

(defn wgflute
  {:arglists '([kamp kfreq kjet iatt idetk kngain kvibf kvamp & itable* iminfreq* ijetrf* iendrf*])}
  [amp freq jet att detk ngain vibf vamp & [ table* minfreq* jetrf* endrf* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "wgflute"
                      [amp freq jet att detk ngain vibf vamp table* minfreq* jetrf* endrf*]
                      *global*)]
    (new out-types ast)))

(s/fdef wgflute
  :args (s/cat :amp valid-kr? :freq valid-kr? :jet valid-kr? :att valid-i? :detk valid-i? :ngain valid-kr? :vibf valid-kr? :vamp valid-kr? :table* (s/? valid-i?*) :minfreq* (s/? valid-i?*) :jetrf* (s/? valid-i?*) :endrf* (s/? valid-i?*) ))
(stest/instrument `wgflute)

(defn serialWrite
  {:arglists '([iPort SBytes] [iPort kBytes])}
  [Port Bytes]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "serialWrite"
                      [Port Bytes]
                      *global*)]
    (new out-types ast)))

(s/fdef serialWrite
  :args (s/alt
         :ik (s/cat :Port valid-i? :Bytes valid-kr? )
         :iS (s/cat :Port valid-i? :Bytes valid-S? )
         ))
(stest/instrument `serialWrite)

(defn inletf
  {:arglists '([Sname])}
  [name]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "inletf"
                      [name]
                      *global*)]
    (new out-types ast)))

(s/fdef inletf
  :args (s/cat :name valid-S? ))
(stest/instrument `inletf)

(defn lposcil
  {:arglists '([kamp kfreqratio kloop kend & itable* iphase*])}
  [amp freqratio loop end & [ table* phase* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "lposcil"
                      [amp freqratio loop end table* phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef lposcil
  :args (s/cat :amp valid-kr? :freqratio valid-kr? :loop valid-kr? :end valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) ))
(stest/instrument `lposcil)

(defn strupperk
  {:arglists '([Ssrc])}
  [src]
  (let [out-types-quoted 'String
        out-types String
        ast (ast-node out-types-quoted
                      "strupperk"
                      [src]
                      *global*)]
    (new out-types ast)))

(s/fdef strupperk
  :args (s/cat :src valid-S? ))
(stest/instrument `strupperk)

(defn noteondur2
  {:arglists '([ichn inum ivel idur])}
  [chn num vel dur]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "noteondur2"
                      [chn num vel dur]
                      *global*)]
    (new out-types ast)))

(s/fdef noteondur2
  :args (s/cat :chn valid-i? :num valid-i? :vel valid-i? :dur valid-i? ))
(stest/instrument `noteondur2)

(defn vdivv_i
  {:arglists '([ifn1 ifn2 ielements & idstoffset* isrcoffset*])}
  [fn1 fn2 elements & [ dstoffset* srcoffset* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vdivv_i"
                      [fn1 fn2 elements dstoffset* srcoffset*]
                      *global*)]
    (new out-types ast)))

(s/fdef vdivv_i
  :args (s/cat :fn1 valid-i? :fn2 valid-i? :elements valid-i? :dstoffset* (s/? valid-i?*) :srcoffset* (s/? valid-i?*) ))
(stest/instrument `vdivv_i)

(defn rewindscore
  {:arglists '()}
  []
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "rewindscore"
                      []
                      *global*)]
    (new out-types ast)))


(defn serialEnd
  {:arglists '([iPort])}
  [Port]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "serialEnd"
                      [Port]
                      *global*)]
    (new out-types ast)))

(s/fdef serialEnd
  :args (s/cat :Port valid-i? ))
(stest/instrument `serialEnd)

(defn initc14
  {:arglists '([ichan ictlno2 ictlno3 ivalue])}
  [chan ctlno2 ctlno3 value]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "initc14"
                      [chan ctlno2 ctlno3 value]
                      *global*)]
    (new out-types ast)))

(s/fdef initc14
  :args (s/cat :chan valid-i? :ctlno2 valid-i? :ctlno3 valid-i? :value valid-i? ))
(stest/instrument `initc14)

(defn marimba
  {:arglists '([kamp kfreq ihrd ipos imp kvibf kvamp ivibfn idec & idoubles* itriples*])}
  [amp freq hrd pos mp vibf vamp vibfn dec & [ doubles* triples* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "marimba"
                      [amp freq hrd pos mp vibf vamp vibfn dec doubles* triples*]
                      *global*)]
    (new out-types ast)))

(s/fdef marimba
  :args (s/cat :amp valid-kr? :freq valid-kr? :hrd valid-i? :pos valid-i? :mp valid-i? :vibf valid-kr? :vamp valid-kr? :vibfn valid-i? :dec valid-i? :doubles* (s/? valid-i?*) :triples* (s/? valid-i?*) ))
(stest/instrument `marimba)

(defn pvsmorph
  {:arglists '([fsig1 fsig2 kampint kfrqint])}
  [sig1 sig2 ampint frqint]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvsmorph"
                      [sig1 sig2 ampint frqint]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsmorph
  :args (s/cat :sig1 valid-f? :sig2 valid-f? :ampint valid-kr? :frqint valid-kr? ))
(stest/instrument `pvsmorph)

(defn linlin
  {:arglists '([kin ksrclo ksrchi kdstlo kdsthi])}
  [in srclo srchi dstlo dsthi]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "linlin"
                      [in srclo srchi dstlo dsthi]
                      *global*)]
    (new out-types ast)))

(s/fdef linlin
  :args (s/cat :in valid-kr? :srclo valid-kr? :srchi valid-kr? :dstlo valid-kr? :dsthi valid-kr? ))
(stest/instrument `linlin)

(defn vdelayxs
  {:arglists '([ain1 ain2 adl imd iws & ist*])}
  [in1 in2 dl md ws & [ st* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "vdelayxs"
                      [in1 in2 dl md ws st*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef vdelayxs
  :args (s/cat :in1 valid-ar? :in2 valid-ar? :dl valid-ar? :md valid-i? :ws valid-i? :st* (s/? valid-i?*) ))
(stest/instrument `vdelayxs)

(defn wgclar
  {:arglists '([kamp kfreq kstiff iatt idetk kngain kvibf kvamp & itable* iminfreq*])}
  [amp freq stiff att detk ngain vibf vamp & [ table* minfreq* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "wgclar"
                      [amp freq stiff att detk ngain vibf vamp table* minfreq*]
                      *global*)]
    (new out-types ast)))

(s/fdef wgclar
  :args (s/cat :amp valid-kr? :freq valid-kr? :stiff valid-kr? :att valid-i? :detk valid-i? :ngain valid-kr? :vibf valid-kr? :vamp valid-kr? :table* (s/? valid-i?*) :minfreq* (s/? valid-i?*) ))
(stest/instrument `wgclar)

(defn midion
  {:arglists '([kchn knum kvel])}
  [chn num vel]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "midion"
                      [chn num vel]
                      *global*)]
    (new out-types ast)))

(s/fdef midion
  :args (s/cat :chn valid-kr? :num valid-kr? :vel valid-kr? ))
(stest/instrument `midion)

(defn serialBegin
  {:arglists '([SPortName & ibaudRate*])}
  [PortName & [ baudRate* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "serialBegin"
                      [PortName baudRate*]
                      *global*)]
    (new out-types ast)))

(s/fdef serialBegin
  :args (s/cat :PortName valid-S? :baudRate* (s/? valid-i?*) ))
(stest/instrument `serialBegin)

(defn vaddv_i
  {:arglists '([ifn1 ifn2 ielements & idstoffset* isrcoffset*])}
  [fn1 fn2 elements & [ dstoffset* srcoffset* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vaddv_i"
                      [fn1 fn2 elements dstoffset* srcoffset*]
                      *global*)]
    (new out-types ast)))

(s/fdef vaddv_i
  :args (s/cat :fn1 valid-i? :fn2 valid-i? :elements valid-i? :dstoffset* (s/? valid-i?*) :srcoffset* (s/? valid-i?*) ))
(stest/instrument `vaddv_i)

(defn sfplay3m
  {:arglists '([ivel inotenum xamp xfreq ipreindex & iflag* ioffset* ienv*])}
  [vel notenum amp freq preindex & [ flag* offset* env* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "sfplay3m"
                      [vel notenum amp freq preindex flag* offset* env*]
                      *global*)]
    (new out-types ast)))

(s/fdef sfplay3m
  :args (s/cat :vel valid-i? :notenum valid-i? :amp valid-x? :freq valid-x? :preindex valid-i? :flag* (s/? valid-i?*) :offset* (s/? valid-i?*) :env* (s/? valid-i?*) ))
(stest/instrument `sfplay3m)

(defn strupper
  {:arglists '([Ssrc])}
  [src]
  (let [out-types-quoted 'String
        out-types String
        ast (ast-node out-types-quoted
                      "strupper"
                      [src]
                      *global*)]
    (new out-types ast)))

(s/fdef strupper
  :args (s/cat :src valid-S? ))
(stest/instrument `strupper)

(defn soundin
  {:arglists '([Sfilcod & iskptim* iformat* iskipinit* ibufsize*] [ifilcod & iskptim* iformat* iskipinit* ibufsize*])}
  [filcod & [ skptim* format* skipinit* bufsize* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "soundin"
                      [filcod skptim* format* skipinit* bufsize*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef soundin
  :args (s/alt
         :iiiii (s/cat :filcod valid-i? :skptim* (s/? valid-i?*) :format* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :bufsize* (s/? valid-i?*) )
         :Siiii (s/cat :filcod valid-S? :skptim* (s/? valid-i?*) :format* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :bufsize* (s/? valid-i?*) )
         ))
(stest/instrument `soundin)

(defn vco2ift
  {:arglists '([icps & iwave* inyx*])}
  [cps & [ wave* nyx* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "vco2ift"
                      [cps wave* nyx*]
                      *global*)]
    (new out-types ast)))

(s/fdef vco2ift
  :args (s/cat :cps valid-i? :wave* (s/? valid-i?*) :nyx* (s/? valid-i?*) ))
(stest/instrument `vco2ift)

(defn resonr
  {:arglists '([asig xcenter-frequency xbandwidth & iscale* iskip*])}
  [sig center-frequency bandwidth & [ scale* skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "resonr"
                      [sig center-frequency bandwidth scale* skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef resonr
  :args (s/cat :sig valid-ar? :center-frequency valid-x? :bandwidth valid-x? :scale* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `resonr)

(defn lpslot
  {:arglists '([islot])}
  [slot]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "lpslot"
                      [slot]
                      *global*)]
    (new out-types ast)))

(s/fdef lpslot
  :args (s/cat :slot valid-i? ))
(stest/instrument `lpslot)

(defn bqrez
  {:arglists '([asig xcutoff-frequency xresonance & imode* iskip*])}
  [sig cutoff-frequency resonance & [ mode* skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "bqrez"
                      [sig cutoff-frequency resonance mode* skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef bqrez
  :args (s/cat :sig valid-ar? :cutoff-frequency valid-x? :resonance valid-x? :mode* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `bqrez)

(defn resonxk
  {:arglists '([ksig kcenter-frequency kbandwidth & inumlayer* iscale* istor*])}
  [sig center-frequency bandwidth & [ numlayer* scale* stor* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "resonxk"
                      [sig center-frequency bandwidth numlayer* scale* stor*]
                      *global*)]
    (new out-types ast)))

(s/fdef resonxk
  :args (s/cat :sig valid-kr? :center-frequency valid-kr? :bandwidth valid-kr? :numlayer* (s/? valid-i?*) :scale* (s/? valid-i?*) :stor* (s/? valid-i?*) ))
(stest/instrument `resonxk)

(defn phaser1
  {:arglists '([asig kfreq kord kfeedback & iskip*])}
  [sig freq ord feedback & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "phaser1"
                      [sig freq ord feedback skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef phaser1
  :args (s/cat :sig valid-ar? :freq valid-kr? :ord valid-kr? :feedback valid-kr? :skip* (s/? valid-i?*) ))
(stest/instrument `phaser1)

(defn dconv
  {:arglists '([asig isize itable])}
  [sig size table]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "dconv"
                      [sig size table]
                      *global*)]
    (new out-types ast)))

(s/fdef dconv
  :args (s/cat :sig valid-ar? :size valid-i? :table valid-i? ))
(stest/instrument `dconv)

(defn vbapz
  {:arglists '([inumchnls istartndx asig kazim & kelev* kspread* ispread*])}
  [numchnls startndx sig azim & [ elev* spread* spread* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vbapz"
                      [numchnls startndx sig azim elev* spread* spread*]
                      *global*)]
    (new out-types ast)))

(s/fdef vbapz
  :args (s/cat :numchnls valid-i? :startndx valid-i? :sig valid-ar? :azim valid-kr? :elev* (s/? valid-kr?*) :spread* (s/? valid-kr?*) :spread* (s/? valid-i?*) ))
(stest/instrument `vbapz)

(defn lowres
  {:arglists '([asig acutoff aresonance & iskip*] [asig acutoff kresonance & iskip*] [asig kcutoff aresonance & iskip*] [asig kcutoff kresonance & iskip*])}
  [sig cutoff resonance & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "lowres"
                      [sig cutoff resonance skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef lowres
  :args (s/alt
         :akki (s/cat :sig valid-ar? :cutoff valid-kr? :resonance valid-kr? :skip* (s/? valid-i?*) )
         :akai (s/cat :sig valid-ar? :cutoff valid-kr? :resonance valid-ar? :skip* (s/? valid-i?*) )
         :aaki (s/cat :sig valid-ar? :cutoff valid-ar? :resonance valid-kr? :skip* (s/? valid-i?*) )
         :aaai (s/cat :sig valid-ar? :cutoff valid-ar? :resonance valid-ar? :skip* (s/? valid-i?*) )
         ))
(stest/instrument `lowres)

(defn deltapn
  {:arglists '([xnumsamps & inumsamps*])}
  [numsamps & [ numsamps* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "deltapn"
                      [numsamps numsamps*]
                      *global*)]
    (new out-types ast)))

(s/fdef deltapn
  :args (s/cat :numsamps valid-x? :numsamps* (s/? valid-i?*) ))
(stest/instrument `deltapn)

(defn instr
  {:arglists '()}
  []
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "instr"
                      []
                      *global*)]
    (new out-types ast)))


(defn miditempo
  {:arglists '()}
  []
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "miditempo"
                      []
                      *global*)]
    (new out-types ast)))


(defn oscil3
  {:arglists '([aamp acps itableArr & iphase*] [aamp acps & itable* iphase*] [aamp kcps itableArr & iphase*] [aamp kcps & itable* iphase*] [kamp acps itableArr & iphase*] [kamp acps & itable* iphase*] [kamp kcps itableArr & iphase*] [kamp kcps & itable* iphase*] [kamp kcps itableArr & iphase*] [kamp kcps & itable* iphase*])}
  [amp cps table & [ phase* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "oscil3"
                      [amp cps table phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef oscil3
  :args (s/alt
         :kkii (s/cat :amp valid-kr? :cps valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :kkiArri (s/cat :amp valid-kr? :cps valid-kr? :table valid-iArr? :phase* (s/? valid-i?*) )
         :kaii (s/cat :amp valid-kr? :cps valid-ar? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :kaiArri (s/cat :amp valid-kr? :cps valid-ar? :table valid-iArr? :phase* (s/? valid-i?*) )
         :akii (s/cat :amp valid-ar? :cps valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :akiArri (s/cat :amp valid-ar? :cps valid-kr? :table valid-iArr? :phase* (s/? valid-i?*) )
         :aaii (s/cat :amp valid-ar? :cps valid-ar? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :aaiArri (s/cat :amp valid-ar? :cps valid-ar? :table valid-iArr? :phase* (s/? valid-i?*) )
         ))
(stest/instrument `oscil3)

(defn oscil3:a
  {:arglists '([aamp acps itableArr & iphase*] [aamp acps & itable* iphase*] [aamp kcps itableArr & iphase*] [aamp kcps & itable* iphase*] [kamp acps itableArr & iphase*] [kamp acps & itable* iphase*] [kamp kcps itableArr & iphase*] [kamp kcps & itable* iphase*])}
  [amp cps table & [ phase* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "oscil3"
                      [amp cps table phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef oscil3:a
  :args (s/alt
         :kkii (s/cat :amp valid-kr? :cps valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :kkiArri (s/cat :amp valid-kr? :cps valid-kr? :table valid-iArr? :phase* (s/? valid-i?*) )
         :kaii (s/cat :amp valid-kr? :cps valid-ar? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :kaiArri (s/cat :amp valid-kr? :cps valid-ar? :table valid-iArr? :phase* (s/? valid-i?*) )
         :akii (s/cat :amp valid-ar? :cps valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :akiArri (s/cat :amp valid-ar? :cps valid-kr? :table valid-iArr? :phase* (s/? valid-i?*) )
         :aaii (s/cat :amp valid-ar? :cps valid-ar? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :aaiArri (s/cat :amp valid-ar? :cps valid-ar? :table valid-iArr? :phase* (s/? valid-i?*) )
         ))
(stest/instrument `oscil3:a)

(defn oscil3:k
  {:arglists '([kamp kcps itableArr & iphase*] [kamp kcps & itable* iphase*])}
  [amp cps table & [ phase* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "oscil3"
                      [amp cps table phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef oscil3:k
  :args (s/alt
         :kkii (s/cat :amp valid-kr? :cps valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :kkiArri (s/cat :amp valid-kr? :cps valid-kr? :table valid-iArr? :phase* (s/? valid-i?*) )
         ))
(stest/instrument `oscil3:k)

(defn octmidib
  {:arglists '([& irange*] [& irange*])}
  [& [ range* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "octmidib"
                      [range*]
                      *global*)]
    (new out-types ast)))

(s/fdef octmidib
  :args (s/alt
         :i (s/cat :range* (s/? valid-i?*) )
         ))
(stest/instrument `octmidib)

(defn octmidib:i
  {:arglists '([& irange*])}
  [& [ range* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "octmidib"
                      [range*]
                      *global*)]
    (new out-types ast)))

(s/fdef octmidib:i
  :args (s/cat :range* (s/? valid-i?*) ))
(stest/instrument `octmidib:i)

(defn octmidib:k
  {:arglists '([& irange*])}
  [& [ range* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "octmidib"
                      [range*]
                      *global*)]
    (new out-types ast)))

(s/fdef octmidib:k
  :args (s/cat :range* (s/? valid-i?*) ))
(stest/instrument `octmidib:k)

(defn vtabwa
  {:arglists '([aindex itable & ainarg1* ainarg2* ainarg3* ainargN4* ainargN5* ainargN6* ainargN7* ainargN8* ainargN9* ainargN10* ainargN11* ainargN12* ainargN13* ainargN14* ainargN15* ainargN16* ainargN17* ainargN18* ainargN19* ainargN20* ainargN21* ainargN22* ainargN23* ainargN24* ainargN25* ainargN26* ainargN27* ainargN28* ainargN29* ainargN30* ainargN31* ainargN32*])}
  [index table & [ inarg1* inarg2* inarg3* inargN4* inargN5* inargN6* inargN7* inargN8* inargN9* inargN10* inargN11* inargN12* inargN13* inargN14* inargN15* inargN16* inargN17* inargN18* inargN19* inargN20* inargN21* inargN22* inargN23* inargN24* inargN25* inargN26* inargN27* inargN28* inargN29* inargN30* inargN31* inargN32* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vtabwa"
                      [index table inarg1* inarg2* inarg3* inargN4* inargN5* inargN6* inargN7* inargN8* inargN9* inargN10* inargN11* inargN12* inargN13* inargN14* inargN15* inargN16* inargN17* inargN18* inargN19* inargN20* inargN21* inargN22* inargN23* inargN24* inargN25* inargN26* inargN27* inargN28* inargN29* inargN30* inargN31* inargN32*]
                      *global*)]
    (new out-types ast)))

(s/fdef vtabwa
  :args (s/cat :index valid-ar? :table valid-i? :inarg1* (s/? valid-ar?*) :inarg2* (s/? valid-ar?*) :inarg3* (s/? valid-ar?*) :inargN4* (s/? valid-ar?*) :inargN5* (s/? valid-ar?*) :inargN6* (s/? valid-ar?*) :inargN7* (s/? valid-ar?*) :inargN8* (s/? valid-ar?*) :inargN9* (s/? valid-ar?*) :inargN10* (s/? valid-ar?*) :inargN11* (s/? valid-ar?*) :inargN12* (s/? valid-ar?*) :inargN13* (s/? valid-ar?*) :inargN14* (s/? valid-ar?*) :inargN15* (s/? valid-ar?*) :inargN16* (s/? valid-ar?*) :inargN17* (s/? valid-ar?*) :inargN18* (s/? valid-ar?*) :inargN19* (s/? valid-ar?*) :inargN20* (s/? valid-ar?*) :inargN21* (s/? valid-ar?*) :inargN22* (s/? valid-ar?*) :inargN23* (s/? valid-ar?*) :inargN24* (s/? valid-ar?*) :inargN25* (s/? valid-ar?*) :inargN26* (s/? valid-ar?*) :inargN27* (s/? valid-ar?*) :inargN28* (s/? valid-ar?*) :inargN29* (s/? valid-ar?*) :inargN30* (s/? valid-ar?*) :inargN31* (s/? valid-ar?*) :inargN32* (s/? valid-ar?*) ))
(stest/instrument `vtabwa)

(defn gendyc
  {:arglists '([kamp kampdist kdurdist kadpar kddpar kminfreq kmaxfreq kampscl kdurscl & initcps* knum*] [kamp kampdist kdurdist kadpar kddpar kminfreq kmaxfreq kampscl kdurscl & initcps* knum*])}
  [amp ampdist durdist adpar ddpar minfreq maxfreq ampscl durscl & [ nitcps* num* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "gendyc"
                      [amp ampdist durdist adpar ddpar minfreq maxfreq ampscl durscl nitcps* num*]
                      *global*)]
    (new out-types ast)))

(s/fdef gendyc
  :args (s/alt
         :kkkkkkkkkik (s/cat :amp valid-kr? :ampdist valid-kr? :durdist valid-kr? :adpar valid-kr? :ddpar valid-kr? :minfreq valid-kr? :maxfreq valid-kr? :ampscl valid-kr? :durscl valid-kr? :nitcps* (s/? valid-i?*) :num* (s/? valid-kr?*) )
         ))
(stest/instrument `gendyc)

(defn gendyc:a
  {:arglists '([kamp kampdist kdurdist kadpar kddpar kminfreq kmaxfreq kampscl kdurscl & initcps* knum*])}
  [amp ampdist durdist adpar ddpar minfreq maxfreq ampscl durscl & [ nitcps* num* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "gendyc"
                      [amp ampdist durdist adpar ddpar minfreq maxfreq ampscl durscl nitcps* num*]
                      *global*)]
    (new out-types ast)))

(s/fdef gendyc:a
  :args (s/cat :amp valid-kr? :ampdist valid-kr? :durdist valid-kr? :adpar valid-kr? :ddpar valid-kr? :minfreq valid-kr? :maxfreq valid-kr? :ampscl valid-kr? :durscl valid-kr? :nitcps* (s/? valid-i?*) :num* (s/? valid-kr?*) ))
(stest/instrument `gendyc:a)

(defn gendyc:k
  {:arglists '([kamp kampdist kdurdist kadpar kddpar kminfreq kmaxfreq kampscl kdurscl & initcps* knum*])}
  [amp ampdist durdist adpar ddpar minfreq maxfreq ampscl durscl & [ nitcps* num* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "gendyc"
                      [amp ampdist durdist adpar ddpar minfreq maxfreq ampscl durscl nitcps* num*]
                      *global*)]
    (new out-types ast)))

(s/fdef gendyc:k
  :args (s/cat :amp valid-kr? :ampdist valid-kr? :durdist valid-kr? :adpar valid-kr? :ddpar valid-kr? :minfreq valid-kr? :maxfreq valid-kr? :ampscl valid-kr? :durscl valid-kr? :nitcps* (s/? valid-i?*) :num* (s/? valid-kr?*) ))
(stest/instrument `gendyc:k)

(defn inx
  {:arglists '()}
  []
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "inx"
                      []
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))


(defn pvsfread
  {:arglists '([ktimpt Stable & ichan*] [ktimpt itable & ichan*])}
  [timpt table & [ chan* ]]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvsfread"
                      [timpt table chan*]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsfread
  :args (s/alt
         :kii (s/cat :timpt valid-kr? :table valid-i? :chan* (s/? valid-i?*) )
         :kSi (s/cat :timpt valid-kr? :table valid-S? :chan* (s/? valid-i?*) )
         ))
(stest/instrument `pvsfread)

(defn tlineto
  {:arglists '([ksig ktime ktrig])}
  [sig time trig]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "tlineto"
                      [sig time trig]
                      *global*)]
    (new out-types ast)))

(s/fdef tlineto
  :args (s/cat :sig valid-kr? :time valid-kr? :trig valid-kr? ))
(stest/instrument `tlineto)

(defn filelen
  {:arglists '([Sfilcod & iallowraw*] [ifilcod & iallowraw*])}
  [filcod & [ allowraw* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "filelen"
                      [filcod allowraw*]
                      *global*)]
    (new out-types ast)))

(s/fdef filelen
  :args (s/alt
         :ii (s/cat :filcod valid-i? :allowraw* (s/? valid-i?*) )
         :Si (s/cat :filcod valid-S? :allowraw* (s/? valid-i?*) )
         ))
(stest/instrument `filelen)

(defn tabmorph
  {:arglists '([kindex kweightpoint ktabnum3 ktabnum4 & ifn1* ifn2* ifn3* ifn4* ifnN5* ifnN6* ifnN7* ifnN8* ifnN9* ifnN10* ifnN11* ifnN12* ifnN13* ifnN14* ifnN15* ifnN16*])}
  [index weightpoint tabnum3 tabnum4 & [ fn1* fn2* fn3* fn4* fnN5* fnN6* fnN7* fnN8* fnN9* fnN10* fnN11* fnN12* fnN13* fnN14* fnN15* fnN16* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "tabmorph"
                      [index weightpoint tabnum3 tabnum4 fn1* fn2* fn3* fn4* fnN5* fnN6* fnN7* fnN8* fnN9* fnN10* fnN11* fnN12* fnN13* fnN14* fnN15* fnN16*]
                      *global*)]
    (new out-types ast)))

(s/fdef tabmorph
  :args (s/cat :index valid-kr? :weightpoint valid-kr? :tabnum3 valid-kr? :tabnum4 valid-kr? :fn1* (s/? valid-i?*) :fn2* (s/? valid-i?*) :fn3* (s/? valid-i?*) :fn4* (s/? valid-i?*) :fnN5* (s/? valid-i?*) :fnN6* (s/? valid-i?*) :fnN7* (s/? valid-i?*) :fnN8* (s/? valid-i?*) :fnN9* (s/? valid-i?*) :fnN10* (s/? valid-i?*) :fnN11* (s/? valid-i?*) :fnN12* (s/? valid-i?*) :fnN13* (s/? valid-i?*) :fnN14* (s/? valid-i?*) :fnN15* (s/? valid-i?*) :fnN16* (s/? valid-i?*) ))
(stest/instrument `tabmorph)

(defn deltap3
  {:arglists '([xdlt & idlt*])}
  [dlt & [ dlt* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "deltap3"
                      [dlt dlt*]
                      *global*)]
    (new out-types ast)))

(s/fdef deltap3
  :args (s/cat :dlt valid-x? :dlt* (s/? valid-i?*) ))
(stest/instrument `deltap3)

(defn tbvcf
  {:arglists '([asig xcutoff-frequency xresonance kdistortion kasym & iskip*])}
  [sig cutoff-frequency resonance distortion asym & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "tbvcf"
                      [sig cutoff-frequency resonance distortion asym skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef tbvcf
  :args (s/cat :sig valid-ar? :cutoff-frequency valid-x? :resonance valid-x? :distortion valid-kr? :asym valid-kr? :skip* (s/? valid-i?*) ))
(stest/instrument `tbvcf)

(defn sc_lag
  {:arglists '([ain klagtime & initialvalue*] [kin klagtime & initialvalue*])}
  [in lagtime & [ nitialvalue* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "sc_lag"
                      [in lagtime nitialvalue*]
                      *global*)]
    (new out-types ast)))

(s/fdef sc_lag
  :args (s/alt
         :kki (s/cat :in valid-kr? :lagtime valid-kr? :nitialvalue* (s/? valid-i?*) )
         :aki (s/cat :in valid-ar? :lagtime valid-kr? :nitialvalue* (s/? valid-i?*) )
         ))
(stest/instrument `sc_lag)

(defn sc_lag:a
  {:arglists '([ain klagtime & initialvalue*])}
  [in lagtime & [ nitialvalue* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "sc_lag"
                      [in lagtime nitialvalue*]
                      *global*)]
    (new out-types ast)))

(s/fdef sc_lag:a
  :args (s/cat :in valid-ar? :lagtime valid-kr? :nitialvalue* (s/? valid-i?*) ))
(stest/instrument `sc_lag:a)

(defn sc_lag:k
  {:arglists '([kin klagtime & initialvalue*])}
  [in lagtime & [ nitialvalue* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "sc_lag"
                      [in lagtime nitialvalue*]
                      *global*)]
    (new out-types ast)))

(s/fdef sc_lag:k
  :args (s/cat :in valid-kr? :lagtime valid-kr? :nitialvalue* (s/? valid-i?*) ))
(stest/instrument `sc_lag:k)

(defn cpuprc
  {:arglists '([Sinsname ipercent] [iinsname ipercent])}
  [insname percent]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "cpuprc"
                      [insname percent]
                      *global*)]
    (new out-types ast)))

(s/fdef cpuprc
  :args (s/alt
         :ii (s/cat :insname valid-i? :percent valid-i? )
         :Si (s/cat :insname valid-S? :percent valid-i? )
         ))
(stest/instrument `cpuprc)

(defn ATSadd
  {:arglists '([ktimepnt kfmod Satsfile itable ipartials & ipartialoffset* ipartialincr* igatefn*] [ktimepnt kfmod iatsfile itable ipartials & ipartialoffset* ipartialincr* igatefn*])}
  [timepnt fmod atsfile table partials & [ partialoffset* partialincr* gatefn* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "ATSadd"
                      [timepnt fmod atsfile table partials partialoffset* partialincr* gatefn*]
                      *global*)]
    (new out-types ast)))

(s/fdef ATSadd
  :args (s/alt
         :kkiiiiii (s/cat :timepnt valid-kr? :fmod valid-kr? :atsfile valid-i? :table valid-i? :partials valid-i? :partialoffset* (s/? valid-i?*) :partialincr* (s/? valid-i?*) :gatefn* (s/? valid-i?*) )
         :kkSiiiii (s/cat :timepnt valid-kr? :fmod valid-kr? :atsfile valid-S? :table valid-i? :partials valid-i? :partialoffset* (s/? valid-i?*) :partialincr* (s/? valid-i?*) :gatefn* (s/? valid-i?*) )
         ))
(stest/instrument `ATSadd)

(defn vsubv_i
  {:arglists '([ifn1 ifn2 ielements & idstoffset* isrcoffset*])}
  [fn1 fn2 elements & [ dstoffset* srcoffset* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vsubv_i"
                      [fn1 fn2 elements dstoffset* srcoffset*]
                      *global*)]
    (new out-types ast)))

(s/fdef vsubv_i
  :args (s/cat :fn1 valid-i? :fn2 valid-i? :elements valid-i? :dstoffset* (s/? valid-i?*) :srcoffset* (s/? valid-i?*) ))
(stest/instrument `vsubv_i)

(defn vadd_i
  {:arglists '([itable ival ielements & idstoffset*])}
  [table val elements & [ dstoffset* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vadd_i"
                      [table val elements dstoffset*]
                      *global*)]
    (new out-types ast)))

(s/fdef vadd_i
  :args (s/cat :table valid-i? :val valid-i? :elements valid-i? :dstoffset* (s/? valid-i?*) ))
(stest/instrument `vadd_i)

(defn scale
  {:arglists '([kinput kmax kmin])}
  [input max min]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "scale"
                      [input max min]
                      *global*)]
    (new out-types ast)))

(s/fdef scale
  :args (s/cat :input valid-kr? :max valid-kr? :min valid-kr? ))
(stest/instrument `scale)

(defn ceps
  {:arglists '([kmagsArr kcoefs])}
  [mags coefs]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "ceps"
                      [mags coefs]
                      *global*)]
    (new out-types ast)))

(s/fdef ceps
  :args (s/cat :mags valid-kArr? :coefs valid-kr? ))
(stest/instrument `ceps)

(defn hrtfearly
  {:arglists '([asrc xsrcx xsrcy xsrcz xlstnrx xlstnry xlstnrz Sfilel Sfiler idefroom & ifade* isr* iorder* ithreed* kheadrot* iroomx* iroomy* iroomz* iwallhigh* iwalllow* iwallgain1* iwallgain1* iwallgain1* ifloorhigh* ifloorlow* ifloorgain1* ifloorgain1* ifloorgain1* iceilinghigh* iceilinglow* iceilinggain1* iceilinggain1* iceilinggain1*])}
  [src srcx srcy srcz lstnrx lstnry lstnrz filel filer defroom & [ fade* sr* order* threed* headrot* roomx* roomy* roomz* wallhigh* walllow* wallgain1* wallgain1* wallgain1* floorhigh* floorlow* floorgain1* floorgain1* floorgain1* ceilinghigh* ceilinglow* ceilinggain1* ceilinggain1* ceilinggain1* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal Variable Variable Variable]
        out-types [AudioSignal AudioSignal Variable Variable Variable]
        ast (ast-node out-types-quoted
                      "hrtfearly"
                      [src srcx srcy srcz lstnrx lstnry lstnrz filel filer defroom fade* sr* order* threed* headrot* roomx* roomy* roomz* wallhigh* walllow* wallgain1* wallgain1* wallgain1* floorhigh* floorlow* floorgain1* floorgain1* floorgain1* ceilinghigh* ceilinglow* ceilinggain1* ceilinggain1* ceilinggain1*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef hrtfearly
  :args (s/cat :src valid-ar? :srcx valid-x? :srcy valid-x? :srcz valid-x? :lstnrx valid-x? :lstnry valid-x? :lstnrz valid-x? :filel valid-S? :filer valid-S? :defroom valid-i? :fade* (s/? valid-i?*) :sr* (s/? valid-i?*) :order* (s/? valid-i?*) :threed* (s/? valid-i?*) :headrot* (s/? valid-kr?*) :roomx* (s/? valid-i?*) :roomy* (s/? valid-i?*) :roomz* (s/? valid-i?*) :wallhigh* (s/? valid-i?*) :walllow* (s/? valid-i?*) :wallgain1* (s/? valid-i?*) :wallgain1* (s/? valid-i?*) :wallgain1* (s/? valid-i?*) :floorhigh* (s/? valid-i?*) :floorlow* (s/? valid-i?*) :floorgain1* (s/? valid-i?*) :floorgain1* (s/? valid-i?*) :floorgain1* (s/? valid-i?*) :ceilinghigh* (s/? valid-i?*) :ceilinglow* (s/? valid-i?*) :ceilinggain1* (s/? valid-i?*) :ceilinggain1* (s/? valid-i?*) :ceilinggain1* (s/? valid-i?*) ))
(stest/instrument `hrtfearly)

(defn s32b14
  {:arglists '([ichan ictlno_msb2 ictlno_lsb3 imin4 imax5 initvalue6 ifn7 ictlno_msb8 ictlno_lsb9 imin10 imax11 initvalue12 ifn13 ifn14 ifn15 ifn16 ifn17 ifn18 ifn19 ifn20 ifn21 ifn22 ifn23 ifn24 ifn25 ifn26 ifn27 ifn28 ifn29 ifn30 ifn31 ifn32 ifn33 ifn34 ifn35 ifn36 ifn37 ifn38 ifn39 ifn40 ifn41 ifn42 ifn43 ifn44 ifn45 ifn46 ifn47 ifn48 ifn49 ifn50 ifn51 ifn52 ifn53 ifn54 ifn55 ifn56 ifn57 ifn58 ifn59 ifn60 ifn61 ifn62 ifn63 ifn64 ifn65 ifn66 ifn67 ifn68 ifn69 ifn70 ifn71 ifn72 ifn73 ifn74 ifn75 ifn76 ifn77 ifn78 ifn79 ifn80 ifn81 ifn82 ifn83 ifn84 ifn85 ifn86 ifn87 ifn88 ifn89 ifn90 ifn91 ifn92 ifn93 ifn94 ifn95 ifn96 ifn97 ifn98 ifn99 ifn100 ifn101 ifn102 ifn103 ifn104 ifn105 ifn106 ifn107 ifn108 ifn109 ifn110 ifn111 ifn112 ifn113 ifn114 ifn115 ifn116 ifn117 ifn118 ifn119 ifn120 ifn121 ifn122 ifn123 ifn124 ifn125 ifn126 ifn127 ifn128 ifn129 ifn130 ifn131 ifn132 ifn133 ifn134 ifn135 ifn136 ifn137 ifn138 ifn139 ifn140 ifn141 ifn142 ifn143 ifn144 ifn145 ifn146 ifn147 ifn148 ifn149 ifn150 ifn151 ifn152 ifn153 ifn154 ifn155 ifn156 ifn157 ifn158 ifn159 ifn160 ifn161] [ichan ictlno_msb2 ictlno_lsb3 imin4 imax5 initvalue6 ifn7 ictlno_msb8 ictlno_lsb9 imin10 imax11 initvalue12 ifn13 ifn14 ifn15 ifn16 ifn17 ifn18 ifn19 ifn20 ifn21 ifn22 ifn23 ifn24 ifn25 ifn26 ifn27 ifn28 ifn29 ifn30 ifn31 ifn32 ifn33 ifn34 ifn35 ifn36 ifn37 ifn38 ifn39 ifn40 ifn41 ifn42 ifn43 ifn44 ifn45 ifn46 ifn47 ifn48 ifn49 ifn50 ifn51 ifn52 ifn53 ifn54 ifn55 ifn56 ifn57 ifn58 ifn59 ifn60 ifn61 ifn62 ifn63 ifn64 ifn65 ifn66 ifn67 ifn68 ifn69 ifn70 ifn71 ifn72 ifn73 ifn74 ifn75 ifn76 ifn77 ifn78 ifn79 ifn80 ifn81 ifn82 ifn83 ifn84 ifn85 ifn86 ifn87 ifn88 ifn89 ifn90 ifn91 ifn92 ifn93 ifn94 ifn95 ifn96 ifn97 ifn98 ifn99 ifn100 ifn101 ifn102 ifn103 ifn104 ifn105 ifn106 ifn107 ifn108 ifn109 ifn110 ifn111 ifn112 ifn113 ifn114 ifn115 ifn116 ifn117 ifn118 ifn119 ifn120 ifn121 ifn122 ifn123 ifn124 ifn125 ifn126 ifn127 ifn128 ifn129 ifn130 ifn131 ifn132 ifn133 ifn134 ifn135 ifn136 ifn137 ifn138 ifn139 ifn140 ifn141 ifn142 ifn143 ifn144 ifn145 ifn146 ifn147 ifn148 ifn149 ifn150 ifn151 ifn152 ifn153 ifn154 ifn155 ifn156 ifn157 ifn158 ifn159 ifn160 ifn161 ifn162 ifn163 ifn164 ifn165 ifn166 ifn167 ifn168 ifn169 ifn170 ifn171 ifn172 ifn173 ifn174 ifn175 ifn176 ifn177 ifn178 ifn179 ifn180 ifn181 ifn182 ifn183 ifn184 ifn185 ifn186 ifn187 ifn188 ifn189 ifn190 ifn191 ifn192 ifn193])}
  [chan ctlno_msb2 ctlno_lsb3 min4 max5 nitvalue6 fn7 ctlno_msb8 ctlno_lsb9 min10 max11 nitvalue12 fn13 fn14 fn15 fn16 fn17 fn18 fn19 fn20 fn21 fn22 fn23 fn24 fn25 fn26 fn27 fn28 fn29 fn30 fn31 fn32 fn33 fn34 fn35 fn36 fn37 fn38 fn39 fn40 fn41 fn42 fn43 fn44 fn45 fn46 fn47 fn48 fn49 fn50 fn51 fn52 fn53 fn54 fn55 fn56 fn57 fn58 fn59 fn60 fn61 fn62 fn63 fn64 fn65 fn66 fn67 fn68 fn69 fn70 fn71 fn72 fn73 fn74 fn75 fn76 fn77 fn78 fn79 fn80 fn81 fn82 fn83 fn84 fn85 fn86 fn87 fn88 fn89 fn90 fn91 fn92 fn93 fn94 fn95 fn96 fn97 fn98 fn99 fn100 fn101 fn102 fn103 fn104 fn105 fn106 fn107 fn108 fn109 fn110 fn111 fn112 fn113 fn114 fn115 fn116 fn117 fn118 fn119 fn120 fn121 fn122 fn123 fn124 fn125 fn126 fn127 fn128 fn129 fn130 fn131 fn132 fn133 fn134 fn135 fn136 fn137 fn138 fn139 fn140 fn141 fn142 fn143 fn144 fn145 fn146 fn147 fn148 fn149 fn150 fn151 fn152 fn153 fn154 fn155 fn156 fn157 fn158 fn159 fn160 fn161]
  (let [out-types-quoted '[Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable]
        out-types [Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable]
        ast (ast-node out-types-quoted
                      "s32b14"
                      [chan ctlno_msb2 ctlno_lsb3 min4 max5 nitvalue6 fn7 ctlno_msb8 ctlno_lsb9 min10 max11 nitvalue12 fn13 fn14 fn15 fn16 fn17 fn18 fn19 fn20 fn21 fn22 fn23 fn24 fn25 fn26 fn27 fn28 fn29 fn30 fn31 fn32 fn33 fn34 fn35 fn36 fn37 fn38 fn39 fn40 fn41 fn42 fn43 fn44 fn45 fn46 fn47 fn48 fn49 fn50 fn51 fn52 fn53 fn54 fn55 fn56 fn57 fn58 fn59 fn60 fn61 fn62 fn63 fn64 fn65 fn66 fn67 fn68 fn69 fn70 fn71 fn72 fn73 fn74 fn75 fn76 fn77 fn78 fn79 fn80 fn81 fn82 fn83 fn84 fn85 fn86 fn87 fn88 fn89 fn90 fn91 fn92 fn93 fn94 fn95 fn96 fn97 fn98 fn99 fn100 fn101 fn102 fn103 fn104 fn105 fn106 fn107 fn108 fn109 fn110 fn111 fn112 fn113 fn114 fn115 fn116 fn117 fn118 fn119 fn120 fn121 fn122 fn123 fn124 fn125 fn126 fn127 fn128 fn129 fn130 fn131 fn132 fn133 fn134 fn135 fn136 fn137 fn138 fn139 fn140 fn141 fn142 fn143 fn144 fn145 fn146 fn147 fn148 fn149 fn150 fn151 fn152 fn153 fn154 fn155 fn156 fn157 fn158 fn159 fn160 fn161]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef s32b14
  :args (s/alt
         :iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii (s/cat :chan valid-i? :ctlno_msb2 valid-i? :ctlno_lsb3 valid-i? :min4 valid-i? :max5 valid-i? :nitvalue6 valid-i? :fn7 valid-i? :ctlno_msb8 valid-i? :ctlno_lsb9 valid-i? :min10 valid-i? :max11 valid-i? :nitvalue12 valid-i? :fn13 valid-i? :fn14 valid-i? :fn15 valid-i? :fn16 valid-i? :fn17 valid-i? :fn18 valid-i? :fn19 valid-i? :fn20 valid-i? :fn21 valid-i? :fn22 valid-i? :fn23 valid-i? :fn24 valid-i? :fn25 valid-i? :fn26 valid-i? :fn27 valid-i? :fn28 valid-i? :fn29 valid-i? :fn30 valid-i? :fn31 valid-i? :fn32 valid-i? :fn33 valid-i? :fn34 valid-i? :fn35 valid-i? :fn36 valid-i? :fn37 valid-i? :fn38 valid-i? :fn39 valid-i? :fn40 valid-i? :fn41 valid-i? :fn42 valid-i? :fn43 valid-i? :fn44 valid-i? :fn45 valid-i? :fn46 valid-i? :fn47 valid-i? :fn48 valid-i? :fn49 valid-i? :fn50 valid-i? :fn51 valid-i? :fn52 valid-i? :fn53 valid-i? :fn54 valid-i? :fn55 valid-i? :fn56 valid-i? :fn57 valid-i? :fn58 valid-i? :fn59 valid-i? :fn60 valid-i? :fn61 valid-i? :fn62 valid-i? :fn63 valid-i? :fn64 valid-i? :fn65 valid-i? :fn66 valid-i? :fn67 valid-i? :fn68 valid-i? :fn69 valid-i? :fn70 valid-i? :fn71 valid-i? :fn72 valid-i? :fn73 valid-i? :fn74 valid-i? :fn75 valid-i? :fn76 valid-i? :fn77 valid-i? :fn78 valid-i? :fn79 valid-i? :fn80 valid-i? :fn81 valid-i? :fn82 valid-i? :fn83 valid-i? :fn84 valid-i? :fn85 valid-i? :fn86 valid-i? :fn87 valid-i? :fn88 valid-i? :fn89 valid-i? :fn90 valid-i? :fn91 valid-i? :fn92 valid-i? :fn93 valid-i? :fn94 valid-i? :fn95 valid-i? :fn96 valid-i? :fn97 valid-i? :fn98 valid-i? :fn99 valid-i? :fn100 valid-i? :fn101 valid-i? :fn102 valid-i? :fn103 valid-i? :fn104 valid-i? :fn105 valid-i? :fn106 valid-i? :fn107 valid-i? :fn108 valid-i? :fn109 valid-i? :fn110 valid-i? :fn111 valid-i? :fn112 valid-i? :fn113 valid-i? :fn114 valid-i? :fn115 valid-i? :fn116 valid-i? :fn117 valid-i? :fn118 valid-i? :fn119 valid-i? :fn120 valid-i? :fn121 valid-i? :fn122 valid-i? :fn123 valid-i? :fn124 valid-i? :fn125 valid-i? :fn126 valid-i? :fn127 valid-i? :fn128 valid-i? :fn129 valid-i? :fn130 valid-i? :fn131 valid-i? :fn132 valid-i? :fn133 valid-i? :fn134 valid-i? :fn135 valid-i? :fn136 valid-i? :fn137 valid-i? :fn138 valid-i? :fn139 valid-i? :fn140 valid-i? :fn141 valid-i? :fn142 valid-i? :fn143 valid-i? :fn144 valid-i? :fn145 valid-i? :fn146 valid-i? :fn147 valid-i? :fn148 valid-i? :fn149 valid-i? :fn150 valid-i? :fn151 valid-i? :fn152 valid-i? :fn153 valid-i? :fn154 valid-i? :fn155 valid-i? :fn156 valid-i? :fn157 valid-i? :fn158 valid-i? :fn159 valid-i? :fn160 valid-i? :fn161 valid-i? :fn162 valid-i? :fn163 valid-i? :fn164 valid-i? :fn165 valid-i? :fn166 valid-i? :fn167 valid-i? :fn168 valid-i? :fn169 valid-i? :fn170 valid-i? :fn171 valid-i? :fn172 valid-i? :fn173 valid-i? :fn174 valid-i? :fn175 valid-i? :fn176 valid-i? :fn177 valid-i? :fn178 valid-i? :fn179 valid-i? :fn180 valid-i? :fn181 valid-i? :fn182 valid-i? :fn183 valid-i? :fn184 valid-i? :fn185 valid-i? :fn186 valid-i? :fn187 valid-i? :fn188 valid-i? :fn189 valid-i? :fn190 valid-i? :fn191 valid-i? :fn192 valid-i? :fn193 valid-i? )
         :iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii (s/cat :chan valid-i? :ctlno_msb2 valid-i? :ctlno_lsb3 valid-i? :min4 valid-i? :max5 valid-i? :nitvalue6 valid-i? :fn7 valid-i? :ctlno_msb8 valid-i? :ctlno_lsb9 valid-i? :min10 valid-i? :max11 valid-i? :nitvalue12 valid-i? :fn13 valid-i? :fn14 valid-i? :fn15 valid-i? :fn16 valid-i? :fn17 valid-i? :fn18 valid-i? :fn19 valid-i? :fn20 valid-i? :fn21 valid-i? :fn22 valid-i? :fn23 valid-i? :fn24 valid-i? :fn25 valid-i? :fn26 valid-i? :fn27 valid-i? :fn28 valid-i? :fn29 valid-i? :fn30 valid-i? :fn31 valid-i? :fn32 valid-i? :fn33 valid-i? :fn34 valid-i? :fn35 valid-i? :fn36 valid-i? :fn37 valid-i? :fn38 valid-i? :fn39 valid-i? :fn40 valid-i? :fn41 valid-i? :fn42 valid-i? :fn43 valid-i? :fn44 valid-i? :fn45 valid-i? :fn46 valid-i? :fn47 valid-i? :fn48 valid-i? :fn49 valid-i? :fn50 valid-i? :fn51 valid-i? :fn52 valid-i? :fn53 valid-i? :fn54 valid-i? :fn55 valid-i? :fn56 valid-i? :fn57 valid-i? :fn58 valid-i? :fn59 valid-i? :fn60 valid-i? :fn61 valid-i? :fn62 valid-i? :fn63 valid-i? :fn64 valid-i? :fn65 valid-i? :fn66 valid-i? :fn67 valid-i? :fn68 valid-i? :fn69 valid-i? :fn70 valid-i? :fn71 valid-i? :fn72 valid-i? :fn73 valid-i? :fn74 valid-i? :fn75 valid-i? :fn76 valid-i? :fn77 valid-i? :fn78 valid-i? :fn79 valid-i? :fn80 valid-i? :fn81 valid-i? :fn82 valid-i? :fn83 valid-i? :fn84 valid-i? :fn85 valid-i? :fn86 valid-i? :fn87 valid-i? :fn88 valid-i? :fn89 valid-i? :fn90 valid-i? :fn91 valid-i? :fn92 valid-i? :fn93 valid-i? :fn94 valid-i? :fn95 valid-i? :fn96 valid-i? :fn97 valid-i? :fn98 valid-i? :fn99 valid-i? :fn100 valid-i? :fn101 valid-i? :fn102 valid-i? :fn103 valid-i? :fn104 valid-i? :fn105 valid-i? :fn106 valid-i? :fn107 valid-i? :fn108 valid-i? :fn109 valid-i? :fn110 valid-i? :fn111 valid-i? :fn112 valid-i? :fn113 valid-i? :fn114 valid-i? :fn115 valid-i? :fn116 valid-i? :fn117 valid-i? :fn118 valid-i? :fn119 valid-i? :fn120 valid-i? :fn121 valid-i? :fn122 valid-i? :fn123 valid-i? :fn124 valid-i? :fn125 valid-i? :fn126 valid-i? :fn127 valid-i? :fn128 valid-i? :fn129 valid-i? :fn130 valid-i? :fn131 valid-i? :fn132 valid-i? :fn133 valid-i? :fn134 valid-i? :fn135 valid-i? :fn136 valid-i? :fn137 valid-i? :fn138 valid-i? :fn139 valid-i? :fn140 valid-i? :fn141 valid-i? :fn142 valid-i? :fn143 valid-i? :fn144 valid-i? :fn145 valid-i? :fn146 valid-i? :fn147 valid-i? :fn148 valid-i? :fn149 valid-i? :fn150 valid-i? :fn151 valid-i? :fn152 valid-i? :fn153 valid-i? :fn154 valid-i? :fn155 valid-i? :fn156 valid-i? :fn157 valid-i? :fn158 valid-i? :fn159 valid-i? :fn160 valid-i? :fn161 valid-i? )
         ))
(stest/instrument `s32b14)

(defn maxabs
  {:arglists '([ain1 & ain1* ain2* ain3* ain4* ain5* ain6* ain7* ain8* ain9* ain10* ain11* ain12* ain13* ain14* ain15* ain16* ain17* ain18* ain19* ain20* ain21* ain22* ain23* ain24* ain25* ain26* ain27* ain28* ain29* ain30* ain31* ain32*] [kin1 & kin1* kin2* kin3* kin4* kin5* kin6* kin7* kin8* kin9* kin10* kin11* kin12* kin13* kin14* kin15* kin16*])}
  [in1 & [ in1* in2* in3* in4* in5* in6* in7* in8* in9* in10* in11* in12* in13* in14* in15* in16* in17* in18* in19* in20* in21* in22* in23* in24* in25* in26* in27* in28* in29* in30* in31* in32* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "maxabs"
                      [in1 in1* in2* in3* in4* in5* in6* in7* in8* in9* in10* in11* in12* in13* in14* in15* in16* in17* in18* in19* in20* in21* in22* in23* in24* in25* in26* in27* in28* in29* in30* in31* in32*]
                      *global*)]
    (new out-types ast)))

(s/fdef maxabs
  :args (s/alt
         :kkkkkkkkkkkkkkkkk (s/cat :in1 valid-kr? :in1* (s/? valid-kr?*) :in2* (s/? valid-kr?*) :in3* (s/? valid-kr?*) :in4* (s/? valid-kr?*) :in5* (s/? valid-kr?*) :in6* (s/? valid-kr?*) :in7* (s/? valid-kr?*) :in8* (s/? valid-kr?*) :in9* (s/? valid-kr?*) :in10* (s/? valid-kr?*) :in11* (s/? valid-kr?*) :in12* (s/? valid-kr?*) :in13* (s/? valid-kr?*) :in14* (s/? valid-kr?*) :in15* (s/? valid-kr?*) :in16* (s/? valid-kr?*) )
         :aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa (s/cat :in1 valid-ar? :in1* (s/? valid-ar?*) :in2* (s/? valid-ar?*) :in3* (s/? valid-ar?*) :in4* (s/? valid-ar?*) :in5* (s/? valid-ar?*) :in6* (s/? valid-ar?*) :in7* (s/? valid-ar?*) :in8* (s/? valid-ar?*) :in9* (s/? valid-ar?*) :in10* (s/? valid-ar?*) :in11* (s/? valid-ar?*) :in12* (s/? valid-ar?*) :in13* (s/? valid-ar?*) :in14* (s/? valid-ar?*) :in15* (s/? valid-ar?*) :in16* (s/? valid-ar?*) :in17* (s/? valid-ar?*) :in18* (s/? valid-ar?*) :in19* (s/? valid-ar?*) :in20* (s/? valid-ar?*) :in21* (s/? valid-ar?*) :in22* (s/? valid-ar?*) :in23* (s/? valid-ar?*) :in24* (s/? valid-ar?*) :in25* (s/? valid-ar?*) :in26* (s/? valid-ar?*) :in27* (s/? valid-ar?*) :in28* (s/? valid-ar?*) :in29* (s/? valid-ar?*) :in30* (s/? valid-ar?*) :in31* (s/? valid-ar?*) :in32* (s/? valid-ar?*) )
         ))
(stest/instrument `maxabs)

(defn maxabs:a
  {:arglists '([ain1 & ain1* ain2* ain3* ain4* ain5* ain6* ain7* ain8* ain9* ain10* ain11* ain12* ain13* ain14* ain15* ain16* ain17* ain18* ain19* ain20* ain21* ain22* ain23* ain24* ain25* ain26* ain27* ain28* ain29* ain30* ain31* ain32*])}
  [in1 & [ in1* in2* in3* in4* in5* in6* in7* in8* in9* in10* in11* in12* in13* in14* in15* in16* in17* in18* in19* in20* in21* in22* in23* in24* in25* in26* in27* in28* in29* in30* in31* in32* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "maxabs"
                      [in1 in1* in2* in3* in4* in5* in6* in7* in8* in9* in10* in11* in12* in13* in14* in15* in16* in17* in18* in19* in20* in21* in22* in23* in24* in25* in26* in27* in28* in29* in30* in31* in32*]
                      *global*)]
    (new out-types ast)))

(s/fdef maxabs:a
  :args (s/cat :in1 valid-ar? :in1* (s/? valid-ar?*) :in2* (s/? valid-ar?*) :in3* (s/? valid-ar?*) :in4* (s/? valid-ar?*) :in5* (s/? valid-ar?*) :in6* (s/? valid-ar?*) :in7* (s/? valid-ar?*) :in8* (s/? valid-ar?*) :in9* (s/? valid-ar?*) :in10* (s/? valid-ar?*) :in11* (s/? valid-ar?*) :in12* (s/? valid-ar?*) :in13* (s/? valid-ar?*) :in14* (s/? valid-ar?*) :in15* (s/? valid-ar?*) :in16* (s/? valid-ar?*) :in17* (s/? valid-ar?*) :in18* (s/? valid-ar?*) :in19* (s/? valid-ar?*) :in20* (s/? valid-ar?*) :in21* (s/? valid-ar?*) :in22* (s/? valid-ar?*) :in23* (s/? valid-ar?*) :in24* (s/? valid-ar?*) :in25* (s/? valid-ar?*) :in26* (s/? valid-ar?*) :in27* (s/? valid-ar?*) :in28* (s/? valid-ar?*) :in29* (s/? valid-ar?*) :in30* (s/? valid-ar?*) :in31* (s/? valid-ar?*) :in32* (s/? valid-ar?*) ))
(stest/instrument `maxabs:a)

(defn maxabs:k
  {:arglists '([kin1 & kin1* kin2* kin3* kin4* kin5* kin6* kin7* kin8* kin9* kin10* kin11* kin12* kin13* kin14* kin15* kin16*])}
  [in1 & [ in1* in2* in3* in4* in5* in6* in7* in8* in9* in10* in11* in12* in13* in14* in15* in16* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "maxabs"
                      [in1 in1* in2* in3* in4* in5* in6* in7* in8* in9* in10* in11* in12* in13* in14* in15* in16*]
                      *global*)]
    (new out-types ast)))

(s/fdef maxabs:k
  :args (s/cat :in1 valid-kr? :in1* (s/? valid-kr?*) :in2* (s/? valid-kr?*) :in3* (s/? valid-kr?*) :in4* (s/? valid-kr?*) :in5* (s/? valid-kr?*) :in6* (s/? valid-kr?*) :in7* (s/? valid-kr?*) :in8* (s/? valid-kr?*) :in9* (s/? valid-kr?*) :in10* (s/? valid-kr?*) :in11* (s/? valid-kr?*) :in12* (s/? valid-kr?*) :in13* (s/? valid-kr?*) :in14* (s/? valid-kr?*) :in15* (s/? valid-kr?*) :in16* (s/? valid-kr?*) ))
(stest/instrument `maxabs:k)

(defn timeinsts
  {:arglists '()}
  []
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "timeinsts"
                      []
                      *global*)]
    (new out-types ast)))


(defn outq
  {:arglists '([& asig1* asig2* asig3* asig4* asig5* asig6* asig7* asig8* asig9* asig10* asig11* asig12* asig13* asig14* asig15* asig16* asig17* asig18* asig19* asig20* asig21* asig22* asig23* asig24* asig25* asig26* asig27* asig28* asig29* asig30* asig31* asig32*])}
  [& [ sig1* sig2* sig3* sig4* sig5* sig6* sig7* sig8* sig9* sig10* sig11* sig12* sig13* sig14* sig15* sig16* sig17* sig18* sig19* sig20* sig21* sig22* sig23* sig24* sig25* sig26* sig27* sig28* sig29* sig30* sig31* sig32* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outq"
                      [sig1* sig2* sig3* sig4* sig5* sig6* sig7* sig8* sig9* sig10* sig11* sig12* sig13* sig14* sig15* sig16* sig17* sig18* sig19* sig20* sig21* sig22* sig23* sig24* sig25* sig26* sig27* sig28* sig29* sig30* sig31* sig32*]
                      *global*)]
    (new out-types ast)))

(s/fdef outq
  :args (s/cat :sig1* (s/? valid-ar?*) :sig2* (s/? valid-ar?*) :sig3* (s/? valid-ar?*) :sig4* (s/? valid-ar?*) :sig5* (s/? valid-ar?*) :sig6* (s/? valid-ar?*) :sig7* (s/? valid-ar?*) :sig8* (s/? valid-ar?*) :sig9* (s/? valid-ar?*) :sig10* (s/? valid-ar?*) :sig11* (s/? valid-ar?*) :sig12* (s/? valid-ar?*) :sig13* (s/? valid-ar?*) :sig14* (s/? valid-ar?*) :sig15* (s/? valid-ar?*) :sig16* (s/? valid-ar?*) :sig17* (s/? valid-ar?*) :sig18* (s/? valid-ar?*) :sig19* (s/? valid-ar?*) :sig20* (s/? valid-ar?*) :sig21* (s/? valid-ar?*) :sig22* (s/? valid-ar?*) :sig23* (s/? valid-ar?*) :sig24* (s/? valid-ar?*) :sig25* (s/? valid-ar?*) :sig26* (s/? valid-ar?*) :sig27* (s/? valid-ar?*) :sig28* (s/? valid-ar?*) :sig29* (s/? valid-ar?*) :sig30* (s/? valid-ar?*) :sig31* (s/? valid-ar?*) :sig32* (s/? valid-ar?*) ))
(stest/instrument `outq)

(defn lpread
  {:arglists '([ktimpnt Sfilcod & inpoles* ifrmrate*] [ktimpnt ifilcod & inpoles* ifrmrate*])}
  [timpnt filcod & [ npoles* frmrate* ]]
  (let [out-types-quoted '[ControlSignal ControlSignal ControlSignal ControlSignal]
        out-types [ControlSignal ControlSignal ControlSignal ControlSignal]
        ast (ast-node out-types-quoted
                      "lpread"
                      [timpnt filcod npoles* frmrate*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef lpread
  :args (s/alt
         :kiii (s/cat :timpnt valid-kr? :filcod valid-i? :npoles* (s/? valid-i?*) :frmrate* (s/? valid-i?*) )
         :kSii (s/cat :timpnt valid-kr? :filcod valid-S? :npoles* (s/? valid-i?*) :frmrate* (s/? valid-i?*) )
         ))
(stest/instrument `lpread)

(defn strtod
  {:arglists '([Sindex] [iindex])}
  [index]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "strtod"
                      [index]
                      *global*)]
    (new out-types ast)))

(s/fdef strtod
  :args (s/alt
         :i (s/cat :index valid-i? )
         :S (s/cat :index valid-S? )
         ))
(stest/instrument `strtod)

(defn ziw
  {:arglists '([isig iindex])}
  [sig index]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "ziw"
                      [sig index]
                      *global*)]
    (new out-types ast)))

(s/fdef ziw
  :args (s/cat :sig valid-i? :index valid-i? ))
(stest/instrument `ziw)

(defn sprintf
  {:arglists '([Sformatstring & xarg1* xarg2* xarg3* xarg4* xarg5* xarg6* xarg7* xarg8* xarg9* xarg10* xarg11* xarg12* xarg13* xarg14* xarg15* xarg16*])}
  [formatstring & [ arg1* arg2* arg3* arg4* arg5* arg6* arg7* arg8* arg9* arg10* arg11* arg12* arg13* arg14* arg15* arg16* ]]
  (let [out-types-quoted 'String
        out-types String
        ast (ast-node out-types-quoted
                      "sprintf"
                      [formatstring arg1* arg2* arg3* arg4* arg5* arg6* arg7* arg8* arg9* arg10* arg11* arg12* arg13* arg14* arg15* arg16*]
                      *global*)]
    (new out-types ast)))

(s/fdef sprintf
  :args (s/cat :formatstring valid-S? :arg1* (s/? valid-x?*) :arg2* (s/? valid-x?*) :arg3* (s/? valid-x?*) :arg4* (s/? valid-x?*) :arg5* (s/? valid-x?*) :arg6* (s/? valid-x?*) :arg7* (s/? valid-x?*) :arg8* (s/? valid-x?*) :arg9* (s/? valid-x?*) :arg10* (s/? valid-x?*) :arg11* (s/? valid-x?*) :arg12* (s/? valid-x?*) :arg13* (s/? valid-x?*) :arg14* (s/? valid-x?*) :arg15* (s/? valid-x?*) :arg16* (s/? valid-x?*) ))
(stest/instrument `sprintf)

(defn rifft
  {:arglists '([iinArr] [kinArr])}
  [in]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "rifft"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef rifft
  :args (s/alt
         :kArr (s/cat :in valid-kArr? )
         :iArr (s/cat :in valid-iArr? )
         ))
(stest/instrument `rifft)

(defn rifft:iArr
  {:arglists '([iinArr])}
  [in]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "rifft"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef rifft:iArr
  :args (s/cat :in valid-iArr? ))
(stest/instrument `rifft:iArr)

(defn rifft:kArr
  {:arglists '([kinArr])}
  [in]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "rifft"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef rifft:kArr
  :args (s/cat :in valid-kArr? ))
(stest/instrument `rifft:kArr)

(defn vwrap
  {:arglists '([itable kmin kmax ielements])}
  [table min max elements]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vwrap"
                      [table min max elements]
                      *global*)]
    (new out-types ast)))

(s/fdef vwrap
  :args (s/cat :table valid-i? :min valid-kr? :max valid-kr? :elements valid-i? ))
(stest/instrument `vwrap)

(defn strfromurl
  {:arglists '([StringURL])}
  [tringURL]
  (let [out-types-quoted 'String
        out-types String
        ast (ast-node out-types-quoted
                      "strfromurl"
                      [tringURL]
                      *global*)]
    (new out-types ast)))

(s/fdef strfromurl
  :args (s/cat :tringURL valid-S? ))
(stest/instrument `strfromurl)

(defn vtablewa
  {:arglists '([aindex ktable ixmode & ainarg1* ainarg2* ainarg3* ainargN4* ainargN5* ainargN6* ainargN7* ainargN8* ainargN9* ainargN10* ainargN11* ainargN12* ainargN13* ainargN14* ainargN15* ainargN16* ainargN17* ainargN18* ainargN19* ainargN20* ainargN21* ainargN22* ainargN23* ainargN24* ainargN25* ainargN26* ainargN27* ainargN28* ainargN29* ainargN30* ainargN31* ainargN32*])}
  [index table xmode & [ inarg1* inarg2* inarg3* inargN4* inargN5* inargN6* inargN7* inargN8* inargN9* inargN10* inargN11* inargN12* inargN13* inargN14* inargN15* inargN16* inargN17* inargN18* inargN19* inargN20* inargN21* inargN22* inargN23* inargN24* inargN25* inargN26* inargN27* inargN28* inargN29* inargN30* inargN31* inargN32* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vtablewa"
                      [index table xmode inarg1* inarg2* inarg3* inargN4* inargN5* inargN6* inargN7* inargN8* inargN9* inargN10* inargN11* inargN12* inargN13* inargN14* inargN15* inargN16* inargN17* inargN18* inargN19* inargN20* inargN21* inargN22* inargN23* inargN24* inargN25* inargN26* inargN27* inargN28* inargN29* inargN30* inargN31* inargN32*]
                      *global*)]
    (new out-types ast)))

(s/fdef vtablewa
  :args (s/cat :index valid-ar? :table valid-kr? :xmode valid-i? :inarg1* (s/? valid-ar?*) :inarg2* (s/? valid-ar?*) :inarg3* (s/? valid-ar?*) :inargN4* (s/? valid-ar?*) :inargN5* (s/? valid-ar?*) :inargN6* (s/? valid-ar?*) :inargN7* (s/? valid-ar?*) :inargN8* (s/? valid-ar?*) :inargN9* (s/? valid-ar?*) :inargN10* (s/? valid-ar?*) :inargN11* (s/? valid-ar?*) :inargN12* (s/? valid-ar?*) :inargN13* (s/? valid-ar?*) :inargN14* (s/? valid-ar?*) :inargN15* (s/? valid-ar?*) :inargN16* (s/? valid-ar?*) :inargN17* (s/? valid-ar?*) :inargN18* (s/? valid-ar?*) :inargN19* (s/? valid-ar?*) :inargN20* (s/? valid-ar?*) :inargN21* (s/? valid-ar?*) :inargN22* (s/? valid-ar?*) :inargN23* (s/? valid-ar?*) :inargN24* (s/? valid-ar?*) :inargN25* (s/? valid-ar?*) :inargN26* (s/? valid-ar?*) :inargN27* (s/? valid-ar?*) :inargN28* (s/? valid-ar?*) :inargN29* (s/? valid-ar?*) :inargN30* (s/? valid-ar?*) :inargN31* (s/? valid-ar?*) :inargN32* (s/? valid-ar?*) ))
(stest/instrument `vtablewa)

(defn sfplaym
  {:arglists '([ivel inotenum xamp xfreq ipreindex & iflag* ioffset* ienv*])}
  [vel notenum amp freq preindex & [ flag* offset* env* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "sfplaym"
                      [vel notenum amp freq preindex flag* offset* env*]
                      *global*)]
    (new out-types ast)))

(s/fdef sfplaym
  :args (s/cat :vel valid-i? :notenum valid-i? :amp valid-x? :freq valid-x? :preindex valid-i? :flag* (s/? valid-i?*) :offset* (s/? valid-i?*) :env* (s/? valid-i?*) ))
(stest/instrument `sfplaym)

(defn OSCinit
  {:arglists '([iport])}
  [port]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "OSCinit"
                      [port]
                      *global*)]
    (new out-types ast)))

(s/fdef OSCinit
  :args (s/cat :port valid-i? ))
(stest/instrument `OSCinit)

(defn sc_trig
  {:arglists '([ain kdur] [kin kdur])}
  [in dur]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "sc_trig"
                      [in dur]
                      *global*)]
    (new out-types ast)))

(s/fdef sc_trig
  :args (s/alt
         :kk (s/cat :in valid-kr? :dur valid-kr? )
         :ak (s/cat :in valid-ar? :dur valid-kr? )
         ))
(stest/instrument `sc_trig)

(defn sc_trig:a
  {:arglists '([ain kdur])}
  [in dur]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "sc_trig"
                      [in dur]
                      *global*)]
    (new out-types ast)))

(s/fdef sc_trig:a
  :args (s/cat :in valid-ar? :dur valid-kr? ))
(stest/instrument `sc_trig:a)

(defn sc_trig:k
  {:arglists '([kin kdur])}
  [in dur]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "sc_trig"
                      [in dur]
                      *global*)]
    (new out-types ast)))

(s/fdef sc_trig:k
  :args (s/cat :in valid-kr? :dur valid-kr? ))
(stest/instrument `sc_trig:k)

(defn gbuzz
  {:arglists '([xamp xcps knh klh kmul itable & iphase*])}
  [amp cps nh lh mul table & [ phase* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "gbuzz"
                      [amp cps nh lh mul table phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef gbuzz
  :args (s/cat :amp valid-x? :cps valid-x? :nh valid-kr? :lh valid-kr? :mul valid-kr? :table valid-i? :phase* (s/? valid-i?*) ))
(stest/instrument `gbuzz)

(defn readscratch
  {:arglists '([& index*])}
  [& [ ndex* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "readscratch"
                      [ndex*]
                      *global*)]
    (new out-types ast)))

(s/fdef readscratch
  :args (s/cat :ndex* (s/? valid-i?*) ))
(stest/instrument `readscratch)

(defn outipc
  {:arglists '([ichn iprog imin imax])}
  [chn prog min max]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outipc"
                      [chn prog min max]
                      *global*)]
    (new out-types ast)))

(s/fdef outipc
  :args (s/cat :chn valid-i? :prog valid-i? :min valid-i? :max valid-i? ))
(stest/instrument `outipc)

(defn diskin2
  {:arglists '([Sfilcod & kpitch* iskiptim* iwrap* iformat* iwsize* ibufsize* iskipinit* iskipinit*] [ifilcod & kpitch* iskiptim* iwrap* iformat* iwsize* ibufsize* iskipinit* iskipinit*] [Sfilcod & kpitch* iskiptim* iwrap* iformat* iwsize* ibufsize* iskipinit* iskipinit*] [ifilcod & kpitch* iskiptim* iwrap* iformat* iwsize* ibufsize* iskipinit* iskipinit*])}
  [filcod & [ pitch* skiptim* wrap* format* wsize* bufsize* skipinit* skipinit* ]]
  (let [out-types-quoted 'AudioArray
        out-types AudioArray
        ast (ast-node out-types-quoted
                      "diskin2"
                      [filcod pitch* skiptim* wrap* format* wsize* bufsize* skipinit* skipinit*]
                      *global*)]
    (new out-types ast)))

(s/fdef diskin2
  :args (s/alt
         :ikiiiiiii (s/cat :filcod valid-i? :pitch* (s/? valid-kr?*) :skiptim* (s/? valid-i?*) :wrap* (s/? valid-i?*) :format* (s/? valid-i?*) :wsize* (s/? valid-i?*) :bufsize* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :skipinit* (s/? valid-i?*) )
         :Skiiiiiii (s/cat :filcod valid-S? :pitch* (s/? valid-kr?*) :skiptim* (s/? valid-i?*) :wrap* (s/? valid-i?*) :format* (s/? valid-i?*) :wsize* (s/? valid-i?*) :bufsize* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :skipinit* (s/? valid-i?*) )
         ))
(stest/instrument `diskin2)

(defn diskin2:aArr
  {:arglists '([Sfilcod & kpitch* iskiptim* iwrap* iformat* iwsize* ibufsize* iskipinit* iskipinit*] [ifilcod & kpitch* iskiptim* iwrap* iformat* iwsize* ibufsize* iskipinit* iskipinit*])}
  [filcod & [ pitch* skiptim* wrap* format* wsize* bufsize* skipinit* skipinit* ]]
  (let [out-types-quoted 'AudioArray
        out-types AudioArray
        ast (ast-node out-types-quoted
                      "diskin2"
                      [filcod pitch* skiptim* wrap* format* wsize* bufsize* skipinit* skipinit*]
                      *global*)]
    (new out-types ast)))

(s/fdef diskin2:aArr
  :args (s/alt
         :ikiiiiiii (s/cat :filcod valid-i? :pitch* (s/? valid-kr?*) :skiptim* (s/? valid-i?*) :wrap* (s/? valid-i?*) :format* (s/? valid-i?*) :wsize* (s/? valid-i?*) :bufsize* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :skipinit* (s/? valid-i?*) )
         :Skiiiiiii (s/cat :filcod valid-S? :pitch* (s/? valid-kr?*) :skiptim* (s/? valid-i?*) :wrap* (s/? valid-i?*) :format* (s/? valid-i?*) :wsize* (s/? valid-i?*) :bufsize* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :skipinit* (s/? valid-i?*) )
         ))
(stest/instrument `diskin2:aArr)

(defn diskin2:a
  {:arglists '([Sfilcod & kpitch* iskiptim* iwrap* iformat* iwsize* ibufsize* iskipinit* iskipinit*] [ifilcod & kpitch* iskiptim* iwrap* iformat* iwsize* ibufsize* iskipinit* iskipinit*])}
  [filcod & [ pitch* skiptim* wrap* format* wsize* bufsize* skipinit* skipinit* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "diskin2"
                      [filcod pitch* skiptim* wrap* format* wsize* bufsize* skipinit* skipinit*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef diskin2:a
  :args (s/alt
         :ikiiiiiii (s/cat :filcod valid-i? :pitch* (s/? valid-kr?*) :skiptim* (s/? valid-i?*) :wrap* (s/? valid-i?*) :format* (s/? valid-i?*) :wsize* (s/? valid-i?*) :bufsize* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :skipinit* (s/? valid-i?*) )
         :Skiiiiiii (s/cat :filcod valid-S? :pitch* (s/? valid-kr?*) :skiptim* (s/? valid-i?*) :wrap* (s/? valid-i?*) :format* (s/? valid-i?*) :wsize* (s/? valid-i?*) :bufsize* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :skipinit* (s/? valid-i?*) )
         ))
(stest/instrument `diskin2:a)

(defn inz
  {:arglists '([ksig1])}
  [sig1]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "inz"
                      [sig1]
                      *global*)]
    (new out-types ast)))

(s/fdef inz
  :args (s/cat :sig1 valid-kr? ))
(stest/instrument `inz)

(defn clockoff
  {:arglists '([inum])}
  [num]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "clockoff"
                      [num]
                      *global*)]
    (new out-types ast)))

(s/fdef clockoff
  :args (s/cat :num valid-i? ))
(stest/instrument `clockoff)

(defn zacl
  {:arglists '([kfirst klast])}
  [first last]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "zacl"
                      [first last]
                      *global*)]
    (new out-types ast)))

(s/fdef zacl
  :args (s/cat :first valid-kr? :last valid-kr? ))
(stest/instrument `zacl)

(defn cpsmidib
  {:arglists '([& irange*] [& irange*])}
  [& [ range* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "cpsmidib"
                      [range*]
                      *global*)]
    (new out-types ast)))

(s/fdef cpsmidib
  :args (s/alt
         :i (s/cat :range* (s/? valid-i?*) )
         ))
(stest/instrument `cpsmidib)

(defn cpsmidib:i
  {:arglists '([& irange*])}
  [& [ range* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "cpsmidib"
                      [range*]
                      *global*)]
    (new out-types ast)))

(s/fdef cpsmidib:i
  :args (s/cat :range* (s/? valid-i?*) ))
(stest/instrument `cpsmidib:i)

(defn cpsmidib:k
  {:arglists '([& irange*])}
  [& [ range* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "cpsmidib"
                      [range*]
                      *global*)]
    (new out-types ast)))

(s/fdef cpsmidib:k
  :args (s/cat :range* (s/? valid-i?*) ))
(stest/instrument `cpsmidib:k)

(defn spat3di
  {:arglists '([ain iX iY iZ idistortion ift imode & istor*])}
  [in X Y Z distortion ft mode & [ stor* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "spat3di"
                      [in X Y Z distortion ft mode stor*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef spat3di
  :args (s/cat :in valid-ar? :X valid-i? :Y valid-i? :Z valid-i? :distortion valid-i? :ft valid-i? :mode valid-i? :stor* (s/? valid-i?*) ))
(stest/instrument `spat3di)

(defn inletv
  {:arglists '([Sname])}
  [name]
  (let [out-types-quoted 'AudioArray
        out-types AudioArray
        ast (ast-node out-types-quoted
                      "inletv"
                      [name]
                      *global*)]
    (new out-types ast)))

(s/fdef inletv
  :args (s/cat :name valid-S? ))
(stest/instrument `inletv)

(defn filter2
  {:arglists '([asig iM iN & ib1* ib2* ibM3* ia4* ia5* iaN6* iaN7* iaN8* iaN9* iaN10* iaN11* iaN12* iaN13* iaN14* iaN15* iaN16*] [ksig iM iN & ib1* ib2* ibM3* ia4* ia5* iaN6* iaN7* iaN8* iaN9* iaN10* iaN11* iaN12* iaN13* iaN14* iaN15* iaN16*])}
  [sig M N & [ b1* b2* bM3* a4* a5* aN6* aN7* aN8* aN9* aN10* aN11* aN12* aN13* aN14* aN15* aN16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "filter2"
                      [sig M N b1* b2* bM3* a4* a5* aN6* aN7* aN8* aN9* aN10* aN11* aN12* aN13* aN14* aN15* aN16*]
                      *global*)]
    (new out-types ast)))

(s/fdef filter2
  :args (s/alt
         :kiiiiiiiiiiiiiiiiii (s/cat :sig valid-kr? :M valid-i? :N valid-i? :b1* (s/? valid-i?*) :b2* (s/? valid-i?*) :bM3* (s/? valid-i?*) :a4* (s/? valid-i?*) :a5* (s/? valid-i?*) :aN6* (s/? valid-i?*) :aN7* (s/? valid-i?*) :aN8* (s/? valid-i?*) :aN9* (s/? valid-i?*) :aN10* (s/? valid-i?*) :aN11* (s/? valid-i?*) :aN12* (s/? valid-i?*) :aN13* (s/? valid-i?*) :aN14* (s/? valid-i?*) :aN15* (s/? valid-i?*) :aN16* (s/? valid-i?*) )
         :aiiiiiiiiiiiiiiiiii (s/cat :sig valid-ar? :M valid-i? :N valid-i? :b1* (s/? valid-i?*) :b2* (s/? valid-i?*) :bM3* (s/? valid-i?*) :a4* (s/? valid-i?*) :a5* (s/? valid-i?*) :aN6* (s/? valid-i?*) :aN7* (s/? valid-i?*) :aN8* (s/? valid-i?*) :aN9* (s/? valid-i?*) :aN10* (s/? valid-i?*) :aN11* (s/? valid-i?*) :aN12* (s/? valid-i?*) :aN13* (s/? valid-i?*) :aN14* (s/? valid-i?*) :aN15* (s/? valid-i?*) :aN16* (s/? valid-i?*) )
         ))
(stest/instrument `filter2)

(defn filter2:a
  {:arglists '([asig iM iN & ib1* ib2* ibM3* ia4* ia5* iaN6* iaN7* iaN8* iaN9* iaN10* iaN11* iaN12* iaN13* iaN14* iaN15* iaN16*])}
  [sig M N & [ b1* b2* bM3* a4* a5* aN6* aN7* aN8* aN9* aN10* aN11* aN12* aN13* aN14* aN15* aN16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "filter2"
                      [sig M N b1* b2* bM3* a4* a5* aN6* aN7* aN8* aN9* aN10* aN11* aN12* aN13* aN14* aN15* aN16*]
                      *global*)]
    (new out-types ast)))

(s/fdef filter2:a
  :args (s/cat :sig valid-ar? :M valid-i? :N valid-i? :b1* (s/? valid-i?*) :b2* (s/? valid-i?*) :bM3* (s/? valid-i?*) :a4* (s/? valid-i?*) :a5* (s/? valid-i?*) :aN6* (s/? valid-i?*) :aN7* (s/? valid-i?*) :aN8* (s/? valid-i?*) :aN9* (s/? valid-i?*) :aN10* (s/? valid-i?*) :aN11* (s/? valid-i?*) :aN12* (s/? valid-i?*) :aN13* (s/? valid-i?*) :aN14* (s/? valid-i?*) :aN15* (s/? valid-i?*) :aN16* (s/? valid-i?*) ))
(stest/instrument `filter2:a)

(defn filter2:k
  {:arglists '([ksig iM iN & ib1* ib2* ibM3* ia4* ia5* iaN6* iaN7* iaN8* iaN9* iaN10* iaN11* iaN12* iaN13* iaN14* iaN15* iaN16*])}
  [sig M N & [ b1* b2* bM3* a4* a5* aN6* aN7* aN8* aN9* aN10* aN11* aN12* aN13* aN14* aN15* aN16* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "filter2"
                      [sig M N b1* b2* bM3* a4* a5* aN6* aN7* aN8* aN9* aN10* aN11* aN12* aN13* aN14* aN15* aN16*]
                      *global*)]
    (new out-types ast)))

(s/fdef filter2:k
  :args (s/cat :sig valid-kr? :M valid-i? :N valid-i? :b1* (s/? valid-i?*) :b2* (s/? valid-i?*) :bM3* (s/? valid-i?*) :a4* (s/? valid-i?*) :a5* (s/? valid-i?*) :aN6* (s/? valid-i?*) :aN7* (s/? valid-i?*) :aN8* (s/? valid-i?*) :aN9* (s/? valid-i?*) :aN10* (s/? valid-i?*) :aN11* (s/? valid-i?*) :aN12* (s/? valid-i?*) :aN13* (s/? valid-i?*) :aN14* (s/? valid-i?*) :aN15* (s/? valid-i?*) :aN16* (s/? valid-i?*) ))
(stest/instrument `filter2:k)

(defn vcopy_i
  {:arglists '([ifn1 ifn2 ielements & idstoffset* isrcoffset*])}
  [fn1 fn2 elements & [ dstoffset* srcoffset* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vcopy_i"
                      [fn1 fn2 elements dstoffset* srcoffset*]
                      *global*)]
    (new out-types ast)))

(s/fdef vcopy_i
  :args (s/cat :fn1 valid-i? :fn2 valid-i? :elements valid-i? :dstoffset* (s/? valid-i?*) :srcoffset* (s/? valid-i?*) ))
(stest/instrument `vcopy_i)

(defn wgbow
  {:arglists '([kamp kfreq kpres krat kvibf kvamp & itable* iminfreq*])}
  [amp freq pres rat vibf vamp & [ table* minfreq* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "wgbow"
                      [amp freq pres rat vibf vamp table* minfreq*]
                      *global*)]
    (new out-types ast)))

(s/fdef wgbow
  :args (s/cat :amp valid-kr? :freq valid-kr? :pres valid-kr? :rat valid-kr? :vibf valid-kr? :vamp valid-kr? :table* (s/? valid-i?*) :minfreq* (s/? valid-i?*) ))
(stest/instrument `wgbow)

(defn linenr
  {:arglists '([aamp irise idec iatdec] [kamp irise idec iatdec] [kamp irise idec iatdec])}
  [amp rise dec atdec]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "linenr"
                      [amp rise dec atdec]
                      *global*)]
    (new out-types ast)))

(s/fdef linenr
  :args (s/alt
         :kiii (s/cat :amp valid-kr? :rise valid-i? :dec valid-i? :atdec valid-i? )
         :aiii (s/cat :amp valid-ar? :rise valid-i? :dec valid-i? :atdec valid-i? )
         ))
(stest/instrument `linenr)

(defn linenr:a
  {:arglists '([aamp irise idec iatdec] [kamp irise idec iatdec])}
  [amp rise dec atdec]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "linenr"
                      [amp rise dec atdec]
                      *global*)]
    (new out-types ast)))

(s/fdef linenr:a
  :args (s/alt
         :kiii (s/cat :amp valid-kr? :rise valid-i? :dec valid-i? :atdec valid-i? )
         :aiii (s/cat :amp valid-ar? :rise valid-i? :dec valid-i? :atdec valid-i? )
         ))
(stest/instrument `linenr:a)

(defn linenr:k
  {:arglists '([kamp irise idec iatdec])}
  [amp rise dec atdec]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "linenr"
                      [amp rise dec atdec]
                      *global*)]
    (new out-types ast)))

(s/fdef linenr:k
  :args (s/cat :amp valid-kr? :rise valid-i? :dec valid-i? :atdec valid-i? ))
(stest/instrument `linenr:k)

(defn clip
  {:arglists '([asig imeth ilimit iarg])}
  [sig meth limit arg]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "clip"
                      [sig meth limit arg]
                      *global*)]
    (new out-types ast)))

(s/fdef clip
  :args (s/cat :sig valid-ar? :meth valid-i? :limit valid-i? :arg valid-i? ))
(stest/instrument `clip)

(defn turnoff2
  {:arglists '([Sinsno kmode krelease] [iinsno kmode krelease] [iinsno kmode krelease] [iinsno kmode krelease] [kinsno kmode krelease])}
  [insno mode release]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "turnoff2"
                      [insno mode release]
                      *global*)]
    (new out-types ast)))

(s/fdef turnoff2
  :args (s/alt
         :kkk (s/cat :insno valid-kr? :mode valid-kr? :release valid-kr? )
         :ikk (s/cat :insno valid-i? :mode valid-kr? :release valid-kr? )
         :Skk (s/cat :insno valid-S? :mode valid-kr? :release valid-kr? )
         ))
(stest/instrument `turnoff2)

(defn taninv2
  {:arglists '([aradian aradian] [iradian iradian] [kradian kradian])}
  [radian radian]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "taninv2"
                      [radian radian]
                      *global*)]
    (new out-types ast)))

(s/fdef taninv2
  :args (s/alt
         :kk (s/cat :radian valid-kr? :radian valid-kr? )
         :ii (s/cat :radian valid-i? :radian valid-i? )
         :aa (s/cat :radian valid-ar? :radian valid-ar? )
         ))
(stest/instrument `taninv2)

(defn taninv2:a
  {:arglists '([aradian aradian])}
  [radian radian]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "taninv2"
                      [radian radian]
                      *global*)]
    (new out-types ast)))

(s/fdef taninv2:a
  :args (s/cat :radian valid-ar? :radian valid-ar? ))
(stest/instrument `taninv2:a)

(defn taninv2:i
  {:arglists '([iradian iradian])}
  [radian radian]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "taninv2"
                      [radian radian]
                      *global*)]
    (new out-types ast)))

(s/fdef taninv2:i
  :args (s/cat :radian valid-i? :radian valid-i? ))
(stest/instrument `taninv2:i)

(defn taninv2:k
  {:arglists '([kradian kradian])}
  [radian radian]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "taninv2"
                      [radian radian]
                      *global*)]
    (new out-types ast)))

(s/fdef taninv2:k
  :args (s/cat :radian valid-kr? :radian valid-kr? ))
(stest/instrument `taninv2:k)

(defn pol2rect
  {:arglists '([kmagsArr] [kmagsArr kphaseArr])}
  [mags]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "pol2rect"
                      [mags]
                      *global*)]
    (new out-types ast)))

(s/fdef pol2rect
  :args (s/alt
         :kArrkArr (s/cat :mags valid-kArr? :phase valid-kArr? )
         :kArr (s/cat :mags valid-kArr? )
         ))
(stest/instrument `pol2rect)

(defn vexp
  {:arglists '([itable kval kelements & kdstoffset* kverbose*])}
  [table val elements & [ dstoffset* verbose* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vexp"
                      [table val elements dstoffset* verbose*]
                      *global*)]
    (new out-types ast)))

(s/fdef vexp
  :args (s/cat :table valid-i? :val valid-kr? :elements valid-kr? :dstoffset* (s/? valid-kr?*) :verbose* (s/? valid-kr?*) ))
(stest/instrument `vexp)

(defn tonex
  {:arglists '([asig ahp & inumlayer* iskip*] [asig khp & inumlayer* iskip*])}
  [sig hp & [ numlayer* skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "tonex"
                      [sig hp numlayer* skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef tonex
  :args (s/alt
         :akii (s/cat :sig valid-ar? :hp valid-kr? :numlayer* (s/? valid-i?*) :skip* (s/? valid-i?*) )
         :aaii (s/cat :sig valid-ar? :hp valid-ar? :numlayer* (s/? valid-i?*) :skip* (s/? valid-i?*) )
         ))
(stest/instrument `tonex)

(defn trmix
  {:arglists '([fin1 fin2])}
  [in1 in2]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "trmix"
                      [in1 in2]
                      *global*)]
    (new out-types ast)))

(s/fdef trmix
  :args (s/cat :in1 valid-f? :in2 valid-f? ))
(stest/instrument `trmix)

(defn inletkid
  {:arglists '([Sname SinstanceID])}
  [name instanceID]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "inletkid"
                      [name instanceID]
                      *global*)]
    (new out-types ast)))

(s/fdef inletkid
  :args (s/cat :name valid-S? :instanceID valid-S? ))
(stest/instrument `inletkid)

(defn cps2pch
  {:arglists '([ipch iequal])}
  [pch equal]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "cps2pch"
                      [pch equal]
                      *global*)]
    (new out-types ast)))

(s/fdef cps2pch
  :args (s/cat :pch valid-i? :equal valid-i? ))
(stest/instrument `cps2pch)

(defn jitter2
  {:arglists '([ktotamp kamp2 kcps3 kamp4 kcps5 kamp6 kcps7 & iopt*])}
  [totamp amp2 cps3 amp4 cps5 amp6 cps7 & [ opt* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "jitter2"
                      [totamp amp2 cps3 amp4 cps5 amp6 cps7 opt*]
                      *global*)]
    (new out-types ast)))

(s/fdef jitter2
  :args (s/cat :totamp valid-kr? :amp2 valid-kr? :cps3 valid-kr? :amp4 valid-kr? :cps5 valid-kr? :amp6 valid-kr? :cps7 valid-kr? :opt* (s/? valid-i?*) ))
(stest/instrument `jitter2)

(defn fog
  {:arglists '([xamp xdens xtrans aspd koct kband kris kdur kdec iolaps ifna ifnb itotdur & iphase* itmode* iskip*])}
  [amp dens trans spd oct band ris dur dec olaps fna fnb totdur & [ phase* tmode* skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "fog"
                      [amp dens trans spd oct band ris dur dec olaps fna fnb totdur phase* tmode* skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef fog
  :args (s/cat :amp valid-x? :dens valid-x? :trans valid-x? :spd valid-ar? :oct valid-kr? :band valid-kr? :ris valid-kr? :dur valid-kr? :dec valid-kr? :olaps valid-i? :fna valid-i? :fnb valid-i? :totdur valid-i? :phase* (s/? valid-i?*) :tmode* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `fog)

(defn inleta
  {:arglists '([Sname])}
  [name]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "inleta"
                      [name]
                      *global*)]
    (new out-types ast)))

(s/fdef inleta
  :args (s/cat :name valid-S? ))
(stest/instrument `inleta)

(defn expsegr
  {:arglists '([ia idur2 & ib1* idur2* ic3* irel4* iz5* iz6* iz7* iz8* iz9* iz10* iz11* iz12* iz13* iz14* iz15* iz16*] [ia idur2 & ib1* idur2* ic3* irel4* iz5* iz6* iz7* iz8* iz9* iz10* iz11* iz12* iz13* iz14* iz15* iz16*])}
  [a dur2 & [ b1* dur2* c3* rel4* z5* z6* z7* z8* z9* z10* z11* z12* z13* z14* z15* z16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "expsegr"
                      [a dur2 b1* dur2* c3* rel4* z5* z6* z7* z8* z9* z10* z11* z12* z13* z14* z15* z16*]
                      *global*)]
    (new out-types ast)))

(s/fdef expsegr
  :args (s/alt
         :iiiiiiiiiiiiiiiiii (s/cat :a valid-i? :dur2 valid-i? :b1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :c3* (s/? valid-i?*) :rel4* (s/? valid-i?*) :z5* (s/? valid-i?*) :z6* (s/? valid-i?*) :z7* (s/? valid-i?*) :z8* (s/? valid-i?*) :z9* (s/? valid-i?*) :z10* (s/? valid-i?*) :z11* (s/? valid-i?*) :z12* (s/? valid-i?*) :z13* (s/? valid-i?*) :z14* (s/? valid-i?*) :z15* (s/? valid-i?*) :z16* (s/? valid-i?*) )
         ))
(stest/instrument `expsegr)

(defn expsegr:a
  {:arglists '([ia idur2 & ib1* idur2* ic3* irel4* iz5* iz6* iz7* iz8* iz9* iz10* iz11* iz12* iz13* iz14* iz15* iz16*])}
  [a dur2 & [ b1* dur2* c3* rel4* z5* z6* z7* z8* z9* z10* z11* z12* z13* z14* z15* z16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "expsegr"
                      [a dur2 b1* dur2* c3* rel4* z5* z6* z7* z8* z9* z10* z11* z12* z13* z14* z15* z16*]
                      *global*)]
    (new out-types ast)))

(s/fdef expsegr:a
  :args (s/cat :a valid-i? :dur2 valid-i? :b1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :c3* (s/? valid-i?*) :rel4* (s/? valid-i?*) :z5* (s/? valid-i?*) :z6* (s/? valid-i?*) :z7* (s/? valid-i?*) :z8* (s/? valid-i?*) :z9* (s/? valid-i?*) :z10* (s/? valid-i?*) :z11* (s/? valid-i?*) :z12* (s/? valid-i?*) :z13* (s/? valid-i?*) :z14* (s/? valid-i?*) :z15* (s/? valid-i?*) :z16* (s/? valid-i?*) ))
(stest/instrument `expsegr:a)

(defn expsegr:k
  {:arglists '([ia idur2 & ib1* idur2* ic3* irel4* iz5* iz6* iz7* iz8* iz9* iz10* iz11* iz12* iz13* iz14* iz15* iz16*])}
  [a dur2 & [ b1* dur2* c3* rel4* z5* z6* z7* z8* z9* z10* z11* z12* z13* z14* z15* z16* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "expsegr"
                      [a dur2 b1* dur2* c3* rel4* z5* z6* z7* z8* z9* z10* z11* z12* z13* z14* z15* z16*]
                      *global*)]
    (new out-types ast)))

(s/fdef expsegr:k
  :args (s/cat :a valid-i? :dur2 valid-i? :b1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :c3* (s/? valid-i?*) :rel4* (s/? valid-i?*) :z5* (s/? valid-i?*) :z6* (s/? valid-i?*) :z7* (s/? valid-i?*) :z8* (s/? valid-i?*) :z9* (s/? valid-i?*) :z10* (s/? valid-i?*) :z11* (s/? valid-i?*) :z12* (s/? valid-i?*) :z13* (s/? valid-i?*) :z14* (s/? valid-i?*) :z15* (s/? valid-i?*) :z16* (s/? valid-i?*) ))
(stest/instrument `expsegr:k)

(defn expsegba
  {:arglists '([ia itim2 & ib1* itim2* ic3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a tim2 & [ b1* tim2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "expsegba"
                      [a tim2 b1* tim2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef expsegba
  :args (s/cat :a valid-i? :tim2 valid-i? :b1* (s/? valid-i?*) :tim2* (s/? valid-i?*) :c3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) ))
(stest/instrument `expsegba)

(defn ftconv
  {:arglists '([ain ift iplen & iskipsamples* iirlen* iskipinit*])}
  [in ft plen & [ skipsamples* irlen* skipinit* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "ftconv"
                      [in ft plen skipsamples* irlen* skipinit*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef ftconv
  :args (s/cat :in valid-ar? :ft valid-i? :plen valid-i? :skipsamples* (s/? valid-i?*) :irlen* (s/? valid-i?*) :skipinit* (s/? valid-i?*) ))
(stest/instrument `ftconv)

(defn printf_i
  {:arglists '([Sformatstring & iarg1* iarg2* iarg3* iarg4* iarg5* iarg6* iarg7* iarg8* iarg9* iarg10* iarg11* iarg12* iarg13* iarg14* iarg15* iarg16*])}
  [formatstring & [ arg1* arg2* arg3* arg4* arg5* arg6* arg7* arg8* arg9* arg10* arg11* arg12* arg13* arg14* arg15* arg16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "printf_i"
                      [formatstring arg1* arg2* arg3* arg4* arg5* arg6* arg7* arg8* arg9* arg10* arg11* arg12* arg13* arg14* arg15* arg16*]
                      *global*)]
    (new out-types ast)))

(s/fdef printf_i
  :args (s/cat :formatstring valid-S? :arg1* (s/? valid-i?*) :arg2* (s/? valid-i?*) :arg3* (s/? valid-i?*) :arg4* (s/? valid-i?*) :arg5* (s/? valid-i?*) :arg6* (s/? valid-i?*) :arg7* (s/? valid-i?*) :arg8* (s/? valid-i?*) :arg9* (s/? valid-i?*) :arg10* (s/? valid-i?*) :arg11* (s/? valid-i?*) :arg12* (s/? valid-i?*) :arg13* (s/? valid-i?*) :arg14* (s/? valid-i?*) :arg15* (s/? valid-i?*) :arg16* (s/? valid-i?*) ))
(stest/instrument `printf_i)

(defn sum
  {:arglists '([& aarr1* aarr2* aarr3* aarr4* aarr5* aarr6* aarr7* aarr8* aarr9* aarr10* aarr11* aarr12* aarr13* aarr14* aarr15* aarr16* aarr17* aarr18* aarr19* aarr20* aarr21* aarr22* aarr23* aarr24* aarr25* aarr26* aarr27* aarr28* aarr29* aarr30* aarr31* aarr32*] [iarrArr] [karrArr])}
  [& [ arr1* arr2* arr3* arr4* arr5* arr6* arr7* arr8* arr9* arr10* arr11* arr12* arr13* arr14* arr15* arr16* arr17* arr18* arr19* arr20* arr21* arr22* arr23* arr24* arr25* arr26* arr27* arr28* arr29* arr30* arr31* arr32* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "sum"
                      [arr1* arr2* arr3* arr4* arr5* arr6* arr7* arr8* arr9* arr10* arr11* arr12* arr13* arr14* arr15* arr16* arr17* arr18* arr19* arr20* arr21* arr22* arr23* arr24* arr25* arr26* arr27* arr28* arr29* arr30* arr31* arr32*]
                      *global*)]
    (new out-types ast)))

(s/fdef sum
  :args (s/alt
         :kArr (s/cat :arr valid-kArr? )
         :iArr (s/cat :arr valid-iArr? )
         :aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa (s/cat :arr1* (s/? valid-ar?*) :arr2* (s/? valid-ar?*) :arr3* (s/? valid-ar?*) :arr4* (s/? valid-ar?*) :arr5* (s/? valid-ar?*) :arr6* (s/? valid-ar?*) :arr7* (s/? valid-ar?*) :arr8* (s/? valid-ar?*) :arr9* (s/? valid-ar?*) :arr10* (s/? valid-ar?*) :arr11* (s/? valid-ar?*) :arr12* (s/? valid-ar?*) :arr13* (s/? valid-ar?*) :arr14* (s/? valid-ar?*) :arr15* (s/? valid-ar?*) :arr16* (s/? valid-ar?*) :arr17* (s/? valid-ar?*) :arr18* (s/? valid-ar?*) :arr19* (s/? valid-ar?*) :arr20* (s/? valid-ar?*) :arr21* (s/? valid-ar?*) :arr22* (s/? valid-ar?*) :arr23* (s/? valid-ar?*) :arr24* (s/? valid-ar?*) :arr25* (s/? valid-ar?*) :arr26* (s/? valid-ar?*) :arr27* (s/? valid-ar?*) :arr28* (s/? valid-ar?*) :arr29* (s/? valid-ar?*) :arr30* (s/? valid-ar?*) :arr31* (s/? valid-ar?*) :arr32* (s/? valid-ar?*) )
         ))
(stest/instrument `sum)

(defn sum:a
  {:arglists '([& aarr1* aarr2* aarr3* aarr4* aarr5* aarr6* aarr7* aarr8* aarr9* aarr10* aarr11* aarr12* aarr13* aarr14* aarr15* aarr16* aarr17* aarr18* aarr19* aarr20* aarr21* aarr22* aarr23* aarr24* aarr25* aarr26* aarr27* aarr28* aarr29* aarr30* aarr31* aarr32*])}
  [& [ arr1* arr2* arr3* arr4* arr5* arr6* arr7* arr8* arr9* arr10* arr11* arr12* arr13* arr14* arr15* arr16* arr17* arr18* arr19* arr20* arr21* arr22* arr23* arr24* arr25* arr26* arr27* arr28* arr29* arr30* arr31* arr32* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "sum"
                      [arr1* arr2* arr3* arr4* arr5* arr6* arr7* arr8* arr9* arr10* arr11* arr12* arr13* arr14* arr15* arr16* arr17* arr18* arr19* arr20* arr21* arr22* arr23* arr24* arr25* arr26* arr27* arr28* arr29* arr30* arr31* arr32*]
                      *global*)]
    (new out-types ast)))

(s/fdef sum:a
  :args (s/cat :arr1* (s/? valid-ar?*) :arr2* (s/? valid-ar?*) :arr3* (s/? valid-ar?*) :arr4* (s/? valid-ar?*) :arr5* (s/? valid-ar?*) :arr6* (s/? valid-ar?*) :arr7* (s/? valid-ar?*) :arr8* (s/? valid-ar?*) :arr9* (s/? valid-ar?*) :arr10* (s/? valid-ar?*) :arr11* (s/? valid-ar?*) :arr12* (s/? valid-ar?*) :arr13* (s/? valid-ar?*) :arr14* (s/? valid-ar?*) :arr15* (s/? valid-ar?*) :arr16* (s/? valid-ar?*) :arr17* (s/? valid-ar?*) :arr18* (s/? valid-ar?*) :arr19* (s/? valid-ar?*) :arr20* (s/? valid-ar?*) :arr21* (s/? valid-ar?*) :arr22* (s/? valid-ar?*) :arr23* (s/? valid-ar?*) :arr24* (s/? valid-ar?*) :arr25* (s/? valid-ar?*) :arr26* (s/? valid-ar?*) :arr27* (s/? valid-ar?*) :arr28* (s/? valid-ar?*) :arr29* (s/? valid-ar?*) :arr30* (s/? valid-ar?*) :arr31* (s/? valid-ar?*) :arr32* (s/? valid-ar?*) ))
(stest/instrument `sum:a)

(defn sum:i
  {:arglists '([iarrArr])}
  [arr]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "sum"
                      [arr]
                      *global*)]
    (new out-types ast)))

(s/fdef sum:i
  :args (s/cat :arr valid-iArr? ))
(stest/instrument `sum:i)

(defn sum:k
  {:arglists '([karrArr])}
  [arr]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "sum"
                      [arr]
                      *global*)]
    (new out-types ast)))

(s/fdef sum:k
  :args (s/cat :arr valid-kArr? ))
(stest/instrument `sum:k)

(defn vtablewi
  {:arglists '([iindex itable ixmode & inarg1* inarg2* inarg3* inargN4* inargN5* inargN6* inargN7* inargN8* inargN9* inargN10* inargN11* inargN12* inargN13* inargN14* inargN15* inargN16*])}
  [index table xmode & [ narg1* narg2* narg3* nargN4* nargN5* nargN6* nargN7* nargN8* nargN9* nargN10* nargN11* nargN12* nargN13* nargN14* nargN15* nargN16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vtablewi"
                      [index table xmode narg1* narg2* narg3* nargN4* nargN5* nargN6* nargN7* nargN8* nargN9* nargN10* nargN11* nargN12* nargN13* nargN14* nargN15* nargN16*]
                      *global*)]
    (new out-types ast)))

(s/fdef vtablewi
  :args (s/cat :index valid-i? :table valid-i? :xmode valid-i? :narg1* (s/? valid-i?*) :narg2* (s/? valid-i?*) :narg3* (s/? valid-i?*) :nargN4* (s/? valid-i?*) :nargN5* (s/? valid-i?*) :nargN6* (s/? valid-i?*) :nargN7* (s/? valid-i?*) :nargN8* (s/? valid-i?*) :nargN9* (s/? valid-i?*) :nargN10* (s/? valid-i?*) :nargN11* (s/? valid-i?*) :nargN12* (s/? valid-i?*) :nargN13* (s/? valid-i?*) :nargN14* (s/? valid-i?*) :nargN15* (s/? valid-i?*) :nargN16* (s/? valid-i?*) ))
(stest/instrument `vtablewi)

(defn resonx
  {:arglists '([asig xcenter-frequency xbandwidth & inumlayer* iscale* iskip*])}
  [sig center-frequency bandwidth & [ numlayer* scale* skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "resonx"
                      [sig center-frequency bandwidth numlayer* scale* skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef resonx
  :args (s/cat :sig valid-ar? :center-frequency valid-x? :bandwidth valid-x? :numlayer* (s/? valid-i?*) :scale* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `resonx)

(defn lposcil3
  {:arglists '([kamp kfreqratio kloop kend & itable* iphase*])}
  [amp freqratio loop end & [ table* phase* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "lposcil3"
                      [amp freqratio loop end table* phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef lposcil3
  :args (s/cat :amp valid-kr? :freqratio valid-kr? :loop valid-kr? :end valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) ))
(stest/instrument `lposcil3)

(defn flashtxt
  {:arglists '([iwhich String] [iwhich itring])}
  [which tring]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "flashtxt"
                      [which tring]
                      *global*)]
    (new out-types ast)))

(s/fdef flashtxt
  :args (s/alt
         :ii (s/cat :which valid-i? :tring valid-i? )
         :iS (s/cat :which valid-i? :tring valid-S? )
         ))
(stest/instrument `flashtxt)

(defn shiftout
  {:arglists '([kInArr & ioff*])}
  [In & [ off* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "shiftout"
                      [In off*]
                      *global*)]
    (new out-types ast)))

(s/fdef shiftout
  :args (s/cat :In valid-kArr? :off* (s/? valid-i?*) ))
(stest/instrument `shiftout)

(defn vsubv
  {:arglists '([ifn1 ifn2 kelements & kdstoffset* ksrcoffset* kverbose*])}
  [fn1 fn2 elements & [ dstoffset* srcoffset* verbose* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vsubv"
                      [fn1 fn2 elements dstoffset* srcoffset* verbose*]
                      *global*)]
    (new out-types ast)))

(s/fdef vsubv
  :args (s/cat :fn1 valid-i? :fn2 valid-i? :elements valid-kr? :dstoffset* (s/? valid-kr?*) :srcoffset* (s/? valid-kr?*) :verbose* (s/? valid-kr?*) ))
(stest/instrument `vsubv)

(defn vmult_i
  {:arglists '([itable ival ielements & idstoffset*])}
  [table val elements & [ dstoffset* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vmult_i"
                      [table val elements dstoffset*]
                      *global*)]
    (new out-types ast)))

(s/fdef vmult_i
  :args (s/cat :table valid-i? :val valid-i? :elements valid-i? :dstoffset* (s/? valid-i?*) ))
(stest/instrument `vmult_i)

(defn vactrol
  {:arglists '([asig & iup* idown*])}
  [sig & [ up* down* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "vactrol"
                      [sig up* down*]
                      *global*)]
    (new out-types ast)))

(s/fdef vactrol
  :args (s/cat :sig valid-ar? :up* (s/? valid-i?*) :down* (s/? valid-i?*) ))
(stest/instrument `vactrol)

(defn fillarray
  {:arglists '([& Sval1* Sval2* Svaln3* Svaln4* Svaln5* Svaln6* Svaln7* Svaln8* Svaln9* Svaln10* Svaln11* Svaln12* Svaln13* Svaln14* Svaln15* Svaln16*] [& ival1* ival2* ivaln3* ivaln4* ivaln5* ivaln6* ivaln7* ivaln8* ivaln9* ivaln10* ivaln11* ivaln12* ivaln13* ivaln14* ivaln15* ivaln16*] [& ival1* ival2* ivaln3* ivaln4* ivaln5* ivaln6* ivaln7* ivaln8* ivaln9* ivaln10* ivaln11* ivaln12* ivaln13* ivaln14* ivaln15* ivaln16*])}
  [& [ val1* val2* valn3* valn4* valn5* valn6* valn7* valn8* valn9* valn10* valn11* valn12* valn13* valn14* valn15* valn16* ]]
  (let [out-types-quoted 'StringArray
        out-types StringArray
        ast (ast-node out-types-quoted
                      "fillarray"
                      [val1* val2* valn3* valn4* valn5* valn6* valn7* valn8* valn9* valn10* valn11* valn12* valn13* valn14* valn15* valn16*]
                      *global*)]
    (new out-types ast)))

(s/fdef fillarray
  :args (s/alt
         :iiiiiiiiiiiiiiii (s/cat :val1* (s/? valid-i?*) :val2* (s/? valid-i?*) :valn3* (s/? valid-i?*) :valn4* (s/? valid-i?*) :valn5* (s/? valid-i?*) :valn6* (s/? valid-i?*) :valn7* (s/? valid-i?*) :valn8* (s/? valid-i?*) :valn9* (s/? valid-i?*) :valn10* (s/? valid-i?*) :valn11* (s/? valid-i?*) :valn12* (s/? valid-i?*) :valn13* (s/? valid-i?*) :valn14* (s/? valid-i?*) :valn15* (s/? valid-i?*) :valn16* (s/? valid-i?*) )
         :SSSSSSSSSSSSSSSS (s/cat :val1* (s/? valid-S?*) :val2* (s/? valid-S?*) :valn3* (s/? valid-S?*) :valn4* (s/? valid-S?*) :valn5* (s/? valid-S?*) :valn6* (s/? valid-S?*) :valn7* (s/? valid-S?*) :valn8* (s/? valid-S?*) :valn9* (s/? valid-S?*) :valn10* (s/? valid-S?*) :valn11* (s/? valid-S?*) :valn12* (s/? valid-S?*) :valn13* (s/? valid-S?*) :valn14* (s/? valid-S?*) :valn15* (s/? valid-S?*) :valn16* (s/? valid-S?*) )
         ))
(stest/instrument `fillarray)

(defn fillarray:SArr
  {:arglists '([& Sval1* Sval2* Svaln3* Svaln4* Svaln5* Svaln6* Svaln7* Svaln8* Svaln9* Svaln10* Svaln11* Svaln12* Svaln13* Svaln14* Svaln15* Svaln16*])}
  [& [ val1* val2* valn3* valn4* valn5* valn6* valn7* valn8* valn9* valn10* valn11* valn12* valn13* valn14* valn15* valn16* ]]
  (let [out-types-quoted 'StringArray
        out-types StringArray
        ast (ast-node out-types-quoted
                      "fillarray"
                      [val1* val2* valn3* valn4* valn5* valn6* valn7* valn8* valn9* valn10* valn11* valn12* valn13* valn14* valn15* valn16*]
                      *global*)]
    (new out-types ast)))

(s/fdef fillarray:SArr
  :args (s/cat :val1* (s/? valid-S?*) :val2* (s/? valid-S?*) :valn3* (s/? valid-S?*) :valn4* (s/? valid-S?*) :valn5* (s/? valid-S?*) :valn6* (s/? valid-S?*) :valn7* (s/? valid-S?*) :valn8* (s/? valid-S?*) :valn9* (s/? valid-S?*) :valn10* (s/? valid-S?*) :valn11* (s/? valid-S?*) :valn12* (s/? valid-S?*) :valn13* (s/? valid-S?*) :valn14* (s/? valid-S?*) :valn15* (s/? valid-S?*) :valn16* (s/? valid-S?*) ))
(stest/instrument `fillarray:SArr)

(defn fillarray:iArr
  {:arglists '([& ival1* ival2* ivaln3* ivaln4* ivaln5* ivaln6* ivaln7* ivaln8* ivaln9* ivaln10* ivaln11* ivaln12* ivaln13* ivaln14* ivaln15* ivaln16*])}
  [& [ val1* val2* valn3* valn4* valn5* valn6* valn7* valn8* valn9* valn10* valn11* valn12* valn13* valn14* valn15* valn16* ]]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "fillarray"
                      [val1* val2* valn3* valn4* valn5* valn6* valn7* valn8* valn9* valn10* valn11* valn12* valn13* valn14* valn15* valn16*]
                      *global*)]
    (new out-types ast)))

(s/fdef fillarray:iArr
  :args (s/cat :val1* (s/? valid-i?*) :val2* (s/? valid-i?*) :valn3* (s/? valid-i?*) :valn4* (s/? valid-i?*) :valn5* (s/? valid-i?*) :valn6* (s/? valid-i?*) :valn7* (s/? valid-i?*) :valn8* (s/? valid-i?*) :valn9* (s/? valid-i?*) :valn10* (s/? valid-i?*) :valn11* (s/? valid-i?*) :valn12* (s/? valid-i?*) :valn13* (s/? valid-i?*) :valn14* (s/? valid-i?*) :valn15* (s/? valid-i?*) :valn16* (s/? valid-i?*) ))
(stest/instrument `fillarray:iArr)

(defn fillarray:kArr
  {:arglists '([& ival1* ival2* ivaln3* ivaln4* ivaln5* ivaln6* ivaln7* ivaln8* ivaln9* ivaln10* ivaln11* ivaln12* ivaln13* ivaln14* ivaln15* ivaln16*])}
  [& [ val1* val2* valn3* valn4* valn5* valn6* valn7* valn8* valn9* valn10* valn11* valn12* valn13* valn14* valn15* valn16* ]]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "fillarray"
                      [val1* val2* valn3* valn4* valn5* valn6* valn7* valn8* valn9* valn10* valn11* valn12* valn13* valn14* valn15* valn16*]
                      *global*)]
    (new out-types ast)))

(s/fdef fillarray:kArr
  :args (s/cat :val1* (s/? valid-i?*) :val2* (s/? valid-i?*) :valn3* (s/? valid-i?*) :valn4* (s/? valid-i?*) :valn5* (s/? valid-i?*) :valn6* (s/? valid-i?*) :valn7* (s/? valid-i?*) :valn8* (s/? valid-i?*) :valn9* (s/? valid-i?*) :valn10* (s/? valid-i?*) :valn11* (s/? valid-i?*) :valn12* (s/? valid-i?*) :valn13* (s/? valid-i?*) :valn14* (s/? valid-i?*) :valn15* (s/? valid-i?*) :valn16* (s/? valid-i?*) ))
(stest/instrument `fillarray:kArr)

(defn event_i
  {:arglists '([Sscorechar Sinsname & idelay1* idur2* ip3* ip4* ip5* ip6* ip7* ip8* ip9* ip10* ip11* ip12* ip13* ip14* ip15* ip16*] [Sscorechar iinsname & idelay1* idur2* ip3* ip4* ip5* ip6* ip7* ip8* ip9* ip10* ip11* ip12* ip13* ip14* ip15* ip16*])}
  [scorechar insname & [ delay1* dur2* p3* p4* p5* p6* p7* p8* p9* p10* p11* p12* p13* p14* p15* p16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "event_i"
                      [scorechar insname delay1* dur2* p3* p4* p5* p6* p7* p8* p9* p10* p11* p12* p13* p14* p15* p16*]
                      *global*)]
    (new out-types ast)))

(s/fdef event_i
  :args (s/alt
         :Siiiiiiiiiiiiiiiii (s/cat :scorechar valid-S? :insname valid-i? :delay1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :p3* (s/? valid-i?*) :p4* (s/? valid-i?*) :p5* (s/? valid-i?*) :p6* (s/? valid-i?*) :p7* (s/? valid-i?*) :p8* (s/? valid-i?*) :p9* (s/? valid-i?*) :p10* (s/? valid-i?*) :p11* (s/? valid-i?*) :p12* (s/? valid-i?*) :p13* (s/? valid-i?*) :p14* (s/? valid-i?*) :p15* (s/? valid-i?*) :p16* (s/? valid-i?*) )
         :SSiiiiiiiiiiiiiiii (s/cat :scorechar valid-S? :insname valid-S? :delay1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :p3* (s/? valid-i?*) :p4* (s/? valid-i?*) :p5* (s/? valid-i?*) :p6* (s/? valid-i?*) :p7* (s/? valid-i?*) :p8* (s/? valid-i?*) :p9* (s/? valid-i?*) :p10* (s/? valid-i?*) :p11* (s/? valid-i?*) :p12* (s/? valid-i?*) :p13* (s/? valid-i?*) :p14* (s/? valid-i?*) :p15* (s/? valid-i?*) :p16* (s/? valid-i?*) )
         ))
(stest/instrument `event_i)

(defn maca
  {:arglists '([& asig1* asig2* asig3* asig4* asig5* asig6* asig7* asig8* asig9* asig10* asig11* asig12* asig13* asig14* asig15* asig16* asig17* asig18* asig19* asig20* asig21* asig22* asig23* asig24* asig25* asig26* asig27* asig28* asig29* asig30* asig31* asig32*])}
  [& [ sig1* sig2* sig3* sig4* sig5* sig6* sig7* sig8* sig9* sig10* sig11* sig12* sig13* sig14* sig15* sig16* sig17* sig18* sig19* sig20* sig21* sig22* sig23* sig24* sig25* sig26* sig27* sig28* sig29* sig30* sig31* sig32* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "maca"
                      [sig1* sig2* sig3* sig4* sig5* sig6* sig7* sig8* sig9* sig10* sig11* sig12* sig13* sig14* sig15* sig16* sig17* sig18* sig19* sig20* sig21* sig22* sig23* sig24* sig25* sig26* sig27* sig28* sig29* sig30* sig31* sig32*]
                      *global*)]
    (new out-types ast)))

(s/fdef maca
  :args (s/cat :sig1* (s/? valid-ar?*) :sig2* (s/? valid-ar?*) :sig3* (s/? valid-ar?*) :sig4* (s/? valid-ar?*) :sig5* (s/? valid-ar?*) :sig6* (s/? valid-ar?*) :sig7* (s/? valid-ar?*) :sig8* (s/? valid-ar?*) :sig9* (s/? valid-ar?*) :sig10* (s/? valid-ar?*) :sig11* (s/? valid-ar?*) :sig12* (s/? valid-ar?*) :sig13* (s/? valid-ar?*) :sig14* (s/? valid-ar?*) :sig15* (s/? valid-ar?*) :sig16* (s/? valid-ar?*) :sig17* (s/? valid-ar?*) :sig18* (s/? valid-ar?*) :sig19* (s/? valid-ar?*) :sig20* (s/? valid-ar?*) :sig21* (s/? valid-ar?*) :sig22* (s/? valid-ar?*) :sig23* (s/? valid-ar?*) :sig24* (s/? valid-ar?*) :sig25* (s/? valid-ar?*) :sig26* (s/? valid-ar?*) :sig27* (s/? valid-ar?*) :sig28* (s/? valid-ar?*) :sig29* (s/? valid-ar?*) :sig30* (s/? valid-ar?*) :sig31* (s/? valid-ar?*) :sig32* (s/? valid-ar?*) ))
(stest/instrument `maca)

(defn freeverb
  {:arglists '([ainL ainR kRoomSize kHFDamp & iSRate* iSkip*])}
  [inL inR RoomSize HFDamp & [ SRate* Skip* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "freeverb"
                      [inL inR RoomSize HFDamp SRate* Skip*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef freeverb
  :args (s/cat :inL valid-ar? :inR valid-ar? :RoomSize valid-kr? :HFDamp valid-kr? :SRate* (s/? valid-i?*) :Skip* (s/? valid-i?*) ))
(stest/instrument `freeverb)

(defn dot
  {:arglists '([iarr1Arr iarg2Arr] [karr1Arr karg2Arr])}
  [arr1 arg2]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "dot"
                      [arr1 arg2]
                      *global*)]
    (new out-types ast)))

(s/fdef dot
  :args (s/alt
         :kArrkArr (s/cat :arr1 valid-kArr? :arg2 valid-kArr? )
         :iArriArr (s/cat :arr1 valid-iArr? :arg2 valid-iArr? )
         ))
(stest/instrument `dot)

(defn dot:i
  {:arglists '([iarr1Arr iarg2Arr])}
  [arr1 arg2]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "dot"
                      [arr1 arg2]
                      *global*)]
    (new out-types ast)))

(s/fdef dot:i
  :args (s/cat :arr1 valid-iArr? :arg2 valid-iArr? ))
(stest/instrument `dot:i)

(defn dot:k
  {:arglists '([karr1Arr karg2Arr])}
  [arr1 arg2]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "dot"
                      [arr1 arg2]
                      *global*)]
    (new out-types ast)))

(s/fdef dot:k
  :args (s/cat :arr1 valid-kArr? :arg2 valid-kArr? ))
(stest/instrument `dot:k)

(defn sfinstrm
  {:arglists '([ivel inotenum xamp xfreq instrnum ifilhandle & iflag* ioffset* ioffset*])}
  [vel notenum amp freq nstrnum filhandle & [ flag* offset* offset* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "sfinstrm"
                      [vel notenum amp freq nstrnum filhandle flag* offset* offset*]
                      *global*)]
    (new out-types ast)))

(s/fdef sfinstrm
  :args (s/cat :vel valid-i? :notenum valid-i? :amp valid-x? :freq valid-x? :nstrnum valid-i? :filhandle valid-i? :flag* (s/? valid-i?*) :offset* (s/? valid-i?*) :offset* (s/? valid-i?*) ))
(stest/instrument `sfinstrm)

(defn tableikt
  {:arglists '([xindex ktable & ixmode* ixoff* iwrap*] [xindex ktable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "tableikt"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef tableikt
  :args (s/alt
         :xkiii (s/cat :index valid-x? :table valid-kr? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) )
         ))
(stest/instrument `tableikt)

(defn tableikt:a
  {:arglists '([xindex ktable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "tableikt"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef tableikt:a
  :args (s/cat :index valid-x? :table valid-kr? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) ))
(stest/instrument `tableikt:a)

(defn tableikt:k
  {:arglists '([xindex ktable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "tableikt"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef tableikt:k
  :args (s/cat :index valid-x? :table valid-kr? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) ))
(stest/instrument `tableikt:k)

(defn rand
  {:arglists '([xamp iseed & isel* ioffset*] [xamp iseed & isel* ioffset*])}
  [amp seed & [ sel* offset* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "rand"
                      [amp seed sel* offset*]
                      *global*)]
    (new out-types ast)))

(s/fdef rand
  :args (s/alt
         :xiii (s/cat :amp valid-x? :seed valid-i? :sel* (s/? valid-i?*) :offset* (s/? valid-i?*) )
         ))
(stest/instrument `rand)

(defn rand:a
  {:arglists '([xamp iseed & isel* ioffset*])}
  [amp seed & [ sel* offset* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "rand"
                      [amp seed sel* offset*]
                      *global*)]
    (new out-types ast)))

(s/fdef rand:a
  :args (s/cat :amp valid-x? :seed valid-i? :sel* (s/? valid-i?*) :offset* (s/? valid-i?*) ))
(stest/instrument `rand:a)

(defn rand:k
  {:arglists '([xamp iseed & isel* ioffset*])}
  [amp seed & [ sel* offset* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "rand"
                      [amp seed sel* offset*]
                      *global*)]
    (new out-types ast)))

(s/fdef rand:k
  :args (s/cat :amp valid-x? :seed valid-i? :sel* (s/? valid-i?*) :offset* (s/? valid-i?*) ))
(stest/instrument `rand:k)

(defn butterbr
  {:arglists '([asig xfreq xband & iskip*])}
  [sig freq band & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "butterbr"
                      [sig freq band skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef butterbr
  :args (s/cat :sig valid-ar? :freq valid-x? :band valid-x? :skip* (s/? valid-i?*) ))
(stest/instrument `butterbr)

(defn mute
  {:arglists '([Sinsname & iswitch*] [iinsname & iswitch*])}
  [insname & [ switch* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "mute"
                      [insname switch*]
                      *global*)]
    (new out-types ast)))

(s/fdef mute
  :args (s/alt
         :ii (s/cat :insname valid-i? :switch* (s/? valid-i?*) )
         :Si (s/cat :insname valid-S? :switch* (s/? valid-i?*) )
         ))
(stest/instrument `mute)

(defn midic7
  {:arglists '([ictlno imin imax & itable*] [ictlno kmin kmax & itable*])}
  [ctlno min max & [ table* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "midic7"
                      [ctlno min max table*]
                      *global*)]
    (new out-types ast)))

(s/fdef midic7
  :args (s/alt
         :ikki (s/cat :ctlno valid-i? :min valid-kr? :max valid-kr? :table* (s/? valid-i?*) )
         :iiii (s/cat :ctlno valid-i? :min valid-i? :max valid-i? :table* (s/? valid-i?*) )
         ))
(stest/instrument `midic7)

(defn midic7:i
  {:arglists '([ictlno imin imax & itable*])}
  [ctlno min max & [ table* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "midic7"
                      [ctlno min max table*]
                      *global*)]
    (new out-types ast)))

(s/fdef midic7:i
  :args (s/cat :ctlno valid-i? :min valid-i? :max valid-i? :table* (s/? valid-i?*) ))
(stest/instrument `midic7:i)

(defn midic7:k
  {:arglists '([ictlno kmin kmax & itable*])}
  [ctlno min max & [ table* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "midic7"
                      [ctlno min max table*]
                      *global*)]
    (new out-types ast)))

(s/fdef midic7:k
  :args (s/cat :ctlno valid-i? :min valid-kr? :max valid-kr? :table* (s/? valid-i?*) ))
(stest/instrument `midic7:k)

(defn pdhalfy
  {:arglists '([ain kShapeAmount & ibipolar* ifullscale*])}
  [in ShapeAmount & [ bipolar* fullscale* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "pdhalfy"
                      [in ShapeAmount bipolar* fullscale*]
                      *global*)]
    (new out-types ast)))

(s/fdef pdhalfy
  :args (s/cat :in valid-ar? :ShapeAmount valid-kr? :bipolar* (s/? valid-i?*) :fullscale* (s/? valid-i?*) ))
(stest/instrument `pdhalfy)

(defn cbrt
  {:arglists '([iargArr] [kargArr])}
  [arg]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "cbrt"
                      [arg]
                      *global*)]
    (new out-types ast)))

(s/fdef cbrt
  :args (s/alt
         :kArr (s/cat :arg valid-kArr? )
         :iArr (s/cat :arg valid-iArr? )
         ))
(stest/instrument `cbrt)

(defn cbrt:iArr
  {:arglists '([iargArr])}
  [arg]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "cbrt"
                      [arg]
                      *global*)]
    (new out-types ast)))

(s/fdef cbrt:iArr
  :args (s/cat :arg valid-iArr? ))
(stest/instrument `cbrt:iArr)

(defn cbrt:kArr
  {:arglists '([kargArr])}
  [arg]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "cbrt"
                      [arg]
                      *global*)]
    (new out-types ast)))

(s/fdef cbrt:kArr
  :args (s/cat :arg valid-kArr? ))
(stest/instrument `cbrt:kArr)

(defn ATSpartialtap
  {:arglists '([ipartialnum])}
  [partialnum]
  (let [out-types-quoted '[ControlSignal ControlSignal]
        out-types [ControlSignal ControlSignal]
        ast (ast-node out-types-quoted
                      "ATSpartialtap"
                      [partialnum]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef ATSpartialtap
  :args (s/cat :partialnum valid-i? ))
(stest/instrument `ATSpartialtap)

(defn seqtime2
  {:arglists '([ktrig_in ktime_unit kstart kloop kinitndx kfn_times])}
  [trig_in time_unit start loop initndx fn_times]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "seqtime2"
                      [trig_in time_unit start loop initndx fn_times]
                      *global*)]
    (new out-types ast)))

(s/fdef seqtime2
  :args (s/cat :trig_in valid-kr? :time_unit valid-kr? :start valid-kr? :loop valid-kr? :initndx valid-kr? :fn_times valid-kr? ))
(stest/instrument `seqtime2)

(defn dssiactivate
  {:arglists '([ihandle ktoggle])}
  [handle toggle]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "dssiactivate"
                      [handle toggle]
                      *global*)]
    (new out-types ast)))

(s/fdef dssiactivate
  :args (s/cat :handle valid-i? :toggle valid-kr? ))
(stest/instrument `dssiactivate)

(defn vlowres
  {:arglists '([asig kcutoff-frequency kresonance iord ksep])}
  [sig cutoff-frequency resonance ord sep]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "vlowres"
                      [sig cutoff-frequency resonance ord sep]
                      *global*)]
    (new out-types ast)))

(s/fdef vlowres
  :args (s/cat :sig valid-ar? :cutoff-frequency valid-kr? :resonance valid-kr? :ord valid-i? :sep valid-kr? ))
(stest/instrument `vlowres)

(defn exitnow
  {:arglists '([& ivalue*])}
  [& [ value* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "exitnow"
                      [value*]
                      *global*)]
    (new out-types ast)))

(s/fdef exitnow
  :args (s/cat :value* (s/? valid-i?*) ))
(stest/instrument `exitnow)

(defn mags
  {:arglists '([kinArr])}
  [in]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "mags"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef mags
  :args (s/cat :in valid-kArr? ))
(stest/instrument `mags)

(defn return
  {:arglists '([ival])}
  [val]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "return"
                      [val]
                      *global*)]
    (new out-types ast)))

(s/fdef return
  :args (s/cat :val valid-i? ))
(stest/instrument `return)

(defn hilbert2
  {:arglists '([asig ifftsize ihopsize])}
  [sig fftsize hopsize]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "hilbert2"
                      [sig fftsize hopsize]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef hilbert2
  :args (s/cat :sig valid-ar? :fftsize valid-i? :hopsize valid-i? ))
(stest/instrument `hilbert2)

(defn vibes
  {:arglists '([kamp kfreq ihrd ipos imp kvibf kvamp ivibfn idec])}
  [amp freq hrd pos mp vibf vamp vibfn dec]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "vibes"
                      [amp freq hrd pos mp vibf vamp vibfn dec]
                      *global*)]
    (new out-types ast)))

(s/fdef vibes
  :args (s/cat :amp valid-kr? :freq valid-kr? :hrd valid-i? :pos valid-i? :mp valid-i? :vibf valid-kr? :vamp valid-kr? :vibfn valid-i? :dec valid-i? ))
(stest/instrument `vibes)

(defn planet
  {:arglists '([kmass1 kmass2 ksep ix iy iz ivx ivy ivz idelta & ifriction* iskip*])}
  [mass1 mass2 sep x y z vx vy vz delta & [ friction* skip* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "planet"
                      [mass1 mass2 sep x y z vx vy vz delta friction* skip*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef planet
  :args (s/cat :mass1 valid-kr? :mass2 valid-kr? :sep valid-kr? :x valid-i? :y valid-i? :z valid-i? :vx valid-i? :vy valid-i? :vz valid-i? :delta valid-i? :friction* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `planet)

(defn fareyleni
  {:arglists '([itable])}
  [table]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "fareyleni"
                      [table]
                      *global*)]
    (new out-types ast)))

(s/fdef fareyleni
  :args (s/cat :table valid-i? ))
(stest/instrument `fareyleni)

(defn vtaba
  {:arglists '([aindex itable & aout1* aout2* aout3* aoutN4* aoutN5* aoutN6* aoutN7* aoutN8* aoutN9* aoutN10* aoutN11* aoutN12* aoutN13* aoutN14* aoutN15* aoutN16* aoutN17* aoutN18* aoutN19* aoutN20* aoutN21* aoutN22* aoutN23* aoutN24* aoutN25* aoutN26* aoutN27* aoutN28* aoutN29* aoutN30* aoutN31* aoutN32*])}
  [index table & [ out1* out2* out3* outN4* outN5* outN6* outN7* outN8* outN9* outN10* outN11* outN12* outN13* outN14* outN15* outN16* outN17* outN18* outN19* outN20* outN21* outN22* outN23* outN24* outN25* outN26* outN27* outN28* outN29* outN30* outN31* outN32* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vtaba"
                      [index table out1* out2* out3* outN4* outN5* outN6* outN7* outN8* outN9* outN10* outN11* outN12* outN13* outN14* outN15* outN16* outN17* outN18* outN19* outN20* outN21* outN22* outN23* outN24* outN25* outN26* outN27* outN28* outN29* outN30* outN31* outN32*]
                      *global*)]
    (new out-types ast)))

(s/fdef vtaba
  :args (s/cat :index valid-ar? :table valid-i? :out1* (s/? valid-ar?*) :out2* (s/? valid-ar?*) :out3* (s/? valid-ar?*) :outN4* (s/? valid-ar?*) :outN5* (s/? valid-ar?*) :outN6* (s/? valid-ar?*) :outN7* (s/? valid-ar?*) :outN8* (s/? valid-ar?*) :outN9* (s/? valid-ar?*) :outN10* (s/? valid-ar?*) :outN11* (s/? valid-ar?*) :outN12* (s/? valid-ar?*) :outN13* (s/? valid-ar?*) :outN14* (s/? valid-ar?*) :outN15* (s/? valid-ar?*) :outN16* (s/? valid-ar?*) :outN17* (s/? valid-ar?*) :outN18* (s/? valid-ar?*) :outN19* (s/? valid-ar?*) :outN20* (s/? valid-ar?*) :outN21* (s/? valid-ar?*) :outN22* (s/? valid-ar?*) :outN23* (s/? valid-ar?*) :outN24* (s/? valid-ar?*) :outN25* (s/? valid-ar?*) :outN26* (s/? valid-ar?*) :outN27* (s/? valid-ar?*) :outN28* (s/? valid-ar?*) :outN29* (s/? valid-ar?*) :outN30* (s/? valid-ar?*) :outN31* (s/? valid-ar?*) :outN32* (s/? valid-ar?*) ))
(stest/instrument `vtaba)

(defn sfplay
  {:arglists '([ivel inotenum xamp xfreq ipreindex & iflag* ioffset* ienv*])}
  [vel notenum amp freq preindex & [ flag* offset* env* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "sfplay"
                      [vel notenum amp freq preindex flag* offset* env*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef sfplay
  :args (s/cat :vel valid-i? :notenum valid-i? :amp valid-x? :freq valid-x? :preindex valid-i? :flag* (s/? valid-i?*) :offset* (s/? valid-i?*) :env* (s/? valid-i?*) ))
(stest/instrument `sfplay)

(defn midiin
  {:arglists '()}
  []
  (let [out-types-quoted '[ControlSignal ControlSignal ControlSignal ControlSignal]
        out-types [ControlSignal ControlSignal ControlSignal ControlSignal]
        ast (ast-node out-types-quoted
                      "midiin"
                      []
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))


(defn midglobal
  {:arglists '([Ssource & instrnum1* instrnum2* instrnum3* instrnum4* instrnum5* instrnum6* instrnum7* instrnum8* instrnum9* instrnum10* instrnum11* instrnum12* instrnum13* instrnum14* instrnum15* instrnum16*])}
  [source & [ nstrnum1* nstrnum2* nstrnum3* nstrnum4* nstrnum5* nstrnum6* nstrnum7* nstrnum8* nstrnum9* nstrnum10* nstrnum11* nstrnum12* nstrnum13* nstrnum14* nstrnum15* nstrnum16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "midglobal"
                      [source nstrnum1* nstrnum2* nstrnum3* nstrnum4* nstrnum5* nstrnum6* nstrnum7* nstrnum8* nstrnum9* nstrnum10* nstrnum11* nstrnum12* nstrnum13* nstrnum14* nstrnum15* nstrnum16*]
                      *global*)]
    (new out-types ast)))

(s/fdef midglobal
  :args (s/cat :source valid-S? :nstrnum1* (s/? valid-i?*) :nstrnum2* (s/? valid-i?*) :nstrnum3* (s/? valid-i?*) :nstrnum4* (s/? valid-i?*) :nstrnum5* (s/? valid-i?*) :nstrnum6* (s/? valid-i?*) :nstrnum7* (s/? valid-i?*) :nstrnum8* (s/? valid-i?*) :nstrnum9* (s/? valid-i?*) :nstrnum10* (s/? valid-i?*) :nstrnum11* (s/? valid-i?*) :nstrnum12* (s/? valid-i?*) :nstrnum13* (s/? valid-i?*) :nstrnum14* (s/? valid-i?*) :nstrnum15* (s/? valid-i?*) :nstrnum16* (s/? valid-i?*) ))
(stest/instrument `midglobal)

(defn tabmorpha
  {:arglists '([aindex aweightpoint atabnum3 atabnum4 & ifn1* ifn2* ifn3* ifn4* ifnN5* ifnN6* ifnN7* ifnN8* ifnN9* ifnN10* ifnN11* ifnN12* ifnN13* ifnN14* ifnN15* ifnN16*])}
  [index weightpoint tabnum3 tabnum4 & [ fn1* fn2* fn3* fn4* fnN5* fnN6* fnN7* fnN8* fnN9* fnN10* fnN11* fnN12* fnN13* fnN14* fnN15* fnN16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "tabmorpha"
                      [index weightpoint tabnum3 tabnum4 fn1* fn2* fn3* fn4* fnN5* fnN6* fnN7* fnN8* fnN9* fnN10* fnN11* fnN12* fnN13* fnN14* fnN15* fnN16*]
                      *global*)]
    (new out-types ast)))

(s/fdef tabmorpha
  :args (s/cat :index valid-ar? :weightpoint valid-ar? :tabnum3 valid-ar? :tabnum4 valid-ar? :fn1* (s/? valid-i?*) :fn2* (s/? valid-i?*) :fn3* (s/? valid-i?*) :fn4* (s/? valid-i?*) :fnN5* (s/? valid-i?*) :fnN6* (s/? valid-i?*) :fnN7* (s/? valid-i?*) :fnN8* (s/? valid-i?*) :fnN9* (s/? valid-i?*) :fnN10* (s/? valid-i?*) :fnN11* (s/? valid-i?*) :fnN12* (s/? valid-i?*) :fnN13* (s/? valid-i?*) :fnN14* (s/? valid-i?*) :fnN15* (s/? valid-i?*) :fnN16* (s/? valid-i?*) ))
(stest/instrument `tabmorpha)

(defn ptable3
  {:arglists '([xindex itable & ixmode* ixoff* iwrap*] [iindex itable & ixmode* ixoff* iwrap*] [xindex itable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "ptable3"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef ptable3
  :args (s/alt
         :iiiii (s/cat :index valid-i? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) )
         :xiiii (s/cat :index valid-x? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) )
         ))
(stest/instrument `ptable3)

(defn ptable3:a
  {:arglists '([xindex itable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "ptable3"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef ptable3:a
  :args (s/cat :index valid-x? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) ))
(stest/instrument `ptable3:a)

(defn ptable3:i
  {:arglists '([iindex itable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "ptable3"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef ptable3:i
  :args (s/cat :index valid-i? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) ))
(stest/instrument `ptable3:i)

(defn ptable3:k
  {:arglists '([xindex itable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "ptable3"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef ptable3:k
  :args (s/cat :index valid-x? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) ))
(stest/instrument `ptable3:k)

(defn sc_lagud
  {:arglists '([ain klagup klagdown & ilagdown*] [kin klagup klagdown & ilagdown*])}
  [in lagup lagdown & [ lagdown* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "sc_lagud"
                      [in lagup lagdown lagdown*]
                      *global*)]
    (new out-types ast)))

(s/fdef sc_lagud
  :args (s/alt
         :kkki (s/cat :in valid-kr? :lagup valid-kr? :lagdown valid-kr? :lagdown* (s/? valid-i?*) )
         :akki (s/cat :in valid-ar? :lagup valid-kr? :lagdown valid-kr? :lagdown* (s/? valid-i?*) )
         ))
(stest/instrument `sc_lagud)

(defn sc_lagud:a
  {:arglists '([ain klagup klagdown & ilagdown*])}
  [in lagup lagdown & [ lagdown* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "sc_lagud"
                      [in lagup lagdown lagdown*]
                      *global*)]
    (new out-types ast)))

(s/fdef sc_lagud:a
  :args (s/cat :in valid-ar? :lagup valid-kr? :lagdown valid-kr? :lagdown* (s/? valid-i?*) ))
(stest/instrument `sc_lagud:a)

(defn sc_lagud:k
  {:arglists '([kin klagup klagdown & ilagdown*])}
  [in lagup lagdown & [ lagdown* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "sc_lagud"
                      [in lagup lagdown lagdown*]
                      *global*)]
    (new out-types ast)))

(s/fdef sc_lagud:k
  :args (s/cat :in valid-kr? :lagup valid-kr? :lagdown valid-kr? :lagdown* (s/? valid-i?*) ))
(stest/instrument `sc_lagud:k)

(defn repluck
  {:arglists '([iplk kamp icps kpick krefl axcite])}
  [plk amp cps pick refl xcite]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "repluck"
                      [plk amp cps pick refl xcite]
                      *global*)]
    (new out-types ast)))

(s/fdef repluck
  :args (s/cat :plk valid-i? :amp valid-kr? :cps valid-i? :pick valid-kr? :refl valid-kr? :xcite valid-ar? ))
(stest/instrument `repluck)

(defn ftfree
  {:arglists '([ifno iwhen])}
  [fno when]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "ftfree"
                      [fno when]
                      *global*)]
    (new out-types ast)))

(s/fdef ftfree
  :args (s/cat :fno valid-i? :when valid-i? ))
(stest/instrument `ftfree)

(defn ins
  {:arglists '()}
  []
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "ins"
                      []
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))


(defn sekere
  {:arglists '([iamp idettack & inum* idamp* imaxshake*])}
  [amp dettack & [ num* damp* maxshake* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "sekere"
                      [amp dettack num* damp* maxshake*]
                      *global*)]
    (new out-types ast)))

(s/fdef sekere
  :args (s/cat :amp valid-i? :dettack valid-i? :num* (s/? valid-i?*) :damp* (s/? valid-i?*) :maxshake* (s/? valid-i?*) ))
(stest/instrument `sekere)

(defn pvsbandr
  {:arglists '([fsigin xlowcut xlowfull xhighfull xhighcut & ktype*])}
  [sigin lowcut lowfull highfull highcut & [ type* ]]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvsbandr"
                      [sigin lowcut lowfull highfull highcut type*]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsbandr
  :args (s/cat :sigin valid-f? :lowcut valid-x? :lowfull valid-x? :highfull valid-x? :highcut valid-x? :type* (s/? valid-kr?*) ))
(stest/instrument `pvsbandr)

(defn vco
  {:arglists '([xamp xcps iwave & kpw* itable* imaxd* ileak* inyx* iphase* iskip*])}
  [amp cps wave & [ pw* table* maxd* leak* nyx* phase* skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "vco"
                      [amp cps wave pw* table* maxd* leak* nyx* phase* skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef vco
  :args (s/cat :amp valid-x? :cps valid-x? :wave valid-i? :pw* (s/? valid-kr?*) :table* (s/? valid-i?*) :maxd* (s/? valid-i?*) :leak* (s/? valid-i?*) :nyx* (s/? valid-i?*) :phase* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `vco)

(defn tablefilter
  {:arglists '([kouttable kintatble kmode kparam])}
  [outtable intatble mode param]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "tablefilter"
                      [outtable intatble mode param]
                      *global*)]
    (new out-types ast)))

(s/fdef tablefilter
  :args (s/cat :outtable valid-kr? :intatble valid-kr? :mode valid-kr? :param valid-kr? ))
(stest/instrument `tablefilter)

(defn grain
  {:arglists '([xamp xpitch xdens kampoff kpitchoff kgdur igfn iwfn imgdur & igrnd*])}
  [amp pitch dens ampoff pitchoff gdur gfn wfn mgdur & [ grnd* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "grain"
                      [amp pitch dens ampoff pitchoff gdur gfn wfn mgdur grnd*]
                      *global*)]
    (new out-types ast)))

(s/fdef grain
  :args (s/cat :amp valid-x? :pitch valid-x? :dens valid-x? :ampoff valid-kr? :pitchoff valid-kr? :gdur valid-kr? :gfn valid-i? :wfn valid-i? :mgdur valid-i? :grnd* (s/? valid-i?*) ))
(stest/instrument `grain)

(defn ctrl21
  {:arglists '([ichan ictlno2 ictlno3 ictlno4 imin imax & itable*] [ichan ictlno2 ictlno3 ictlno4 kmin kmax & itable*])}
  [chan ctlno2 ctlno3 ctlno4 min max & [ table* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "ctrl21"
                      [chan ctlno2 ctlno3 ctlno4 min max table*]
                      *global*)]
    (new out-types ast)))

(s/fdef ctrl21
  :args (s/alt
         :iiiikki (s/cat :chan valid-i? :ctlno2 valid-i? :ctlno3 valid-i? :ctlno4 valid-i? :min valid-kr? :max valid-kr? :table* (s/? valid-i?*) )
         :iiiiiii (s/cat :chan valid-i? :ctlno2 valid-i? :ctlno3 valid-i? :ctlno4 valid-i? :min valid-i? :max valid-i? :table* (s/? valid-i?*) )
         ))
(stest/instrument `ctrl21)

(defn ctrl21:i
  {:arglists '([ichan ictlno2 ictlno3 ictlno4 imin imax & itable*])}
  [chan ctlno2 ctlno3 ctlno4 min max & [ table* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "ctrl21"
                      [chan ctlno2 ctlno3 ctlno4 min max table*]
                      *global*)]
    (new out-types ast)))

(s/fdef ctrl21:i
  :args (s/cat :chan valid-i? :ctlno2 valid-i? :ctlno3 valid-i? :ctlno4 valid-i? :min valid-i? :max valid-i? :table* (s/? valid-i?*) ))
(stest/instrument `ctrl21:i)

(defn ctrl21:k
  {:arglists '([ichan ictlno2 ictlno3 ictlno4 kmin kmax & itable*])}
  [chan ctlno2 ctlno3 ctlno4 min max & [ table* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "ctrl21"
                      [chan ctlno2 ctlno3 ctlno4 min max table*]
                      *global*)]
    (new out-types ast)))

(s/fdef ctrl21:k
  :args (s/cat :chan valid-i? :ctlno2 valid-i? :ctlno3 valid-i? :ctlno4 valid-i? :min valid-kr? :max valid-kr? :table* (s/? valid-i?*) ))
(stest/instrument `ctrl21:k)

(defn schedkwhennamed
  {:arglists '([ktrigger kmintim kmaxnum Sname kwhen & kdur1* kp2* kp3* kp4* kp5* kp6* kp7* kp8* kp9* kp10* kp11* kp12* kp13* kp14* kp15* kp16*] [ktrigger kmintim kmaxnum kname kwhen & kdur1* kp2* kp3* kp4* kp5* kp6* kp7* kp8* kp9* kp10* kp11* kp12* kp13* kp14* kp15* kp16*])}
  [trigger mintim maxnum name when & [ dur1* p2* p3* p4* p5* p6* p7* p8* p9* p10* p11* p12* p13* p14* p15* p16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "schedkwhennamed"
                      [trigger mintim maxnum name when dur1* p2* p3* p4* p5* p6* p7* p8* p9* p10* p11* p12* p13* p14* p15* p16*]
                      *global*)]
    (new out-types ast)))

(s/fdef schedkwhennamed
  :args (s/alt
         :kkkkkkkkkkkkkkkkkkkkk (s/cat :trigger valid-kr? :mintim valid-kr? :maxnum valid-kr? :name valid-kr? :when valid-kr? :dur1* (s/? valid-kr?*) :p2* (s/? valid-kr?*) :p3* (s/? valid-kr?*) :p4* (s/? valid-kr?*) :p5* (s/? valid-kr?*) :p6* (s/? valid-kr?*) :p7* (s/? valid-kr?*) :p8* (s/? valid-kr?*) :p9* (s/? valid-kr?*) :p10* (s/? valid-kr?*) :p11* (s/? valid-kr?*) :p12* (s/? valid-kr?*) :p13* (s/? valid-kr?*) :p14* (s/? valid-kr?*) :p15* (s/? valid-kr?*) :p16* (s/? valid-kr?*) )
         :kkkSkkkkkkkkkkkkkkkkk (s/cat :trigger valid-kr? :mintim valid-kr? :maxnum valid-kr? :name valid-S? :when valid-kr? :dur1* (s/? valid-kr?*) :p2* (s/? valid-kr?*) :p3* (s/? valid-kr?*) :p4* (s/? valid-kr?*) :p5* (s/? valid-kr?*) :p6* (s/? valid-kr?*) :p7* (s/? valid-kr?*) :p8* (s/? valid-kr?*) :p9* (s/? valid-kr?*) :p10* (s/? valid-kr?*) :p11* (s/? valid-kr?*) :p12* (s/? valid-kr?*) :p13* (s/? valid-kr?*) :p14* (s/? valid-kr?*) :p15* (s/? valid-kr?*) :p16* (s/? valid-kr?*) )
         ))
(stest/instrument `schedkwhennamed)

(defn pvinterp
  {:arglists '([ktimpnt kfmod Sfile kfreqscale4 kfreqscale5 kampscale6 kampscale7 kfreqinterp kampinterp] [ktimpnt kfmod ifile kfreqscale4 kfreqscale5 kampscale6 kampscale7 kfreqinterp kampinterp])}
  [timpnt fmod file freqscale4 freqscale5 ampscale6 ampscale7 freqinterp ampinterp]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "pvinterp"
                      [timpnt fmod file freqscale4 freqscale5 ampscale6 ampscale7 freqinterp ampinterp]
                      *global*)]
    (new out-types ast)))

(s/fdef pvinterp
  :args (s/alt
         :kkikkkkkk (s/cat :timpnt valid-kr? :fmod valid-kr? :file valid-i? :freqscale4 valid-kr? :freqscale5 valid-kr? :ampscale6 valid-kr? :ampscale7 valid-kr? :freqinterp valid-kr? :ampinterp valid-kr? )
         :kkSkkkkkk (s/cat :timpnt valid-kr? :fmod valid-kr? :file valid-S? :freqscale4 valid-kr? :freqscale5 valid-kr? :ampscale6 valid-kr? :ampscale7 valid-kr? :freqinterp valid-kr? :ampinterp valid-kr? )
         ))
(stest/instrument `pvinterp)

(defn pvsftw
  {:arglists '([fsrc ifna & ifnf*])}
  [src fna & [ fnf* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "pvsftw"
                      [src fna fnf*]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsftw
  :args (s/cat :src valid-f? :fna valid-i? :fnf* (s/? valid-i?*) ))
(stest/instrument `pvsftw)

(defn pan2
  {:arglists '([asig xp & imode*])}
  [sig p & [ mode* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "pan2"
                      [sig p mode*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef pan2
  :args (s/cat :sig valid-ar? :p valid-x? :mode* (s/? valid-i?*) ))
(stest/instrument `pan2)

(defn olabuffer
  {:arglists '([kinArr ioverlap])}
  [in overlap]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "olabuffer"
                      [in overlap]
                      *global*)]
    (new out-types ast)))

(s/fdef olabuffer
  :args (s/cat :in valid-kArr? :overlap valid-i? ))
(stest/instrument `olabuffer)

(defn lposcilsa
  {:arglists '([aamp kfreqratio kloop kend ift & iphase*])}
  [amp freqratio loop end ft & [ phase* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "lposcilsa"
                      [amp freqratio loop end ft phase*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef lposcilsa
  :args (s/cat :amp valid-ar? :freqratio valid-kr? :loop valid-kr? :end valid-kr? :ft valid-i? :phase* (s/? valid-i?*) ))
(stest/instrument `lposcilsa)

(defn ptablei
  {:arglists '([xindex itable & ixmode* ixoff* iwrap*] [iindex itable & ixmode* ixoff* iwrap*] [xindex itable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "ptablei"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef ptablei
  :args (s/alt
         :iiiii (s/cat :index valid-i? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) )
         :xiiii (s/cat :index valid-x? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) )
         ))
(stest/instrument `ptablei)

(defn ptablei:a
  {:arglists '([xindex itable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "ptablei"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef ptablei:a
  :args (s/cat :index valid-x? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) ))
(stest/instrument `ptablei:a)

(defn ptablei:i
  {:arglists '([iindex itable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "ptablei"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef ptablei:i
  :args (s/cat :index valid-i? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) ))
(stest/instrument `ptablei:i)

(defn ptablei:k
  {:arglists '([xindex itable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "ptablei"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef ptablei:k
  :args (s/cat :index valid-x? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) ))
(stest/instrument `ptablei:k)

(defn imagesetpixel
  {:arglists '([iimagenum xx xy xred xgreen xblue])}
  [imagenum x y red green blue]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "imagesetpixel"
                      [imagenum x y red green blue]
                      *global*)]
    (new out-types ast)))

(s/fdef imagesetpixel
  :args (s/cat :imagenum valid-i? :x valid-x? :y valid-x? :red valid-x? :green valid-x? :blue valid-x? ))
(stest/instrument `imagesetpixel)

(defn pconvolve
  {:arglists '([ain Sfilcod & ipartitionsize* ichannel*] [ain ifilcod & ipartitionsize* ichannel*])}
  [in filcod & [ partitionsize* channel* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "pconvolve"
                      [in filcod partitionsize* channel*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef pconvolve
  :args (s/alt
         :aiii (s/cat :in valid-ar? :filcod valid-i? :partitionsize* (s/? valid-i?*) :channel* (s/? valid-i?*) )
         :aSii (s/cat :in valid-ar? :filcod valid-S? :partitionsize* (s/? valid-i?*) :channel* (s/? valid-i?*) )
         ))
(stest/instrument `pconvolve)

(defn locsig
  {:arglists '([asig kdegree kdistance kreverbsend])}
  [sig degree distance reverbsend]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "locsig"
                      [sig degree distance reverbsend]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef locsig
  :args (s/cat :sig valid-ar? :degree valid-kr? :distance valid-kr? :reverbsend valid-kr? ))
(stest/instrument `locsig)

(defn pvsfilter
  {:arglists '([fsigin fsigfil fdepth & igain*] [fsigin fsigfil xdepth & igain*] [fsigin fsigfil xdepth & igain*])}
  [sigin sigfil depth & [ gain* ]]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvsfilter"
                      [sigin sigfil depth gain*]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsfilter
  :args (s/alt
         :ffxi (s/cat :sigin valid-f? :sigfil valid-f? :depth valid-x? :gain* (s/? valid-i?*) )
         :fffi (s/cat :sigin valid-f? :sigfil valid-f? :depth valid-f? :gain* (s/? valid-i?*) )
         ))
(stest/instrument `pvsfilter)

(defn chnparams
  {:arglists '([Sname])}
  [name]
  (let [out-types-quoted '[Variable Variable Variable Variable Variable Variable]
        out-types [Variable Variable Variable Variable Variable Variable]
        ast (ast-node out-types-quoted
                      "chnparams"
                      [name]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef chnparams
  :args (s/cat :name valid-S? ))
(stest/instrument `chnparams)

(defn cell
  {:arglists '([ktrig kreinit ioutFunc initStateFunc iRuleFunc ielements])}
  [trig reinit outFunc nitStateFunc RuleFunc elements]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "cell"
                      [trig reinit outFunc nitStateFunc RuleFunc elements]
                      *global*)]
    (new out-types ast)))

(s/fdef cell
  :args (s/cat :trig valid-kr? :reinit valid-kr? :outFunc valid-i? :nitStateFunc valid-i? :RuleFunc valid-i? :elements valid-i? ))
(stest/instrument `cell)

(defn cpstun
  {:arglists '([ktrig kindex ktable])}
  [trig index table]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "cpstun"
                      [trig index table]
                      *global*)]
    (new out-types ast)))

(s/fdef cpstun
  :args (s/cat :trig valid-kr? :index valid-kr? :table valid-kr? ))
(stest/instrument `cpstun)

(defn cossegb
  {:arglists '([ia itim2 & ib1* itim2* ic3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*] [ia itim2 & ib1* itim2* ic3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a tim2 & [ b1* tim2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "cossegb"
                      [a tim2 b1* tim2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef cossegb
  :args (s/alt
         :iiiiiiiiiiiiiiiiii (s/cat :a valid-i? :tim2 valid-i? :b1* (s/? valid-i?*) :tim2* (s/? valid-i?*) :c3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) )
         ))
(stest/instrument `cossegb)

(defn cossegb:a
  {:arglists '([ia itim2 & ib1* itim2* ic3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a tim2 & [ b1* tim2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "cossegb"
                      [a tim2 b1* tim2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef cossegb:a
  :args (s/cat :a valid-i? :tim2 valid-i? :b1* (s/? valid-i?*) :tim2* (s/? valid-i?*) :c3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) ))
(stest/instrument `cossegb:a)

(defn cossegb:k
  {:arglists '([ia itim2 & ib1* itim2* ic3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a tim2 & [ b1* tim2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "cossegb"
                      [a tim2 b1* tim2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef cossegb:k
  :args (s/cat :a valid-i? :tim2 valid-i? :b1* (s/? valid-i?*) :tim2* (s/? valid-i?*) :c3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) ))
(stest/instrument `cossegb:k)

(defn genarray
  {:arglists '([istart iens & inc*] [kstart kens & inc*])}
  [start ens & [ nc* ]]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "genarray"
                      [start ens nc*]
                      *global*)]
    (new out-types ast)))

(s/fdef genarray
  :args (s/alt
         :kki (s/cat :start valid-kr? :ens valid-kr? :nc* (s/? valid-i?*) )
         :iii (s/cat :start valid-i? :ens valid-i? :nc* (s/? valid-i?*) )
         ))
(stest/instrument `genarray)

(defn genarray:iArr
  {:arglists '([istart iens & inc*])}
  [start ens & [ nc* ]]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "genarray"
                      [start ens nc*]
                      *global*)]
    (new out-types ast)))

(s/fdef genarray:iArr
  :args (s/cat :start valid-i? :ens valid-i? :nc* (s/? valid-i?*) ))
(stest/instrument `genarray:iArr)

(defn genarray:kArr
  {:arglists '([kstart kens & inc*])}
  [start ens & [ nc* ]]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "genarray"
                      [start ens nc*]
                      *global*)]
    (new out-types ast)))

(s/fdef genarray:kArr
  :args (s/cat :start valid-kr? :ens valid-kr? :nc* (s/? valid-i?*) ))
(stest/instrument `genarray:kArr)

(defn MixerSetLevel
  {:arglists '([isend ibuss kgain])}
  [send buss gain]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "MixerSetLevel"
                      [send buss gain]
                      *global*)]
    (new out-types ast)))

(s/fdef MixerSetLevel
  :args (s/cat :send valid-i? :buss valid-i? :gain valid-kr? ))
(stest/instrument `MixerSetLevel)

(defn tableimix
  {:arglists '([idft idoff ilen is1ft is1off is1g is2ft is2off is2g])}
  [dft doff len s1ft s1off s1g s2ft s2off s2g]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "tableimix"
                      [dft doff len s1ft s1off s1g s2ft s2off s2g]
                      *global*)]
    (new out-types ast)))

(s/fdef tableimix
  :args (s/cat :dft valid-i? :doff valid-i? :len valid-i? :s1ft valid-i? :s1off valid-i? :s1g valid-i? :s2ft valid-i? :s2off valid-i? :s2g valid-i? ))
(stest/instrument `tableimix)

(defn trshift
  {:arglists '([fin & kpshift1* kgain2* kgain3* kgain4* kgain5* kgain6* kgain7* kgain8* kgain9* kgain10* kgain11* kgain12* kgain13* kgain14* kgain15* kgain16*])}
  [in & [ pshift1* gain2* gain3* gain4* gain5* gain6* gain7* gain8* gain9* gain10* gain11* gain12* gain13* gain14* gain15* gain16* ]]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "trshift"
                      [in pshift1* gain2* gain3* gain4* gain5* gain6* gain7* gain8* gain9* gain10* gain11* gain12* gain13* gain14* gain15* gain16*]
                      *global*)]
    (new out-types ast)))

(s/fdef trshift
  :args (s/cat :in valid-f? :pshift1* (s/? valid-kr?*) :gain2* (s/? valid-kr?*) :gain3* (s/? valid-kr?*) :gain4* (s/? valid-kr?*) :gain5* (s/? valid-kr?*) :gain6* (s/? valid-kr?*) :gain7* (s/? valid-kr?*) :gain8* (s/? valid-kr?*) :gain9* (s/? valid-kr?*) :gain10* (s/? valid-kr?*) :gain11* (s/? valid-kr?*) :gain12* (s/? valid-kr?*) :gain13* (s/? valid-kr?*) :gain14* (s/? valid-kr?*) :gain15* (s/? valid-kr?*) :gain16* (s/? valid-kr?*) ))
(stest/instrument `trshift)

(defn chuap
  {:arglists '([kL kR2 kC3 kG kGa kGb kE kC8 iI9 iV10 iV11 ktime_step])}
  [L R2 C3 G Ga Gb E C8 I9 V10 V11 time_step]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "chuap"
                      [L R2 C3 G Ga Gb E C8 I9 V10 V11 time_step]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef chuap
  :args (s/cat :L valid-kr? :R2 valid-kr? :C3 valid-kr? :G valid-kr? :Ga valid-kr? :Gb valid-kr? :E valid-kr? :C8 valid-kr? :I9 valid-i? :V10 valid-i? :V11 valid-i? :time_step valid-kr? ))
(stest/instrument `chuap)

(defn platerev
  {:arglists '([itabexcite itabouts kbndry iaspect istiff idecay iloss & aexcite1* aexcite2* aexcite3* aexcite4* aexcite5* aexcite6* aexcite7* aexcite8* aexcite9* aexcite10* aexcite11* aexcite12* aexcite13* aexcite14* aexcite15* aexcite16* aexcite17* aexcite18* aexcite19* aexcite20* aexcite21* aexcite22* aexcite23* aexcite24* aexcite25* aexcite26* aexcite27* aexcite28* aexcite29* aexcite30* aexcite31* aexcite32*])}
  [tabexcite tabouts bndry aspect stiff decay loss & [ excite1* excite2* excite3* excite4* excite5* excite6* excite7* excite8* excite9* excite10* excite11* excite12* excite13* excite14* excite15* excite16* excite17* excite18* excite19* excite20* excite21* excite22* excite23* excite24* excite25* excite26* excite27* excite28* excite29* excite30* excite31* excite32* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "platerev"
                      [tabexcite tabouts bndry aspect stiff decay loss excite1* excite2* excite3* excite4* excite5* excite6* excite7* excite8* excite9* excite10* excite11* excite12* excite13* excite14* excite15* excite16* excite17* excite18* excite19* excite20* excite21* excite22* excite23* excite24* excite25* excite26* excite27* excite28* excite29* excite30* excite31* excite32*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef platerev
  :args (s/cat :tabexcite valid-i? :tabouts valid-i? :bndry valid-kr? :aspect valid-i? :stiff valid-i? :decay valid-i? :loss valid-i? :excite1* (s/? valid-ar?*) :excite2* (s/? valid-ar?*) :excite3* (s/? valid-ar?*) :excite4* (s/? valid-ar?*) :excite5* (s/? valid-ar?*) :excite6* (s/? valid-ar?*) :excite7* (s/? valid-ar?*) :excite8* (s/? valid-ar?*) :excite9* (s/? valid-ar?*) :excite10* (s/? valid-ar?*) :excite11* (s/? valid-ar?*) :excite12* (s/? valid-ar?*) :excite13* (s/? valid-ar?*) :excite14* (s/? valid-ar?*) :excite15* (s/? valid-ar?*) :excite16* (s/? valid-ar?*) :excite17* (s/? valid-ar?*) :excite18* (s/? valid-ar?*) :excite19* (s/? valid-ar?*) :excite20* (s/? valid-ar?*) :excite21* (s/? valid-ar?*) :excite22* (s/? valid-ar?*) :excite23* (s/? valid-ar?*) :excite24* (s/? valid-ar?*) :excite25* (s/? valid-ar?*) :excite26* (s/? valid-ar?*) :excite27* (s/? valid-ar?*) :excite28* (s/? valid-ar?*) :excite29* (s/? valid-ar?*) :excite30* (s/? valid-ar?*) :excite31* (s/? valid-ar?*) :excite32* (s/? valid-ar?*) ))
(stest/instrument `platerev)

(defn noteon
  {:arglists '([ichn inum ivel])}
  [chn num vel]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "noteon"
                      [chn num vel]
                      *global*)]
    (new out-types ast)))

(s/fdef noteon
  :args (s/cat :chn valid-i? :num valid-i? :vel valid-i? ))
(stest/instrument `noteon)

(defn fprintks
  {:arglists '([Sfilename Sstring & xval1* xval2* xval3* xval4* xval5* xval6* xval7* xval8* xval9* xval10* xval11* xval12* xval13* xval14* xval15* xval16*] [ifilename Sstring & xval1* xval2* xval3* xval4* xval5* xval6* xval7* xval8* xval9* xval10* xval11* xval12* xval13* xval14* xval15* xval16*] [Sfilename Sstring & xval1* xval2* xval3* xval4* xval5* xval6* xval7* xval8* xval9* xval10* xval11* xval12* xval13* xval14* xval15* xval16*] [ifilename Sstring & xval1* xval2* xval3* xval4* xval5* xval6* xval7* xval8* xval9* xval10* xval11* xval12* xval13* xval14* xval15* xval16*])}
  [filename string & [ val1* val2* val3* val4* val5* val6* val7* val8* val9* val10* val11* val12* val13* val14* val15* val16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "fprintks"
                      [filename string val1* val2* val3* val4* val5* val6* val7* val8* val9* val10* val11* val12* val13* val14* val15* val16*]
                      *global*)]
    (new out-types ast)))

(s/fdef fprintks
  :args (s/alt
         :iSxxxxxxxxxxxxxxxx (s/cat :filename valid-i? :string valid-S? :val1* (s/? valid-x?*) :val2* (s/? valid-x?*) :val3* (s/? valid-x?*) :val4* (s/? valid-x?*) :val5* (s/? valid-x?*) :val6* (s/? valid-x?*) :val7* (s/? valid-x?*) :val8* (s/? valid-x?*) :val9* (s/? valid-x?*) :val10* (s/? valid-x?*) :val11* (s/? valid-x?*) :val12* (s/? valid-x?*) :val13* (s/? valid-x?*) :val14* (s/? valid-x?*) :val15* (s/? valid-x?*) :val16* (s/? valid-x?*) )
         :SSxxxxxxxxxxxxxxxx (s/cat :filename valid-S? :string valid-S? :val1* (s/? valid-x?*) :val2* (s/? valid-x?*) :val3* (s/? valid-x?*) :val4* (s/? valid-x?*) :val5* (s/? valid-x?*) :val6* (s/? valid-x?*) :val7* (s/? valid-x?*) :val8* (s/? valid-x?*) :val9* (s/? valid-x?*) :val10* (s/? valid-x?*) :val11* (s/? valid-x?*) :val12* (s/? valid-x?*) :val13* (s/? valid-x?*) :val14* (s/? valid-x?*) :val15* (s/? valid-x?*) :val16* (s/? valid-x?*) )
         ))
(stest/instrument `fprintks)

(defn envlpx
  {:arglists '([aamp irise idur idec itable iatss iatdec & ixmod*] [kamp irise idur idec itable iatss iatdec & ixmod*] [kamp irise idur idec itable iatss iatdec & ixmod*])}
  [amp rise dur dec table atss atdec & [ xmod* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "envlpx"
                      [amp rise dur dec table atss atdec xmod*]
                      *global*)]
    (new out-types ast)))

(s/fdef envlpx
  :args (s/alt
         :kiiiiiii (s/cat :amp valid-kr? :rise valid-i? :dur valid-i? :dec valid-i? :table valid-i? :atss valid-i? :atdec valid-i? :xmod* (s/? valid-i?*) )
         :aiiiiiii (s/cat :amp valid-ar? :rise valid-i? :dur valid-i? :dec valid-i? :table valid-i? :atss valid-i? :atdec valid-i? :xmod* (s/? valid-i?*) )
         ))
(stest/instrument `envlpx)

(defn envlpx:a
  {:arglists '([aamp irise idur idec itable iatss iatdec & ixmod*] [kamp irise idur idec itable iatss iatdec & ixmod*])}
  [amp rise dur dec table atss atdec & [ xmod* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "envlpx"
                      [amp rise dur dec table atss atdec xmod*]
                      *global*)]
    (new out-types ast)))

(s/fdef envlpx:a
  :args (s/alt
         :kiiiiiii (s/cat :amp valid-kr? :rise valid-i? :dur valid-i? :dec valid-i? :table valid-i? :atss valid-i? :atdec valid-i? :xmod* (s/? valid-i?*) )
         :aiiiiiii (s/cat :amp valid-ar? :rise valid-i? :dur valid-i? :dec valid-i? :table valid-i? :atss valid-i? :atdec valid-i? :xmod* (s/? valid-i?*) )
         ))
(stest/instrument `envlpx:a)

(defn envlpx:k
  {:arglists '([kamp irise idur idec itable iatss iatdec & ixmod*])}
  [amp rise dur dec table atss atdec & [ xmod* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "envlpx"
                      [amp rise dur dec table atss atdec xmod*]
                      *global*)]
    (new out-types ast)))

(s/fdef envlpx:k
  :args (s/cat :amp valid-kr? :rise valid-i? :dur valid-i? :dec valid-i? :table valid-i? :atss valid-i? :atdec valid-i? :xmod* (s/? valid-i?*) ))
(stest/instrument `envlpx:k)

(defn follow2
  {:arglists '([asig katt krel])}
  [sig att rel]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "follow2"
                      [sig att rel]
                      *global*)]
    (new out-types ast)))

(s/fdef follow2
  :args (s/cat :sig valid-ar? :att valid-kr? :rel valid-kr? ))
(stest/instrument `follow2)

(defn vdelayxwq
  {:arglists '([ain1 ain2 ain3 ain4 adl imd iws & ist*])}
  [in1 in2 in3 in4 dl md ws & [ st* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "vdelayxwq"
                      [in1 in2 in3 in4 dl md ws st*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef vdelayxwq
  :args (s/cat :in1 valid-ar? :in2 valid-ar? :in3 valid-ar? :in4 valid-ar? :dl valid-ar? :md valid-i? :ws valid-i? :st* (s/? valid-i?*) ))
(stest/instrument `vdelayxwq)

(defn pcauchy
  {:arglists '([kalpha] [kalpha] [kalpha])}
  [alpha]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "pcauchy"
                      [alpha]
                      *global*)]
    (new out-types ast)))

(s/fdef pcauchy
  :args (s/alt
         :k (s/cat :alpha valid-kr? )
         ))
(stest/instrument `pcauchy)

(defn pcauchy:a
  {:arglists '([kalpha])}
  [alpha]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "pcauchy"
                      [alpha]
                      *global*)]
    (new out-types ast)))

(s/fdef pcauchy:a
  :args (s/cat :alpha valid-kr? ))
(stest/instrument `pcauchy:a)

(defn pcauchy:i
  {:arglists '([kalpha])}
  [alpha]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "pcauchy"
                      [alpha]
                      *global*)]
    (new out-types ast)))

(s/fdef pcauchy:i
  :args (s/cat :alpha valid-kr? ))
(stest/instrument `pcauchy:i)

(defn pcauchy:k
  {:arglists '([kalpha])}
  [alpha]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "pcauchy"
                      [alpha]
                      *global*)]
    (new out-types ast)))

(s/fdef pcauchy:k
  :args (s/cat :alpha valid-kr? ))
(stest/instrument `pcauchy:k)

(defn MixerSend
  {:arglists '([asignal isend ibuss ichannel])}
  [signal send buss channel]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "MixerSend"
                      [signal send buss channel]
                      *global*)]
    (new out-types ast)))

(s/fdef MixerSend
  :args (s/cat :signal valid-ar? :send valid-i? :buss valid-i? :channel valid-i? ))
(stest/instrument `MixerSend)

(defn imagegetpixel
  {:arglists '([iimagenum xx xy])}
  [imagenum x y]
  (let [out-types-quoted '[ControlSignal ControlSignal ControlSignal]
        out-types [ControlSignal ControlSignal ControlSignal]
        ast (ast-node out-types-quoted
                      "imagegetpixel"
                      [imagenum x y]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef imagegetpixel
  :args (s/cat :imagenum valid-i? :x valid-x? :y valid-x? ))
(stest/instrument `imagegetpixel)

(defn mediank
  {:arglists '([kin ksize imaxsize & iskip*])}
  [in size maxsize & [ skip* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "mediank"
                      [in size maxsize skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef mediank
  :args (s/cat :in valid-kr? :size valid-kr? :maxsize valid-i? :skip* (s/? valid-i?*) ))
(stest/instrument `mediank)

(defn pvshift
  {:arglists '([fsigin kshift klowest & kkeepform* kgain* kcoefs*] [fsigin xshift klowest & kkeepform* kgain* kcoefs*])}
  [sigin shift lowest & [ keepform* gain* coefs* ]]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvshift"
                      [sigin shift lowest keepform* gain* coefs*]
                      *global*)]
    (new out-types ast)))

(s/fdef pvshift
  :args (s/alt
         :fxkkkk (s/cat :sigin valid-f? :shift valid-x? :lowest valid-kr? :keepform* (s/? valid-kr?*) :gain* (s/? valid-kr?*) :coefs* (s/? valid-kr?*) )
         :fkkkkk (s/cat :sigin valid-f? :shift valid-kr? :lowest valid-kr? :keepform* (s/? valid-kr?*) :gain* (s/? valid-kr?*) :coefs* (s/? valid-kr?*) )
         ))
(stest/instrument `pvshift)

(defn ATSread
  {:arglists '([ktimepnt Satsfile ipartial] [ktimepnt iatsfile ipartial])}
  [timepnt atsfile partial]
  (let [out-types-quoted '[ControlSignal ControlSignal]
        out-types [ControlSignal ControlSignal]
        ast (ast-node out-types-quoted
                      "ATSread"
                      [timepnt atsfile partial]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef ATSread
  :args (s/alt
         :kii (s/cat :timepnt valid-kr? :atsfile valid-i? :partial valid-i? )
         :kSi (s/cat :timepnt valid-kr? :atsfile valid-S? :partial valid-i? )
         ))
(stest/instrument `ATSread)

(defn waveset
  {:arglists '([ain krep & ilen*])}
  [in rep & [ len* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "waveset"
                      [in rep len*]
                      *global*)]
    (new out-types ast)))

(s/fdef waveset
  :args (s/cat :in valid-ar? :rep valid-kr? :len* (s/? valid-i?*) ))
(stest/instrument `waveset)

(defn mvclpf1
  {:arglists '([ain acenter-frequency aresonance & istor*] [ain acenter-frequency kresonance & istor*] [ain kcenter-frequency aresonance & istor*] [ain kcenter-frequency kresonance & istor*])}
  [in center-frequency resonance & [ stor* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "mvclpf1"
                      [in center-frequency resonance stor*]
                      *global*)]
    (new out-types ast)))

(s/fdef mvclpf1
  :args (s/alt
         :akki (s/cat :in valid-ar? :center-frequency valid-kr? :resonance valid-kr? :stor* (s/? valid-i?*) )
         :akai (s/cat :in valid-ar? :center-frequency valid-kr? :resonance valid-ar? :stor* (s/? valid-i?*) )
         :aaki (s/cat :in valid-ar? :center-frequency valid-ar? :resonance valid-kr? :stor* (s/? valid-i?*) )
         :aaai (s/cat :in valid-ar? :center-frequency valid-ar? :resonance valid-ar? :stor* (s/? valid-i?*) )
         ))
(stest/instrument `mvclpf1)

(defn tab2pvs
  {:arglists '([kmagsArr kfreqsArr & ihopsize* iwinsize* iwintype*] [kmagsArr & ifreqs* ihopsize* iwinsize*])}
  [mags freqs & [ hopsize* winsize* wintype* ]]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "tab2pvs"
                      [mags freqs hopsize* winsize* wintype*]
                      *global*)]
    (new out-types ast)))

(s/fdef tab2pvs
  :args (s/alt
         :kArriii (s/cat :mags valid-kArr? :freqs* (s/? valid-i?*) :hopsize* (s/? valid-i?*) :winsize* (s/? valid-i?*) )
         :kArrkArriii (s/cat :mags valid-kArr? :freqs valid-kArr? :hopsize* (s/? valid-i?*) :winsize* (s/? valid-i?*) :wintype* (s/? valid-i?*) )
         ))
(stest/instrument `tab2pvs)

(defn vadd
  {:arglists '([itable kval kelements & kdstoffset* kverbose*])}
  [table val elements & [ dstoffset* verbose* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vadd"
                      [table val elements dstoffset* verbose*]
                      *global*)]
    (new out-types ast)))

(s/fdef vadd
  :args (s/cat :table valid-i? :val valid-kr? :elements valid-kr? :dstoffset* (s/? valid-kr?*) :verbose* (s/? valid-kr?*) ))
(stest/instrument `vadd)

(defn pvsbufread
  {:arglists '([ktime khandle & klo* khi* iclear*])}
  [time handle & [ lo* hi* clear* ]]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvsbufread"
                      [time handle lo* hi* clear*]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsbufread
  :args (s/cat :time valid-kr? :handle valid-kr? :lo* (s/? valid-kr?*) :hi* (s/? valid-kr?*) :clear* (s/? valid-i?*) ))
(stest/instrument `pvsbufread)

(defn imagesave
  {:arglists '([iimagenum Silename])}
  [imagenum ilename]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "imagesave"
                      [imagenum ilename]
                      *global*)]
    (new out-types ast)))

(s/fdef imagesave
  :args (s/cat :imagenum valid-i? :ilename valid-S? ))
(stest/instrument `imagesave)

(defn tablera
  {:arglists '([ktable kstart koff])}
  [table start off]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "tablera"
                      [table start off]
                      *global*)]
    (new out-types ast)))

(s/fdef tablera
  :args (s/cat :table valid-kr? :start valid-kr? :off valid-kr? ))
(stest/instrument `tablera)

(defn midictrl
  {:arglists '([inum & imin* imax*] [inum & imin* imax*])}
  [num & [ min* max* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "midictrl"
                      [num min* max*]
                      *global*)]
    (new out-types ast)))

(s/fdef midictrl
  :args (s/alt
         :iii (s/cat :num valid-i? :min* (s/? valid-i?*) :max* (s/? valid-i?*) )
         ))
(stest/instrument `midictrl)

(defn midictrl:i
  {:arglists '([inum & imin* imax*])}
  [num & [ min* max* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "midictrl"
                      [num min* max*]
                      *global*)]
    (new out-types ast)))

(s/fdef midictrl:i
  :args (s/cat :num valid-i? :min* (s/? valid-i?*) :max* (s/? valid-i?*) ))
(stest/instrument `midictrl:i)

(defn midictrl:k
  {:arglists '([inum & imin* imax*])}
  [num & [ min* max* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "midictrl"
                      [num min* max*]
                      *global*)]
    (new out-types ast)))

(s/fdef midictrl:k
  :args (s/cat :num valid-i? :min* (s/? valid-i?*) :max* (s/? valid-i?*) ))
(stest/instrument `midictrl:k)

(defn bbcuts
  {:arglists '([asource1 asource2 ibps isubdiv ibarlength iphrasebars inumrepeats & istutterspeed* istutterchance* ienvchoice*])}
  [source1 source2 bps subdiv barlength phrasebars numrepeats & [ stutterspeed* stutterchance* envchoice* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "bbcuts"
                      [source1 source2 bps subdiv barlength phrasebars numrepeats stutterspeed* stutterchance* envchoice*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef bbcuts
  :args (s/cat :source1 valid-ar? :source2 valid-ar? :bps valid-i? :subdiv valid-i? :barlength valid-i? :phrasebars valid-i? :numrepeats valid-i? :stutterspeed* (s/? valid-i?*) :stutterchance* (s/? valid-i?*) :envchoice* (s/? valid-i?*) ))
(stest/instrument `bbcuts)

(defn loopsegp
  {:arglists '([kphase & kvalue1* kdur2* kvalue3* kdur4* kdurN-5* kvalueN6* kvalueN7* kvalueN8* kvalueN9* kvalueN10* kvalueN11* kvalueN12* kvalueN13* kvalueN14* kvalueN15* kvalueN16*])}
  [phase & [ value1* dur2* value3* dur4* durN-5* valueN6* valueN7* valueN8* valueN9* valueN10* valueN11* valueN12* valueN13* valueN14* valueN15* valueN16* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "loopsegp"
                      [phase value1* dur2* value3* dur4* durN-5* valueN6* valueN7* valueN8* valueN9* valueN10* valueN11* valueN12* valueN13* valueN14* valueN15* valueN16*]
                      *global*)]
    (new out-types ast)))

(s/fdef loopsegp
  :args (s/cat :phase valid-kr? :value1* (s/? valid-kr?*) :dur2* (s/? valid-kr?*) :value3* (s/? valid-kr?*) :dur4* (s/? valid-kr?*) :durN-5* (s/? valid-kr?*) :valueN6* (s/? valid-kr?*) :valueN7* (s/? valid-kr?*) :valueN8* (s/? valid-kr?*) :valueN9* (s/? valid-kr?*) :valueN10* (s/? valid-kr?*) :valueN11* (s/? valid-kr?*) :valueN12* (s/? valid-kr?*) :valueN13* (s/? valid-kr?*) :valueN14* (s/? valid-kr?*) :valueN15* (s/? valid-kr?*) :valueN16* (s/? valid-kr?*) ))
(stest/instrument `loopsegp)

(defn printks
  {:arglists '([Sstring itime & xval1* xval2* xval3* xval4* xval5* xval6* xval7* xval8* xval9* xval10* xval11* xval12* xval13* xval14* xval15* xval16*] [istring itime & xval1* xval2* xval3* xval4* xval5* xval6* xval7* xval8* xval9* xval10* xval11* xval12* xval13* xval14* xval15* xval16*])}
  [string time & [ val1* val2* val3* val4* val5* val6* val7* val8* val9* val10* val11* val12* val13* val14* val15* val16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "printks"
                      [string time val1* val2* val3* val4* val5* val6* val7* val8* val9* val10* val11* val12* val13* val14* val15* val16*]
                      *global*)]
    (new out-types ast)))

(s/fdef printks
  :args (s/alt
         :iixxxxxxxxxxxxxxxx (s/cat :string valid-i? :time valid-i? :val1* (s/? valid-x?*) :val2* (s/? valid-x?*) :val3* (s/? valid-x?*) :val4* (s/? valid-x?*) :val5* (s/? valid-x?*) :val6* (s/? valid-x?*) :val7* (s/? valid-x?*) :val8* (s/? valid-x?*) :val9* (s/? valid-x?*) :val10* (s/? valid-x?*) :val11* (s/? valid-x?*) :val12* (s/? valid-x?*) :val13* (s/? valid-x?*) :val14* (s/? valid-x?*) :val15* (s/? valid-x?*) :val16* (s/? valid-x?*) )
         :Sixxxxxxxxxxxxxxxx (s/cat :string valid-S? :time valid-i? :val1* (s/? valid-x?*) :val2* (s/? valid-x?*) :val3* (s/? valid-x?*) :val4* (s/? valid-x?*) :val5* (s/? valid-x?*) :val6* (s/? valid-x?*) :val7* (s/? valid-x?*) :val8* (s/? valid-x?*) :val9* (s/? valid-x?*) :val10* (s/? valid-x?*) :val11* (s/? valid-x?*) :val12* (s/? valid-x?*) :val13* (s/? valid-x?*) :val14* (s/? valid-x?*) :val15* (s/? valid-x?*) :val16* (s/? valid-x?*) )
         ))
(stest/instrument `printks)

(defn zamod
  {:arglists '([asig kzamod])}
  [sig zamod]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "zamod"
                      [sig zamod]
                      *global*)]
    (new out-types ast)))

(s/fdef zamod
  :args (s/cat :sig valid-ar? :zamod valid-kr? ))
(stest/instrument `zamod)

(defn lorenz
  {:arglists '([ksv krv kbv kh ix iy iz iskip & iskipinit*])}
  [sv rv bv h x y z skip & [ skipinit* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "lorenz"
                      [sv rv bv h x y z skip skipinit*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef lorenz
  :args (s/cat :sv valid-kr? :rv valid-kr? :bv valid-kr? :h valid-kr? :x valid-i? :y valid-i? :z valid-i? :skip valid-i? :skipinit* (s/? valid-i?*) ))
(stest/instrument `lorenz)

(defn pchmidib
  {:arglists '([& irange*] [& irange*])}
  [& [ range* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "pchmidib"
                      [range*]
                      *global*)]
    (new out-types ast)))

(s/fdef pchmidib
  :args (s/alt
         :i (s/cat :range* (s/? valid-i?*) )
         ))
(stest/instrument `pchmidib)

(defn pchmidib:i
  {:arglists '([& irange*])}
  [& [ range* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "pchmidib"
                      [range*]
                      *global*)]
    (new out-types ast)))

(s/fdef pchmidib:i
  :args (s/cat :range* (s/? valid-i?*) ))
(stest/instrument `pchmidib:i)

(defn pchmidib:k
  {:arglists '([& irange*])}
  [& [ range* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "pchmidib"
                      [range*]
                      *global*)]
    (new out-types ast)))

(s/fdef pchmidib:k
  :args (s/cat :range* (s/? valid-i?*) ))
(stest/instrument `pchmidib:k)

(defn strchar
  {:arglists '([Sstr & ipos*])}
  [str & [ pos* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "strchar"
                      [str pos*]
                      *global*)]
    (new out-types ast)))

(s/fdef strchar
  :args (s/cat :str valid-S? :pos* (s/? valid-i?*) ))
(stest/instrument `strchar)

(defn interp
  {:arglists '([ksig & iskip* imode* ivalue*])}
  [sig & [ skip* mode* value* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "interp"
                      [sig skip* mode* value*]
                      *global*)]
    (new out-types ast)))

(s/fdef interp
  :args (s/cat :sig valid-kr? :skip* (s/? valid-i?*) :mode* (s/? valid-i?*) :value* (s/? valid-i?*) ))
(stest/instrument `interp)

(defn temposcal
  {:arglists '([ktimescal kamp kpitch ktab klock & ifftsize* idecim* kthresh* kthresh* kthresh*])}
  [timescal amp pitch tab lock & [ fftsize* decim* thresh* thresh* thresh* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "temposcal"
                      [timescal amp pitch tab lock fftsize* decim* thresh* thresh* thresh*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef temposcal
  :args (s/cat :timescal valid-kr? :amp valid-kr? :pitch valid-kr? :tab valid-kr? :lock valid-kr? :fftsize* (s/? valid-i?*) :decim* (s/? valid-i?*) :thresh* (s/? valid-kr?*) :thresh* (s/? valid-kr?*) :thresh* (s/? valid-kr?*) ))
(stest/instrument `temposcal)

(defn pvsosc
  {:arglists '([kamp kfreq ktype isize & ioverlap* iwinsize* iwintype* iformat*])}
  [amp freq type size & [ overlap* winsize* wintype* format* ]]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvsosc"
                      [amp freq type size overlap* winsize* wintype* format*]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsosc
  :args (s/cat :amp valid-kr? :freq valid-kr? :type valid-kr? :size valid-i? :overlap* (s/? valid-i?*) :winsize* (s/? valid-i?*) :wintype* (s/? valid-i?*) :format* (s/? valid-i?*) ))
(stest/instrument `pvsosc)

(defn noise
  {:arglists '([xamp kbeta])}
  [amp beta]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "noise"
                      [amp beta]
                      *global*)]
    (new out-types ast)))

(s/fdef noise
  :args (s/cat :amp valid-x? :beta valid-kr? ))
(stest/instrument `noise)

(defn fftinv
  {:arglists '([iinArr] [kinArr])}
  [in]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "fftinv"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef fftinv
  :args (s/alt
         :kArr (s/cat :in valid-kArr? )
         :iArr (s/cat :in valid-iArr? )
         ))
(stest/instrument `fftinv)

(defn fftinv:iArr
  {:arglists '([iinArr])}
  [in]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "fftinv"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef fftinv:iArr
  :args (s/cat :in valid-iArr? ))
(stest/instrument `fftinv:iArr)

(defn fftinv:kArr
  {:arglists '([kinArr])}
  [in]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "fftinv"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef fftinv:kArr
  :args (s/cat :in valid-kArr? ))
(stest/instrument `fftinv:kArr)

(defn diff
  {:arglists '([xsig & iskip*] [xsig & iskip*])}
  [sig & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "diff"
                      [sig skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef diff
  :args (s/alt
         :xi (s/cat :sig valid-x? :skip* (s/? valid-i?*) )
         ))
(stest/instrument `diff)

(defn diff:a
  {:arglists '([xsig & iskip*])}
  [sig & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "diff"
                      [sig skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef diff:a
  :args (s/cat :sig valid-x? :skip* (s/? valid-i?*) ))
(stest/instrument `diff:a)

(defn diff:k
  {:arglists '([xsig & iskip*])}
  [sig & [ skip* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "diff"
                      [sig skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef diff:k
  :args (s/cat :sig valid-x? :skip* (s/? valid-i?*) ))
(stest/instrument `diff:k)

(defn chnexport
  {:arglists '([Sname imode] [Sname imode] [Sname imode & imode* imode* imode* imode*] [Sname imode & imode* imode* imode* imode*])}
  [name mode]
  (let [out-types-quoted 'String
        out-types String
        ast (ast-node out-types-quoted
                      "chnexport"
                      [name mode]
                      *global*)]
    (new out-types ast)))

(s/fdef chnexport
  :args (s/alt
         :Siiiii (s/cat :name valid-S? :mode valid-i? :mode* (s/? valid-i?*) :mode* (s/? valid-i?*) :mode* (s/? valid-i?*) :mode* (s/? valid-i?*) )
         :Si (s/cat :name valid-S? :mode valid-i? )
         ))
(stest/instrument `chnexport)

(defn chnexport:S
  {:arglists '([Sname imode])}
  [name mode]
  (let [out-types-quoted 'String
        out-types String
        ast (ast-node out-types-quoted
                      "chnexport"
                      [name mode]
                      *global*)]
    (new out-types ast)))

(s/fdef chnexport:S
  :args (s/cat :name valid-S? :mode valid-i? ))
(stest/instrument `chnexport:S)

(defn chnexport:a
  {:arglists '([Sname imode])}
  [name mode]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "chnexport"
                      [name mode]
                      *global*)]
    (new out-types ast)))

(s/fdef chnexport:a
  :args (s/cat :name valid-S? :mode valid-i? ))
(stest/instrument `chnexport:a)

(defn chnexport:i
  {:arglists '([Sname imode & imode* imode* imode* imode*])}
  [name mode & [ mode* mode* mode* mode* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "chnexport"
                      [name mode mode* mode* mode* mode*]
                      *global*)]
    (new out-types ast)))

(s/fdef chnexport:i
  :args (s/cat :name valid-S? :mode valid-i? :mode* (s/? valid-i?*) :mode* (s/? valid-i?*) :mode* (s/? valid-i?*) :mode* (s/? valid-i?*) ))
(stest/instrument `chnexport:i)

(defn chnexport:k
  {:arglists '([Sname imode & imode* imode* imode* imode*])}
  [name mode & [ mode* mode* mode* mode* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "chnexport"
                      [name mode mode* mode* mode* mode*]
                      *global*)]
    (new out-types ast)))

(s/fdef chnexport:k
  :args (s/cat :name valid-S? :mode valid-i? :mode* (s/? valid-i?*) :mode* (s/? valid-i?*) :mode* (s/? valid-i?*) :mode* (s/? valid-i?*) ))
(stest/instrument `chnexport:k)

(defn OSClisten
  {:arglists '([ihandle Sdest Stype] [ihandle Sdest Stype & xdata1* xdata2* xdata3* xdata4* xdata5* xdata6* xdata7* xdata8* xdata9* xdata10* xdata11* xdata12* xdata13* xdata14* xdata15* xdata16*])}
  [handle dest type]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "OSClisten"
                      [handle dest type]
                      *global*)]
    (new out-types ast)))

(s/fdef OSClisten
  :args (s/alt
         :iSSxxxxxxxxxxxxxxxx (s/cat :handle valid-i? :dest valid-S? :type valid-S? :data1* (s/? valid-x?*) :data2* (s/? valid-x?*) :data3* (s/? valid-x?*) :data4* (s/? valid-x?*) :data5* (s/? valid-x?*) :data6* (s/? valid-x?*) :data7* (s/? valid-x?*) :data8* (s/? valid-x?*) :data9* (s/? valid-x?*) :data10* (s/? valid-x?*) :data11* (s/? valid-x?*) :data12* (s/? valid-x?*) :data13* (s/? valid-x?*) :data14* (s/? valid-x?*) :data15* (s/? valid-x?*) :data16* (s/? valid-x?*) )
         :iSS (s/cat :handle valid-i? :dest valid-S? :type valid-S? )
         ))
(stest/instrument `OSClisten)

(defn pvsadsyn
  {:arglists '([fsrc inoscs kfmod & ibinoffset* ibinincr* iinit*])}
  [src noscs fmod & [ binoffset* binincr* init* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "pvsadsyn"
                      [src noscs fmod binoffset* binincr* init*]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsadsyn
  :args (s/cat :src valid-f? :noscs valid-i? :fmod valid-kr? :binoffset* (s/? valid-i?*) :binincr* (s/? valid-i?*) :init* (s/? valid-i?*) ))
(stest/instrument `pvsadsyn)

(defn checkbox
  {:arglists '([knum])}
  [num]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "checkbox"
                      [num]
                      *global*)]
    (new out-types ast)))

(s/fdef checkbox
  :args (s/cat :num valid-kr? ))
(stest/instrument `checkbox)

(defn puts
  {:arglists '([Sstr ktrig & inonl*])}
  [str trig & [ nonl* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "puts"
                      [str trig nonl*]
                      *global*)]
    (new out-types ast)))

(s/fdef puts
  :args (s/cat :str valid-S? :trig valid-kr? :nonl* (s/? valid-i?*) ))
(stest/instrument `puts)

(defn pcount
  {:arglists '()}
  []
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "pcount"
                      []
                      *global*)]
    (new out-types ast)))


(defn lposcilsa2
  {:arglists '([aamp kfreqratio kloop kend ift & iphase*])}
  [amp freqratio loop end ft & [ phase* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "lposcilsa2"
                      [amp freqratio loop end ft phase*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef lposcilsa2
  :args (s/cat :amp valid-ar? :freqratio valid-kr? :loop valid-kr? :end valid-kr? :ft valid-i? :phase* (s/? valid-i?*) ))
(stest/instrument `lposcilsa2)

(defn diskin
  {:arglists '([Sfilcod & kpitch* iskiptim* iwraparound* iformat* iskipinit* iskipinit* iskipinit* iskipinit*] [ifilcod & kpitch* iskiptim* iwraparound* iformat* iskipinit* iskipinit* iskipinit* iskipinit*] [Sfilcod & kpitch* iskiptim* iwraparound* iformat* iskipinit* iskipinit* iskipinit* iskipinit*] [ifilcod & kpitch* iskiptim* iwraparound* iformat* iskipinit* iskipinit* iskipinit* iskipinit*])}
  [filcod & [ pitch* skiptim* wraparound* format* skipinit* skipinit* skipinit* skipinit* ]]
  (let [out-types-quoted 'AudioArray
        out-types AudioArray
        ast (ast-node out-types-quoted
                      "diskin"
                      [filcod pitch* skiptim* wraparound* format* skipinit* skipinit* skipinit* skipinit*]
                      *global*)]
    (new out-types ast)))

(s/fdef diskin
  :args (s/alt
         :ikiiiiiii (s/cat :filcod valid-i? :pitch* (s/? valid-kr?*) :skiptim* (s/? valid-i?*) :wraparound* (s/? valid-i?*) :format* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :skipinit* (s/? valid-i?*) )
         :Skiiiiiii (s/cat :filcod valid-S? :pitch* (s/? valid-kr?*) :skiptim* (s/? valid-i?*) :wraparound* (s/? valid-i?*) :format* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :skipinit* (s/? valid-i?*) )
         ))
(stest/instrument `diskin)

(defn diskin:aArr
  {:arglists '([Sfilcod & kpitch* iskiptim* iwraparound* iformat* iskipinit* iskipinit* iskipinit* iskipinit*] [ifilcod & kpitch* iskiptim* iwraparound* iformat* iskipinit* iskipinit* iskipinit* iskipinit*])}
  [filcod & [ pitch* skiptim* wraparound* format* skipinit* skipinit* skipinit* skipinit* ]]
  (let [out-types-quoted 'AudioArray
        out-types AudioArray
        ast (ast-node out-types-quoted
                      "diskin"
                      [filcod pitch* skiptim* wraparound* format* skipinit* skipinit* skipinit* skipinit*]
                      *global*)]
    (new out-types ast)))

(s/fdef diskin:aArr
  :args (s/alt
         :ikiiiiiii (s/cat :filcod valid-i? :pitch* (s/? valid-kr?*) :skiptim* (s/? valid-i?*) :wraparound* (s/? valid-i?*) :format* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :skipinit* (s/? valid-i?*) )
         :Skiiiiiii (s/cat :filcod valid-S? :pitch* (s/? valid-kr?*) :skiptim* (s/? valid-i?*) :wraparound* (s/? valid-i?*) :format* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :skipinit* (s/? valid-i?*) )
         ))
(stest/instrument `diskin:aArr)

(defn diskin:a
  {:arglists '([Sfilcod & kpitch* iskiptim* iwraparound* iformat* iskipinit* iskipinit* iskipinit* iskipinit*] [ifilcod & kpitch* iskiptim* iwraparound* iformat* iskipinit* iskipinit* iskipinit* iskipinit*])}
  [filcod & [ pitch* skiptim* wraparound* format* skipinit* skipinit* skipinit* skipinit* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "diskin"
                      [filcod pitch* skiptim* wraparound* format* skipinit* skipinit* skipinit* skipinit*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef diskin:a
  :args (s/alt
         :ikiiiiiii (s/cat :filcod valid-i? :pitch* (s/? valid-kr?*) :skiptim* (s/? valid-i?*) :wraparound* (s/? valid-i?*) :format* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :skipinit* (s/? valid-i?*) )
         :Skiiiiiii (s/cat :filcod valid-S? :pitch* (s/? valid-kr?*) :skiptim* (s/? valid-i?*) :wraparound* (s/? valid-i?*) :format* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :skipinit* (s/? valid-i?*) )
         ))
(stest/instrument `diskin:a)

(defn outs2
  {:arglists '([asig])}
  [sig]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outs2"
                      [sig]
                      *global*)]
    (new out-types ast)))

(s/fdef outs2
  :args (s/cat :sig valid-ar? ))
(stest/instrument `outs2)

(defn midiarp
  {:arglists '([kRate & kMode*])}
  [Rate & [ Mode* ]]
  (let [out-types-quoted '[ControlSignal ControlSignal]
        out-types [ControlSignal ControlSignal]
        ast (ast-node out-types-quoted
                      "midiarp"
                      [Rate Mode*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef midiarp
  :args (s/cat :Rate valid-kr? :Mode* (s/? valid-kr?*) ))
(stest/instrument `midiarp)

(defn OSCsend
  {:arglists '([kwhen Shost kport Sdestination Stype & xdata1* xdata2* xdata3* xdata4* xdata5* xdata6* xdata7* xdata8* xdata9* xdata10* xdata11* xdata12* xdata13* xdata14* xdata15* xdata16*])}
  [when host port destination type & [ data1* data2* data3* data4* data5* data6* data7* data8* data9* data10* data11* data12* data13* data14* data15* data16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "OSCsend"
                      [when host port destination type data1* data2* data3* data4* data5* data6* data7* data8* data9* data10* data11* data12* data13* data14* data15* data16*]
                      *global*)]
    (new out-types ast)))

(s/fdef OSCsend
  :args (s/cat :when valid-kr? :host valid-S? :port valid-kr? :destination valid-S? :type valid-S? :data1* (s/? valid-x?*) :data2* (s/? valid-x?*) :data3* (s/? valid-x?*) :data4* (s/? valid-x?*) :data5* (s/? valid-x?*) :data6* (s/? valid-x?*) :data7* (s/? valid-x?*) :data8* (s/? valid-x?*) :data9* (s/? valid-x?*) :data10* (s/? valid-x?*) :data11* (s/? valid-x?*) :data12* (s/? valid-x?*) :data13* (s/? valid-x?*) :data14* (s/? valid-x?*) :data15* (s/? valid-x?*) :data16* (s/? valid-x?*) ))
(stest/instrument `OSCsend)

(defn cuserrnd
  {:arglists '([kmin kmax ktableNum] [imin imax itableNum] [kmin kmax ktableNum])}
  [min max tableNum]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "cuserrnd"
                      [min max tableNum]
                      *global*)]
    (new out-types ast)))

(s/fdef cuserrnd
  :args (s/alt
         :iii (s/cat :min valid-i? :max valid-i? :tableNum valid-i? )
         :kkk (s/cat :min valid-kr? :max valid-kr? :tableNum valid-kr? )
         ))
(stest/instrument `cuserrnd)

(defn cuserrnd:a
  {:arglists '([kmin kmax ktableNum])}
  [min max tableNum]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "cuserrnd"
                      [min max tableNum]
                      *global*)]
    (new out-types ast)))

(s/fdef cuserrnd:a
  :args (s/cat :min valid-kr? :max valid-kr? :tableNum valid-kr? ))
(stest/instrument `cuserrnd:a)

(defn cuserrnd:i
  {:arglists '([imin imax itableNum])}
  [min max tableNum]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "cuserrnd"
                      [min max tableNum]
                      *global*)]
    (new out-types ast)))

(s/fdef cuserrnd:i
  :args (s/cat :min valid-i? :max valid-i? :tableNum valid-i? ))
(stest/instrument `cuserrnd:i)

(defn cuserrnd:k
  {:arglists '([kmin kmax ktableNum])}
  [min max tableNum]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "cuserrnd"
                      [min max tableNum]
                      *global*)]
    (new out-types ast)))

(s/fdef cuserrnd:k
  :args (s/cat :min valid-kr? :max valid-kr? :tableNum valid-kr? ))
(stest/instrument `cuserrnd:k)

(defn event
  {:arglists '([Sscorechar Sinsname & kdelay1* kdur2* kp3* kp4* kp5* kp6* kp7* kp8* kp9* kp10* kp11* kp12* kp13* kp14* kp15* kp16*] [Sscorechar kinsname & kdelay1* kdur2* kp3* kp4* kp5* kp6* kp7* kp8* kp9* kp10* kp11* kp12* kp13* kp14* kp15* kp16*])}
  [scorechar insname & [ delay1* dur2* p3* p4* p5* p6* p7* p8* p9* p10* p11* p12* p13* p14* p15* p16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "event"
                      [scorechar insname delay1* dur2* p3* p4* p5* p6* p7* p8* p9* p10* p11* p12* p13* p14* p15* p16*]
                      *global*)]
    (new out-types ast)))

(s/fdef event
  :args (s/alt
         :Skkkkkkkkkkkkkkkkk (s/cat :scorechar valid-S? :insname valid-kr? :delay1* (s/? valid-kr?*) :dur2* (s/? valid-kr?*) :p3* (s/? valid-kr?*) :p4* (s/? valid-kr?*) :p5* (s/? valid-kr?*) :p6* (s/? valid-kr?*) :p7* (s/? valid-kr?*) :p8* (s/? valid-kr?*) :p9* (s/? valid-kr?*) :p10* (s/? valid-kr?*) :p11* (s/? valid-kr?*) :p12* (s/? valid-kr?*) :p13* (s/? valid-kr?*) :p14* (s/? valid-kr?*) :p15* (s/? valid-kr?*) :p16* (s/? valid-kr?*) )
         :SSkkkkkkkkkkkkkkkk (s/cat :scorechar valid-S? :insname valid-S? :delay1* (s/? valid-kr?*) :dur2* (s/? valid-kr?*) :p3* (s/? valid-kr?*) :p4* (s/? valid-kr?*) :p5* (s/? valid-kr?*) :p6* (s/? valid-kr?*) :p7* (s/? valid-kr?*) :p8* (s/? valid-kr?*) :p9* (s/? valid-kr?*) :p10* (s/? valid-kr?*) :p11* (s/? valid-kr?*) :p12* (s/? valid-kr?*) :p13* (s/? valid-kr?*) :p14* (s/? valid-kr?*) :p15* (s/? valid-kr?*) :p16* (s/? valid-kr?*) )
         ))
(stest/instrument `event)

(defn nrpn
  {:arglists '([kchan kparmnum kparmvalue])}
  [chan parmnum parmvalue]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "nrpn"
                      [chan parmnum parmvalue]
                      *global*)]
    (new out-types ast)))

(s/fdef nrpn
  :args (s/cat :chan valid-kr? :parmnum valid-kr? :parmvalue valid-kr? ))
(stest/instrument `nrpn)

(defn exciter
  {:arglists '([asig kfreq kceil kharmonics kblend])}
  [sig freq ceil harmonics blend]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "exciter"
                      [sig freq ceil harmonics blend]
                      *global*)]
    (new out-types ast)))

(s/fdef exciter
  :args (s/cat :sig valid-ar? :freq valid-kr? :ceil valid-kr? :harmonics valid-kr? :blend valid-kr? ))
(stest/instrument `exciter)

(defn ftgenonce
  {:arglists '([ip1 ip2dummy isize Sgen Sarga & iargb1* iargb2* iargb3* iargb4* iargb5* iargb6* iargb7* iargb8* iargb9* iargb10* iargb11* iargb12* iargb13* iargb14* iargb15* iargb16*] [ip1 ip2dummy isize Sgen iarga & iargb1* iargb2* iargb3* iargb4* iargb5* iargb6* iargb7* iargb8* iargb9* iargb10* iargb11* iargb12* iargb13* iargb14* iargb15* iargb16*] [ip1 ip2dummy isize igen Sarga & iargb1* iargb2* iargb3* iargb4* iargb5* iargb6* iargb7* iargb8* iargb9* iargb10* iargb11* iargb12* iargb13* iargb14* iargb15* iargb16*] [ip1 ip2dummy isize igen iarga & iargb1* iargb2* iargb3* iargb4* iargb5* iargb6* iargb7* iargb8* iargb9* iargb10* iargb11* iargb12* iargb13* iargb14* iargb15* iargb16*])}
  [p1 p2dummy size gen arga & [ argb1* argb2* argb3* argb4* argb5* argb6* argb7* argb8* argb9* argb10* argb11* argb12* argb13* argb14* argb15* argb16* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "ftgenonce"
                      [p1 p2dummy size gen arga argb1* argb2* argb3* argb4* argb5* argb6* argb7* argb8* argb9* argb10* argb11* argb12* argb13* argb14* argb15* argb16*]
                      *global*)]
    (new out-types ast)))

(s/fdef ftgenonce
  :args (s/alt
         :iiiiiiiiiiiiiiiiiiiii (s/cat :p1 valid-i? :p2dummy valid-i? :size valid-i? :gen valid-i? :arga valid-i? :argb1* (s/? valid-i?*) :argb2* (s/? valid-i?*) :argb3* (s/? valid-i?*) :argb4* (s/? valid-i?*) :argb5* (s/? valid-i?*) :argb6* (s/? valid-i?*) :argb7* (s/? valid-i?*) :argb8* (s/? valid-i?*) :argb9* (s/? valid-i?*) :argb10* (s/? valid-i?*) :argb11* (s/? valid-i?*) :argb12* (s/? valid-i?*) :argb13* (s/? valid-i?*) :argb14* (s/? valid-i?*) :argb15* (s/? valid-i?*) :argb16* (s/? valid-i?*) )
         :iiiiSiiiiiiiiiiiiiiii (s/cat :p1 valid-i? :p2dummy valid-i? :size valid-i? :gen valid-i? :arga valid-S? :argb1* (s/? valid-i?*) :argb2* (s/? valid-i?*) :argb3* (s/? valid-i?*) :argb4* (s/? valid-i?*) :argb5* (s/? valid-i?*) :argb6* (s/? valid-i?*) :argb7* (s/? valid-i?*) :argb8* (s/? valid-i?*) :argb9* (s/? valid-i?*) :argb10* (s/? valid-i?*) :argb11* (s/? valid-i?*) :argb12* (s/? valid-i?*) :argb13* (s/? valid-i?*) :argb14* (s/? valid-i?*) :argb15* (s/? valid-i?*) :argb16* (s/? valid-i?*) )
         :iiiSiiiiiiiiiiiiiiiii (s/cat :p1 valid-i? :p2dummy valid-i? :size valid-i? :gen valid-S? :arga valid-i? :argb1* (s/? valid-i?*) :argb2* (s/? valid-i?*) :argb3* (s/? valid-i?*) :argb4* (s/? valid-i?*) :argb5* (s/? valid-i?*) :argb6* (s/? valid-i?*) :argb7* (s/? valid-i?*) :argb8* (s/? valid-i?*) :argb9* (s/? valid-i?*) :argb10* (s/? valid-i?*) :argb11* (s/? valid-i?*) :argb12* (s/? valid-i?*) :argb13* (s/? valid-i?*) :argb14* (s/? valid-i?*) :argb15* (s/? valid-i?*) :argb16* (s/? valid-i?*) )
         :iiiSSiiiiiiiiiiiiiiii (s/cat :p1 valid-i? :p2dummy valid-i? :size valid-i? :gen valid-S? :arga valid-S? :argb1* (s/? valid-i?*) :argb2* (s/? valid-i?*) :argb3* (s/? valid-i?*) :argb4* (s/? valid-i?*) :argb5* (s/? valid-i?*) :argb6* (s/? valid-i?*) :argb7* (s/? valid-i?*) :argb8* (s/? valid-i?*) :argb9* (s/? valid-i?*) :argb10* (s/? valid-i?*) :argb11* (s/? valid-i?*) :argb12* (s/? valid-i?*) :argb13* (s/? valid-i?*) :argb14* (s/? valid-i?*) :argb15* (s/? valid-i?*) :argb16* (s/? valid-i?*) )
         ))
(stest/instrument `ftgenonce)

(defn butterbp
  {:arglists '([asig xfreq xband & iskip*])}
  [sig freq band & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "butterbp"
                      [sig freq band skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef butterbp
  :args (s/cat :sig valid-ar? :freq valid-x? :band valid-x? :skip* (s/? valid-i?*) ))
(stest/instrument `butterbp)

(defn maxaccum
  {:arglists '([aAccumulator aInput])}
  [Accumulator Input]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "maxaccum"
                      [Accumulator Input]
                      *global*)]
    (new out-types ast)))

(s/fdef maxaccum
  :args (s/cat :Accumulator valid-ar? :Input valid-ar? ))
(stest/instrument `maxaccum)

(defn pvsftr
  {:arglists '([fsrc ifna & ifnf*])}
  [src fna & [ fnf* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "pvsftr"
                      [src fna fnf*]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsftr
  :args (s/cat :src valid-f? :fna valid-i? :fnf* (s/? valid-i?*) ))
(stest/instrument `pvsftr)

(defn butbr
  {:arglists '([asig xfreq xband & iskip*])}
  [sig freq band & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "butbr"
                      [sig freq band skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef butbr
  :args (s/cat :sig valid-ar? :freq valid-x? :band valid-x? :skip* (s/? valid-i?*) ))
(stest/instrument `butbr)

(defn readk4
  {:arglists '([Sfilname iformat iprd] [ifilname iformat iprd])}
  [filname format prd]
  (let [out-types-quoted '[ControlSignal ControlSignal ControlSignal ControlSignal]
        out-types [ControlSignal ControlSignal ControlSignal ControlSignal]
        ast (ast-node out-types-quoted
                      "readk4"
                      [filname format prd]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef readk4
  :args (s/alt
         :iii (s/cat :filname valid-i? :format valid-i? :prd valid-i? )
         :Sii (s/cat :filname valid-S? :format valid-i? :prd valid-i? )
         ))
(stest/instrument `readk4)

(defn outx
  {:arglists '([& asig1* asig2* asig3* asig4* asig5* asig6* asig7* asig8* asig9* asig10* asig11* asig12* asig13* asig14* asig15* asig16* asig17* asig18* asig19* asig20* asig21* asig22* asig23* asig24* asig25* asig26* asig27* asig28* asig29* asig30* asig31* asig32*])}
  [& [ sig1* sig2* sig3* sig4* sig5* sig6* sig7* sig8* sig9* sig10* sig11* sig12* sig13* sig14* sig15* sig16* sig17* sig18* sig19* sig20* sig21* sig22* sig23* sig24* sig25* sig26* sig27* sig28* sig29* sig30* sig31* sig32* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outx"
                      [sig1* sig2* sig3* sig4* sig5* sig6* sig7* sig8* sig9* sig10* sig11* sig12* sig13* sig14* sig15* sig16* sig17* sig18* sig19* sig20* sig21* sig22* sig23* sig24* sig25* sig26* sig27* sig28* sig29* sig30* sig31* sig32*]
                      *global*)]
    (new out-types ast)))

(s/fdef outx
  :args (s/cat :sig1* (s/? valid-ar?*) :sig2* (s/? valid-ar?*) :sig3* (s/? valid-ar?*) :sig4* (s/? valid-ar?*) :sig5* (s/? valid-ar?*) :sig6* (s/? valid-ar?*) :sig7* (s/? valid-ar?*) :sig8* (s/? valid-ar?*) :sig9* (s/? valid-ar?*) :sig10* (s/? valid-ar?*) :sig11* (s/? valid-ar?*) :sig12* (s/? valid-ar?*) :sig13* (s/? valid-ar?*) :sig14* (s/? valid-ar?*) :sig15* (s/? valid-ar?*) :sig16* (s/? valid-ar?*) :sig17* (s/? valid-ar?*) :sig18* (s/? valid-ar?*) :sig19* (s/? valid-ar?*) :sig20* (s/? valid-ar?*) :sig21* (s/? valid-ar?*) :sig22* (s/? valid-ar?*) :sig23* (s/? valid-ar?*) :sig24* (s/? valid-ar?*) :sig25* (s/? valid-ar?*) :sig26* (s/? valid-ar?*) :sig27* (s/? valid-ar?*) :sig28* (s/? valid-ar?*) :sig29* (s/? valid-ar?*) :sig30* (s/? valid-ar?*) :sig31* (s/? valid-ar?*) :sig32* (s/? valid-ar?*) ))
(stest/instrument `outx)

(defn sfload
  {:arglists '([Sfilename] [ifilename])}
  [filename]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "sfload"
                      [filename]
                      *global*)]
    (new out-types ast)))

(s/fdef sfload
  :args (s/alt
         :i (s/cat :filename valid-i? )
         :S (s/cat :filename valid-S? )
         ))
(stest/instrument `sfload)

(defn transegb
  {:arglists '([ia itim itype & ib1* itim2* itype3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*] [ia itim itype & ib1* itim2* itype3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a tim type & [ b1* tim2* type3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "transegb"
                      [a tim type b1* tim2* type3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef transegb
  :args (s/alt
         :iiiiiiiiiiiiiiiiiii (s/cat :a valid-i? :tim valid-i? :type valid-i? :b1* (s/? valid-i?*) :tim2* (s/? valid-i?*) :type3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) )
         ))
(stest/instrument `transegb)

(defn transegb:a
  {:arglists '([ia itim itype & ib1* itim2* itype3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a tim type & [ b1* tim2* type3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "transegb"
                      [a tim type b1* tim2* type3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef transegb:a
  :args (s/cat :a valid-i? :tim valid-i? :type valid-i? :b1* (s/? valid-i?*) :tim2* (s/? valid-i?*) :type3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) ))
(stest/instrument `transegb:a)

(defn transegb:k
  {:arglists '([ia itim itype & ib1* itim2* itype3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a tim type & [ b1* tim2* type3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "transegb"
                      [a tim type b1* tim2* type3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef transegb:k
  :args (s/cat :a valid-i? :tim valid-i? :type valid-i? :b1* (s/? valid-i?*) :tim2* (s/? valid-i?*) :type3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) ))
(stest/instrument `transegb:k)

(defn vcomb
  {:arglists '([asig krvt xlpt imaxlpt & iskip* insmps*])}
  [sig rvt lpt maxlpt & [ skip* nsmps* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "vcomb"
                      [sig rvt lpt maxlpt skip* nsmps*]
                      *global*)]
    (new out-types ast)))

(s/fdef vcomb
  :args (s/cat :sig valid-ar? :rvt valid-kr? :lpt valid-x? :maxlpt valid-i? :skip* (s/? valid-i?*) :nsmps* (s/? valid-i?*) ))
(stest/instrument `vcomb)

(defn tablexseg
  {:arglists '([ifn1 idur2 & ifn1* idur2* ifn3* ifn4* ifn5* ifn6* ifn7* ifn8* ifn9* ifn10* ifn11* ifn12* ifn13* ifn14* ifn15* ifn16*])}
  [fn1 dur2 & [ fn1* dur2* fn3* fn4* fn5* fn6* fn7* fn8* fn9* fn10* fn11* fn12* fn13* fn14* fn15* fn16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "tablexseg"
                      [fn1 dur2 fn1* dur2* fn3* fn4* fn5* fn6* fn7* fn8* fn9* fn10* fn11* fn12* fn13* fn14* fn15* fn16*]
                      *global*)]
    (new out-types ast)))

(s/fdef tablexseg
  :args (s/cat :fn1 valid-i? :dur2 valid-i? :fn1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :fn3* (s/? valid-i?*) :fn4* (s/? valid-i?*) :fn5* (s/? valid-i?*) :fn6* (s/? valid-i?*) :fn7* (s/? valid-i?*) :fn8* (s/? valid-i?*) :fn9* (s/? valid-i?*) :fn10* (s/? valid-i?*) :fn11* (s/? valid-i?*) :fn12* (s/? valid-i?*) :fn13* (s/? valid-i?*) :fn14* (s/? valid-i?*) :fn15* (s/? valid-i?*) :fn16* (s/? valid-i?*) ))
(stest/instrument `tablexseg)

(defn mp3in
  {:arglists '([Sfilcod & iskptim* iformat* iskipinit* ibufsize*] [ifilcod & iskptim* iformat* iskipinit* ibufsize*])}
  [filcod & [ skptim* format* skipinit* bufsize* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "mp3in"
                      [filcod skptim* format* skipinit* bufsize*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef mp3in
  :args (s/alt
         :iiiii (s/cat :filcod valid-i? :skptim* (s/? valid-i?*) :format* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :bufsize* (s/? valid-i?*) )
         :Siiii (s/cat :filcod valid-S? :skptim* (s/? valid-i?*) :format* (s/? valid-i?*) :skipinit* (s/? valid-i?*) :bufsize* (s/? valid-i?*) )
         ))
(stest/instrument `mp3in)

(defn ctrlinit
  {:arglists '([ichnl & ictlno1* ival2* ictlno3* ival4* ictlno5* ival6* ival7* ival8* ival9* ival10* ival11* ival12* ival13* ival14* ival15* ival16*])}
  [chnl & [ ctlno1* val2* ctlno3* val4* ctlno5* val6* val7* val8* val9* val10* val11* val12* val13* val14* val15* val16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "ctrlinit"
                      [chnl ctlno1* val2* ctlno3* val4* ctlno5* val6* val7* val8* val9* val10* val11* val12* val13* val14* val15* val16*]
                      *global*)]
    (new out-types ast)))

(s/fdef ctrlinit
  :args (s/cat :chnl valid-i? :ctlno1* (s/? valid-i?*) :val2* (s/? valid-i?*) :ctlno3* (s/? valid-i?*) :val4* (s/? valid-i?*) :ctlno5* (s/? valid-i?*) :val6* (s/? valid-i?*) :val7* (s/? valid-i?*) :val8* (s/? valid-i?*) :val9* (s/? valid-i?*) :val10* (s/? valid-i?*) :val11* (s/? valid-i?*) :val12* (s/? valid-i?*) :val13* (s/? valid-i?*) :val14* (s/? valid-i?*) :val15* (s/? valid-i?*) :val16* (s/? valid-i?*) ))
(stest/instrument `ctrlinit)

(defn outletv
  {:arglists '([Sname arrayArr])}
  [name rray]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outletv"
                      [name rray]
                      *global*)]
    (new out-types ast)))

(s/fdef outletv
  :args (s/cat :name valid-S? :rray valid-aArr? ))
(stest/instrument `outletv)

(defn fmod
  {:arglists '([iargArr iarg2] [iargArr iarg2Arr] [kargArr karg2] [kargArr karg2Arr])}
  [arg arg2]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "fmod"
                      [arg arg2]
                      *global*)]
    (new out-types ast)))

(s/fdef fmod
  :args (s/alt
         :kArrkArr (s/cat :arg valid-kArr? :arg2 valid-kArr? )
         :kArrk (s/cat :arg valid-kArr? :arg2 valid-kr? )
         :iArriArr (s/cat :arg valid-iArr? :arg2 valid-iArr? )
         :iArri (s/cat :arg valid-iArr? :arg2 valid-i? )
         ))
(stest/instrument `fmod)

(defn fmod:iArr
  {:arglists '([iargArr iarg2] [iargArr iarg2Arr])}
  [arg arg2]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "fmod"
                      [arg arg2]
                      *global*)]
    (new out-types ast)))

(s/fdef fmod:iArr
  :args (s/alt
         :iArriArr (s/cat :arg valid-iArr? :arg2 valid-iArr? )
         :iArri (s/cat :arg valid-iArr? :arg2 valid-i? )
         ))
(stest/instrument `fmod:iArr)

(defn fmod:kArr
  {:arglists '([kargArr karg2] [kargArr karg2Arr])}
  [arg arg2]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "fmod"
                      [arg arg2]
                      *global*)]
    (new out-types ast)))

(s/fdef fmod:kArr
  :args (s/alt
         :kArrkArr (s/cat :arg valid-kArr? :arg2 valid-kArr? )
         :kArrk (s/cat :arg valid-kArr? :arg2 valid-kr? )
         ))
(stest/instrument `fmod:kArr)

(defn tableigpw
  {:arglists '([itable])}
  [table]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "tableigpw"
                      [table]
                      *global*)]
    (new out-types ast)))

(s/fdef tableigpw
  :args (s/cat :table valid-i? ))
(stest/instrument `tableigpw)

(defn ftgentmp
  {:arglists '([ip1 ip2dummy isize Sgen Sarga & iargb1* iargb2* iargb3* iargb4* iargb5* iargb6* iargb7* iargb8* iargb9* iargb10* iargb11* iargb12* iargb13* iargb14* iargb15* iargb16*] [ip1 ip2dummy isize Sgen iarga & iargb1* iargb2* iargb3* iargb4* iargb5* iargb6* iargb7* iargb8* iargb9* iargb10* iargb11* iargb12* iargb13* iargb14* iargb15* iargb16*] [ip1 ip2dummy isize igen Sarga & iargb1* iargb2* iargb3* iargb4* iargb5* iargb6* iargb7* iargb8* iargb9* iargb10* iargb11* iargb12* iargb13* iargb14* iargb15* iargb16*] [ip1 ip2dummy isize igen iarga & iargb1* iargb2* iargb3* iargb4* iargb5* iargb6* iargb7* iargb8* iargb9* iargb10* iargb11* iargb12* iargb13* iargb14* iargb15* iargb16*])}
  [p1 p2dummy size gen arga & [ argb1* argb2* argb3* argb4* argb5* argb6* argb7* argb8* argb9* argb10* argb11* argb12* argb13* argb14* argb15* argb16* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "ftgentmp"
                      [p1 p2dummy size gen arga argb1* argb2* argb3* argb4* argb5* argb6* argb7* argb8* argb9* argb10* argb11* argb12* argb13* argb14* argb15* argb16*]
                      *global*)]
    (new out-types ast)))

(s/fdef ftgentmp
  :args (s/alt
         :iiiiiiiiiiiiiiiiiiiii (s/cat :p1 valid-i? :p2dummy valid-i? :size valid-i? :gen valid-i? :arga valid-i? :argb1* (s/? valid-i?*) :argb2* (s/? valid-i?*) :argb3* (s/? valid-i?*) :argb4* (s/? valid-i?*) :argb5* (s/? valid-i?*) :argb6* (s/? valid-i?*) :argb7* (s/? valid-i?*) :argb8* (s/? valid-i?*) :argb9* (s/? valid-i?*) :argb10* (s/? valid-i?*) :argb11* (s/? valid-i?*) :argb12* (s/? valid-i?*) :argb13* (s/? valid-i?*) :argb14* (s/? valid-i?*) :argb15* (s/? valid-i?*) :argb16* (s/? valid-i?*) )
         :iiiiSiiiiiiiiiiiiiiii (s/cat :p1 valid-i? :p2dummy valid-i? :size valid-i? :gen valid-i? :arga valid-S? :argb1* (s/? valid-i?*) :argb2* (s/? valid-i?*) :argb3* (s/? valid-i?*) :argb4* (s/? valid-i?*) :argb5* (s/? valid-i?*) :argb6* (s/? valid-i?*) :argb7* (s/? valid-i?*) :argb8* (s/? valid-i?*) :argb9* (s/? valid-i?*) :argb10* (s/? valid-i?*) :argb11* (s/? valid-i?*) :argb12* (s/? valid-i?*) :argb13* (s/? valid-i?*) :argb14* (s/? valid-i?*) :argb15* (s/? valid-i?*) :argb16* (s/? valid-i?*) )
         :iiiSiiiiiiiiiiiiiiiii (s/cat :p1 valid-i? :p2dummy valid-i? :size valid-i? :gen valid-S? :arga valid-i? :argb1* (s/? valid-i?*) :argb2* (s/? valid-i?*) :argb3* (s/? valid-i?*) :argb4* (s/? valid-i?*) :argb5* (s/? valid-i?*) :argb6* (s/? valid-i?*) :argb7* (s/? valid-i?*) :argb8* (s/? valid-i?*) :argb9* (s/? valid-i?*) :argb10* (s/? valid-i?*) :argb11* (s/? valid-i?*) :argb12* (s/? valid-i?*) :argb13* (s/? valid-i?*) :argb14* (s/? valid-i?*) :argb15* (s/? valid-i?*) :argb16* (s/? valid-i?*) )
         :iiiSSiiiiiiiiiiiiiiii (s/cat :p1 valid-i? :p2dummy valid-i? :size valid-i? :gen valid-S? :arga valid-S? :argb1* (s/? valid-i?*) :argb2* (s/? valid-i?*) :argb3* (s/? valid-i?*) :argb4* (s/? valid-i?*) :argb5* (s/? valid-i?*) :argb6* (s/? valid-i?*) :argb7* (s/? valid-i?*) :argb8* (s/? valid-i?*) :argb9* (s/? valid-i?*) :argb10* (s/? valid-i?*) :argb11* (s/? valid-i?*) :argb12* (s/? valid-i?*) :argb13* (s/? valid-i?*) :argb14* (s/? valid-i?*) :argb15* (s/? valid-i?*) :argb16* (s/? valid-i?*) )
         ))
(stest/instrument `ftgentmp)

(defn unwrap
  {:arglists '([kinArr])}
  [in]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "unwrap"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef unwrap
  :args (s/cat :in valid-kArr? ))
(stest/instrument `unwrap)

(defn pan
  {:arglists '([asig kx ky itable & imode* ioffset*])}
  [sig x y table & [ mode* offset* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "pan"
                      [sig x y table mode* offset*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef pan
  :args (s/cat :sig valid-ar? :x valid-kr? :y valid-kr? :table valid-i? :mode* (s/? valid-i?*) :offset* (s/? valid-i?*) ))
(stest/instrument `pan)

(defn bformdec1
  {:arglists '([isetup abformArr] [isetup & abform1* abform2* abform3* abform4* abform5* abform6* abform7* abform8* abform9* abform10* abform11* abform12* abform13* abform14* abform15* abform16* abform17* abform18* abform19* abform20* abform21* abform22* abform23* abform24* abform25* abform26* abform27* abform28* abform29* abform30* abform31* abform32*])}
  [setup bform]
  (let [out-types-quoted 'AudioArray
        out-types AudioArray
        ast (ast-node out-types-quoted
                      "bformdec1"
                      [setup bform]
                      *global*)]
    (new out-types ast)))

(s/fdef bformdec1
  :args (s/alt
         :iaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa (s/cat :setup valid-i? :bform1* (s/? valid-ar?*) :bform2* (s/? valid-ar?*) :bform3* (s/? valid-ar?*) :bform4* (s/? valid-ar?*) :bform5* (s/? valid-ar?*) :bform6* (s/? valid-ar?*) :bform7* (s/? valid-ar?*) :bform8* (s/? valid-ar?*) :bform9* (s/? valid-ar?*) :bform10* (s/? valid-ar?*) :bform11* (s/? valid-ar?*) :bform12* (s/? valid-ar?*) :bform13* (s/? valid-ar?*) :bform14* (s/? valid-ar?*) :bform15* (s/? valid-ar?*) :bform16* (s/? valid-ar?*) :bform17* (s/? valid-ar?*) :bform18* (s/? valid-ar?*) :bform19* (s/? valid-ar?*) :bform20* (s/? valid-ar?*) :bform21* (s/? valid-ar?*) :bform22* (s/? valid-ar?*) :bform23* (s/? valid-ar?*) :bform24* (s/? valid-ar?*) :bform25* (s/? valid-ar?*) :bform26* (s/? valid-ar?*) :bform27* (s/? valid-ar?*) :bform28* (s/? valid-ar?*) :bform29* (s/? valid-ar?*) :bform30* (s/? valid-ar?*) :bform31* (s/? valid-ar?*) :bform32* (s/? valid-ar?*) )
         :iaArr (s/cat :setup valid-i? :bform valid-aArr? )
         ))
(stest/instrument `bformdec1)

(defn bformdec1:aArr
  {:arglists '([isetup abformArr])}
  [setup bform]
  (let [out-types-quoted 'AudioArray
        out-types AudioArray
        ast (ast-node out-types-quoted
                      "bformdec1"
                      [setup bform]
                      *global*)]
    (new out-types ast)))

(s/fdef bformdec1:aArr
  :args (s/cat :setup valid-i? :bform valid-aArr? ))
(stest/instrument `bformdec1:aArr)

(defn bformdec1:a
  {:arglists '([isetup & abform1* abform2* abform3* abform4* abform5* abform6* abform7* abform8* abform9* abform10* abform11* abform12* abform13* abform14* abform15* abform16* abform17* abform18* abform19* abform20* abform21* abform22* abform23* abform24* abform25* abform26* abform27* abform28* abform29* abform30* abform31* abform32*])}
  [setup & [ bform1* bform2* bform3* bform4* bform5* bform6* bform7* bform8* bform9* bform10* bform11* bform12* bform13* bform14* bform15* bform16* bform17* bform18* bform19* bform20* bform21* bform22* bform23* bform24* bform25* bform26* bform27* bform28* bform29* bform30* bform31* bform32* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "bformdec1"
                      [setup bform1* bform2* bform3* bform4* bform5* bform6* bform7* bform8* bform9* bform10* bform11* bform12* bform13* bform14* bform15* bform16* bform17* bform18* bform19* bform20* bform21* bform22* bform23* bform24* bform25* bform26* bform27* bform28* bform29* bform30* bform31* bform32*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef bformdec1:a
  :args (s/cat :setup valid-i? :bform1* (s/? valid-ar?*) :bform2* (s/? valid-ar?*) :bform3* (s/? valid-ar?*) :bform4* (s/? valid-ar?*) :bform5* (s/? valid-ar?*) :bform6* (s/? valid-ar?*) :bform7* (s/? valid-ar?*) :bform8* (s/? valid-ar?*) :bform9* (s/? valid-ar?*) :bform10* (s/? valid-ar?*) :bform11* (s/? valid-ar?*) :bform12* (s/? valid-ar?*) :bform13* (s/? valid-ar?*) :bform14* (s/? valid-ar?*) :bform15* (s/? valid-ar?*) :bform16* (s/? valid-ar?*) :bform17* (s/? valid-ar?*) :bform18* (s/? valid-ar?*) :bform19* (s/? valid-ar?*) :bform20* (s/? valid-ar?*) :bform21* (s/? valid-ar?*) :bform22* (s/? valid-ar?*) :bform23* (s/? valid-ar?*) :bform24* (s/? valid-ar?*) :bform25* (s/? valid-ar?*) :bform26* (s/? valid-ar?*) :bform27* (s/? valid-ar?*) :bform28* (s/? valid-ar?*) :bform29* (s/? valid-ar?*) :bform30* (s/? valid-ar?*) :bform31* (s/? valid-ar?*) :bform32* (s/? valid-ar?*) ))
(stest/instrument `bformdec1:a)

(defn readfi
  {:arglists '([Sfilname] [ifilname])}
  [filname]
  (let [out-types-quoted '[String Variable]
        out-types [String Variable]
        ast (ast-node out-types-quoted
                      "readfi"
                      [filname]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef readfi
  :args (s/alt
         :i (s/cat :filname valid-i? )
         :S (s/cat :filname valid-S? )
         ))
(stest/instrument `readfi)

(defn sininv
  {:arglists '([aarg1] [iarg1] [iarg1Arr] [karg1] [karg1Arr])}
  [arg1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "sininv"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sininv
  :args (s/alt
         :kArr (s/cat :arg1 valid-kArr? )
         :k (s/cat :arg1 valid-kr? )
         :iArr (s/cat :arg1 valid-iArr? )
         :i (s/cat :arg1 valid-i? )
         :a (s/cat :arg1 valid-ar? )
         ))
(stest/instrument `sininv)

(defn sininv:a
  {:arglists '([aarg1])}
  [arg1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "sininv"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sininv:a
  :args (s/cat :arg1 valid-ar? ))
(stest/instrument `sininv:a)

(defn sininv:i
  {:arglists '([iarg1])}
  [arg1]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "sininv"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sininv:i
  :args (s/cat :arg1 valid-i? ))
(stest/instrument `sininv:i)

(defn sininv:iArr
  {:arglists '([iarg1Arr])}
  [arg1]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "sininv"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sininv:iArr
  :args (s/cat :arg1 valid-iArr? ))
(stest/instrument `sininv:iArr)

(defn sininv:k
  {:arglists '([karg1])}
  [arg1]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "sininv"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sininv:k
  :args (s/cat :arg1 valid-kr? ))
(stest/instrument `sininv:k)

(defn sininv:kArr
  {:arglists '([karg1Arr])}
  [arg1]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "sininv"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sininv:kArr
  :args (s/cat :arg1 valid-kArr? ))
(stest/instrument `sininv:kArr)

(defn outkc14
  {:arglists '([kchn kmsb klsb kvalue kmin kmax])}
  [chn msb lsb value min max]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outkc14"
                      [chn msb lsb value min max]
                      *global*)]
    (new out-types ast)))

(s/fdef outkc14
  :args (s/cat :chn valid-kr? :msb valid-kr? :lsb valid-kr? :value valid-kr? :min valid-kr? :max valid-kr? ))
(stest/instrument `outkc14)

(defn cpumeter
  {:arglists '([ifreq])}
  [freq]
  (let [out-types-quoted '[ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal]
        out-types [ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal]
        ast (ast-node out-types-quoted
                      "cpumeter"
                      [freq]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef cpumeter
  :args (s/cat :freq valid-i? ))
(stest/instrument `cpumeter)

(defn zir
  {:arglists '([iindex])}
  [index]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "zir"
                      [index]
                      *global*)]
    (new out-types ast)))

(s/fdef zir
  :args (s/cat :index valid-i? ))
(stest/instrument `zir)

(defn poisson
  {:arglists '([klambda] [klambda] [klambda])}
  [lambda]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "poisson"
                      [lambda]
                      *global*)]
    (new out-types ast)))

(s/fdef poisson
  :args (s/alt
         :k (s/cat :lambda valid-kr? )
         ))
(stest/instrument `poisson)

(defn poisson:a
  {:arglists '([klambda])}
  [lambda]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "poisson"
                      [lambda]
                      *global*)]
    (new out-types ast)))

(s/fdef poisson:a
  :args (s/cat :lambda valid-kr? ))
(stest/instrument `poisson:a)

(defn poisson:i
  {:arglists '([klambda])}
  [lambda]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "poisson"
                      [lambda]
                      *global*)]
    (new out-types ast)))

(s/fdef poisson:i
  :args (s/cat :lambda valid-kr? ))
(stest/instrument `poisson:i)

(defn poisson:k
  {:arglists '([klambda])}
  [lambda]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "poisson"
                      [lambda]
                      *global*)]
    (new out-types ast)))

(s/fdef poisson:k
  :args (s/cat :lambda valid-kr? ))
(stest/instrument `poisson:k)

(defn pvsinit
  {:arglists '([isize & iolap* iwinsize* iwintype* iformat*])}
  [size & [ olap* winsize* wintype* format* ]]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvsinit"
                      [size olap* winsize* wintype* format*]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsinit
  :args (s/cat :size valid-i? :olap* (s/? valid-i?*) :winsize* (s/? valid-i?*) :wintype* (s/? valid-i?*) :format* (s/? valid-i?*) ))
(stest/instrument `pvsinit)

(defn outipat
  {:arglists '([ichn inotenum ivalue imin imax])}
  [chn notenum value min max]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outipat"
                      [chn notenum value min max]
                      *global*)]
    (new out-types ast)))

(s/fdef outipat
  :args (s/cat :chn valid-i? :notenum valid-i? :value valid-i? :min valid-i? :max valid-i? ))
(stest/instrument `outipat)

(defn shiftin
  {:arglists '([asig])}
  [sig]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "shiftin"
                      [sig]
                      *global*)]
    (new out-types ast)))

(s/fdef shiftin
  :args (s/cat :sig valid-ar? ))
(stest/instrument `shiftin)

(defn tablemix
  {:arglists '([kdft kdoff klen ks1ft ks1off ks1g ks2ft ks2off ks2g])}
  [dft doff len s1ft s1off s1g s2ft s2off s2g]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "tablemix"
                      [dft doff len s1ft s1off s1g s2ft s2off s2g]
                      *global*)]
    (new out-types ast)))

(s/fdef tablemix
  :args (s/cat :dft valid-kr? :doff valid-kr? :len valid-kr? :s1ft valid-kr? :s1off valid-kr? :s1g valid-kr? :s2ft valid-kr? :s2off valid-kr? :s2g valid-kr? ))
(stest/instrument `tablemix)

(defn insglobal
  {:arglists '([Ssource & instrnum1* instrnum2* instrnum3* instrnum4* instrnum5* instrnum6* instrnum7* instrnum8* instrnum9* instrnum10* instrnum11* instrnum12* instrnum13* instrnum14* instrnum15* instrnum16*])}
  [source & [ nstrnum1* nstrnum2* nstrnum3* nstrnum4* nstrnum5* nstrnum6* nstrnum7* nstrnum8* nstrnum9* nstrnum10* nstrnum11* nstrnum12* nstrnum13* nstrnum14* nstrnum15* nstrnum16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "insglobal"
                      [source nstrnum1* nstrnum2* nstrnum3* nstrnum4* nstrnum5* nstrnum6* nstrnum7* nstrnum8* nstrnum9* nstrnum10* nstrnum11* nstrnum12* nstrnum13* nstrnum14* nstrnum15* nstrnum16*]
                      *global*)]
    (new out-types ast)))

(s/fdef insglobal
  :args (s/cat :source valid-S? :nstrnum1* (s/? valid-i?*) :nstrnum2* (s/? valid-i?*) :nstrnum3* (s/? valid-i?*) :nstrnum4* (s/? valid-i?*) :nstrnum5* (s/? valid-i?*) :nstrnum6* (s/? valid-i?*) :nstrnum7* (s/? valid-i?*) :nstrnum8* (s/? valid-i?*) :nstrnum9* (s/? valid-i?*) :nstrnum10* (s/? valid-i?*) :nstrnum11* (s/? valid-i?*) :nstrnum12* (s/? valid-i?*) :nstrnum13* (s/? valid-i?*) :nstrnum14* (s/? valid-i?*) :nstrnum15* (s/? valid-i?*) :nstrnum16* (s/? valid-i?*) ))
(stest/instrument `insglobal)

(defn setcol
  {:arglists '([kinArr kcol])}
  [in col]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "setcol"
                      [in col]
                      *global*)]
    (new out-types ast)))

(s/fdef setcol
  :args (s/cat :in valid-kArr? :col valid-kr? ))
(stest/instrument `setcol)

(defn trsplit
  {:arglists '([fin & ksplit1* kgainlow2* kgainhigh3* kgainhigh4* kgainhigh5* kgainhigh6* kgainhigh7* kgainhigh8* kgainhigh9* kgainhigh10* kgainhigh11* kgainhigh12* kgainhigh13* kgainhigh14* kgainhigh15* kgainhigh16*])}
  [in & [ split1* gainlow2* gainhigh3* gainhigh4* gainhigh5* gainhigh6* gainhigh7* gainhigh8* gainhigh9* gainhigh10* gainhigh11* gainhigh12* gainhigh13* gainhigh14* gainhigh15* gainhigh16* ]]
  (let [out-types-quoted '[FrequencySignal FrequencySignal]
        out-types [FrequencySignal FrequencySignal]
        ast (ast-node out-types-quoted
                      "trsplit"
                      [in split1* gainlow2* gainhigh3* gainhigh4* gainhigh5* gainhigh6* gainhigh7* gainhigh8* gainhigh9* gainhigh10* gainhigh11* gainhigh12* gainhigh13* gainhigh14* gainhigh15* gainhigh16*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef trsplit
  :args (s/cat :in valid-f? :split1* (s/? valid-kr?*) :gainlow2* (s/? valid-kr?*) :gainhigh3* (s/? valid-kr?*) :gainhigh4* (s/? valid-kr?*) :gainhigh5* (s/? valid-kr?*) :gainhigh6* (s/? valid-kr?*) :gainhigh7* (s/? valid-kr?*) :gainhigh8* (s/? valid-kr?*) :gainhigh9* (s/? valid-kr?*) :gainhigh10* (s/? valid-kr?*) :gainhigh11* (s/? valid-kr?*) :gainhigh12* (s/? valid-kr?*) :gainhigh13* (s/? valid-kr?*) :gainhigh14* (s/? valid-kr?*) :gainhigh15* (s/? valid-kr?*) :gainhigh16* (s/? valid-kr?*) ))
(stest/instrument `trsplit)

(defn deltapi
  {:arglists '([xdlt & idlt*])}
  [dlt & [ dlt* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "deltapi"
                      [dlt dlt*]
                      *global*)]
    (new out-types ast)))

(s/fdef deltapi
  :args (s/cat :dlt valid-x? :dlt* (s/? valid-i?*) ))
(stest/instrument `deltapi)

(defn alpass
  {:arglists '([asig xrvt ilpt & iskip* insmps*])}
  [sig rvt lpt & [ skip* nsmps* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "alpass"
                      [sig rvt lpt skip* nsmps*]
                      *global*)]
    (new out-types ast)))

(s/fdef alpass
  :args (s/cat :sig valid-ar? :rvt valid-x? :lpt valid-i? :skip* (s/? valid-i?*) :nsmps* (s/? valid-i?*) ))
(stest/instrument `alpass)

(defn vbapmove
  {:arglists '([asig idur ispread ifldnum & ifld1* ifld2* ifld3* ifld4* ifld5* ifld6* ifld7* ifld8* ifld9* ifld10* ifld11* ifld12* ifld13* ifld14* ifld15* ifld16*] [asig idur ispread ifldnum & ifld1* ifld2* ifld3* ifld4* ifld5* ifld6* ifld7* ifld8* ifld9* ifld10* ifld11* ifld12* ifld13* ifld14* ifld15* ifld16*])}
  [sig dur spread fldnum & [ fld1* fld2* fld3* fld4* fld5* fld6* fld7* fld8* fld9* fld10* fld11* fld12* fld13* fld14* fld15* fld16* ]]
  (let [out-types-quoted 'AudioArray
        out-types AudioArray
        ast (ast-node out-types-quoted
                      "vbapmove"
                      [sig dur spread fldnum fld1* fld2* fld3* fld4* fld5* fld6* fld7* fld8* fld9* fld10* fld11* fld12* fld13* fld14* fld15* fld16*]
                      *global*)]
    (new out-types ast)))

(s/fdef vbapmove
  :args (s/alt
         :aiiiiiiiiiiiiiiiiiii (s/cat :sig valid-ar? :dur valid-i? :spread valid-i? :fldnum valid-i? :fld1* (s/? valid-i?*) :fld2* (s/? valid-i?*) :fld3* (s/? valid-i?*) :fld4* (s/? valid-i?*) :fld5* (s/? valid-i?*) :fld6* (s/? valid-i?*) :fld7* (s/? valid-i?*) :fld8* (s/? valid-i?*) :fld9* (s/? valid-i?*) :fld10* (s/? valid-i?*) :fld11* (s/? valid-i?*) :fld12* (s/? valid-i?*) :fld13* (s/? valid-i?*) :fld14* (s/? valid-i?*) :fld15* (s/? valid-i?*) :fld16* (s/? valid-i?*) )
         ))
(stest/instrument `vbapmove)

(defn vbapmove:aArr
  {:arglists '([asig idur ispread ifldnum & ifld1* ifld2* ifld3* ifld4* ifld5* ifld6* ifld7* ifld8* ifld9* ifld10* ifld11* ifld12* ifld13* ifld14* ifld15* ifld16*])}
  [sig dur spread fldnum & [ fld1* fld2* fld3* fld4* fld5* fld6* fld7* fld8* fld9* fld10* fld11* fld12* fld13* fld14* fld15* fld16* ]]
  (let [out-types-quoted 'AudioArray
        out-types AudioArray
        ast (ast-node out-types-quoted
                      "vbapmove"
                      [sig dur spread fldnum fld1* fld2* fld3* fld4* fld5* fld6* fld7* fld8* fld9* fld10* fld11* fld12* fld13* fld14* fld15* fld16*]
                      *global*)]
    (new out-types ast)))

(s/fdef vbapmove:aArr
  :args (s/cat :sig valid-ar? :dur valid-i? :spread valid-i? :fldnum valid-i? :fld1* (s/? valid-i?*) :fld2* (s/? valid-i?*) :fld3* (s/? valid-i?*) :fld4* (s/? valid-i?*) :fld5* (s/? valid-i?*) :fld6* (s/? valid-i?*) :fld7* (s/? valid-i?*) :fld8* (s/? valid-i?*) :fld9* (s/? valid-i?*) :fld10* (s/? valid-i?*) :fld11* (s/? valid-i?*) :fld12* (s/? valid-i?*) :fld13* (s/? valid-i?*) :fld14* (s/? valid-i?*) :fld15* (s/? valid-i?*) :fld16* (s/? valid-i?*) ))
(stest/instrument `vbapmove:aArr)

(defn vbapmove:a
  {:arglists '([asig idur ispread ifldnum & ifld1* ifld2* ifld3* ifld4* ifld5* ifld6* ifld7* ifld8* ifld9* ifld10* ifld11* ifld12* ifld13* ifld14* ifld15* ifld16*])}
  [sig dur spread fldnum & [ fld1* fld2* fld3* fld4* fld5* fld6* fld7* fld8* fld9* fld10* fld11* fld12* fld13* fld14* fld15* fld16* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "vbapmove"
                      [sig dur spread fldnum fld1* fld2* fld3* fld4* fld5* fld6* fld7* fld8* fld9* fld10* fld11* fld12* fld13* fld14* fld15* fld16*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef vbapmove:a
  :args (s/cat :sig valid-ar? :dur valid-i? :spread valid-i? :fldnum valid-i? :fld1* (s/? valid-i?*) :fld2* (s/? valid-i?*) :fld3* (s/? valid-i?*) :fld4* (s/? valid-i?*) :fld5* (s/? valid-i?*) :fld6* (s/? valid-i?*) :fld7* (s/? valid-i?*) :fld8* (s/? valid-i?*) :fld9* (s/? valid-i?*) :fld10* (s/? valid-i?*) :fld11* (s/? valid-i?*) :fld12* (s/? valid-i?*) :fld13* (s/? valid-i?*) :fld14* (s/? valid-i?*) :fld15* (s/? valid-i?*) :fld16* (s/? valid-i?*) ))
(stest/instrument `vbapmove:a)

(defn log
  {:arglists '([ain] [iin] [iinArr] [kin] [kinArr] [kinArr ibas])}
  [in]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "log"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef log
  :args (s/alt
         :kArri (s/cat :in valid-kArr? :bas valid-i? )
         :kArr (s/cat :in valid-kArr? )
         :k (s/cat :in valid-kr? )
         :iArr (s/cat :in valid-iArr? )
         :i (s/cat :in valid-i? )
         :a (s/cat :in valid-ar? )
         ))
(stest/instrument `log)

(defn log:a
  {:arglists '([ain])}
  [in]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "log"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef log:a
  :args (s/cat :in valid-ar? ))
(stest/instrument `log:a)

(defn log:i
  {:arglists '([iin])}
  [in]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "log"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef log:i
  :args (s/cat :in valid-i? ))
(stest/instrument `log:i)

(defn log:iArr
  {:arglists '([iinArr])}
  [in]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "log"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef log:iArr
  :args (s/cat :in valid-iArr? ))
(stest/instrument `log:iArr)

(defn log:k
  {:arglists '([kin])}
  [in]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "log"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef log:k
  :args (s/cat :in valid-kr? ))
(stest/instrument `log:k)

(defn log:kArr
  {:arglists '([kinArr] [kinArr ibas])}
  [in]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "log"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef log:kArr
  :args (s/alt
         :kArri (s/cat :in valid-kArr? :bas valid-i? )
         :kArr (s/cat :in valid-kArr? )
         ))
(stest/instrument `log:kArr)

(defn alwayson
  {:arglists '([Sinstrument & iarg1* in2* in3* in4* in5* in6* in7* in8* in9* in10* in11* in12* in13* in14* in15* in16*] [iinstrument & iarg1* in2* in3* in4* in5* in6* in7* in8* in9* in10* in11* in12* in13* in14* in15* in16*])}
  [instrument & [ arg1* n2* n3* n4* n5* n6* n7* n8* n9* n10* n11* n12* n13* n14* n15* n16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "alwayson"
                      [instrument arg1* n2* n3* n4* n5* n6* n7* n8* n9* n10* n11* n12* n13* n14* n15* n16*]
                      *global*)]
    (new out-types ast)))

(s/fdef alwayson
  :args (s/alt
         :iiiiiiiiiiiiiiiii (s/cat :instrument valid-i? :arg1* (s/? valid-i?*) :n2* (s/? valid-i?*) :n3* (s/? valid-i?*) :n4* (s/? valid-i?*) :n5* (s/? valid-i?*) :n6* (s/? valid-i?*) :n7* (s/? valid-i?*) :n8* (s/? valid-i?*) :n9* (s/? valid-i?*) :n10* (s/? valid-i?*) :n11* (s/? valid-i?*) :n12* (s/? valid-i?*) :n13* (s/? valid-i?*) :n14* (s/? valid-i?*) :n15* (s/? valid-i?*) :n16* (s/? valid-i?*) )
         :Siiiiiiiiiiiiiiii (s/cat :instrument valid-S? :arg1* (s/? valid-i?*) :n2* (s/? valid-i?*) :n3* (s/? valid-i?*) :n4* (s/? valid-i?*) :n5* (s/? valid-i?*) :n6* (s/? valid-i?*) :n7* (s/? valid-i?*) :n8* (s/? valid-i?*) :n9* (s/? valid-i?*) :n10* (s/? valid-i?*) :n11* (s/? valid-i?*) :n12* (s/? valid-i?*) :n13* (s/? valid-i?*) :n14* (s/? valid-i?*) :n15* (s/? valid-i?*) :n16* (s/? valid-i?*) )
         ))
(stest/instrument `alwayson)

(defn sfinstr
  {:arglists '([ivel inotenum xamp xfreq instrnum ifilhandle & iflag* ioffset* ioffset*])}
  [vel notenum amp freq nstrnum filhandle & [ flag* offset* offset* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "sfinstr"
                      [vel notenum amp freq nstrnum filhandle flag* offset* offset*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef sfinstr
  :args (s/cat :vel valid-i? :notenum valid-i? :amp valid-x? :freq valid-x? :nstrnum valid-i? :filhandle valid-i? :flag* (s/? valid-i?*) :offset* (s/? valid-i?*) :offset* (s/? valid-i?*) ))
(stest/instrument `sfinstr)

(defn cross2
  {:arglists '([ain1 ain2 isize ioverlap iwin kbias])}
  [in1 in2 size overlap win bias]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "cross2"
                      [in1 in2 size overlap win bias]
                      *global*)]
    (new out-types ast)))

(s/fdef cross2
  :args (s/cat :in1 valid-ar? :in2 valid-ar? :size valid-i? :overlap valid-i? :win valid-i? :bias valid-kr? ))
(stest/instrument `cross2)

(defn pchmidi
  {:arglists '()}
  []
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "pchmidi"
                      []
                      *global*)]
    (new out-types ast)))


(defn tableng
  {:arglists '([itable] [ktable])}
  [table]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "tableng"
                      [table]
                      *global*)]
    (new out-types ast)))

(s/fdef tableng
  :args (s/alt
         :k (s/cat :table valid-kr? )
         :i (s/cat :table valid-i? )
         ))
(stest/instrument `tableng)

(defn tableng:i
  {:arglists '([itable])}
  [table]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "tableng"
                      [table]
                      *global*)]
    (new out-types ast)))

(s/fdef tableng:i
  :args (s/cat :table valid-i? ))
(stest/instrument `tableng:i)

(defn tableng:k
  {:arglists '([ktable])}
  [table]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "tableng"
                      [table]
                      *global*)]
    (new out-types ast)))

(s/fdef tableng:k
  :args (s/cat :table valid-kr? ))
(stest/instrument `tableng:k)

(defn wrap
  {:arglists '([asig klow khigh] [isig ilow ihigh] [ksig klow khigh])}
  [sig low high]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "wrap"
                      [sig low high]
                      *global*)]
    (new out-types ast)))

(s/fdef wrap
  :args (s/alt
         :kkk (s/cat :sig valid-kr? :low valid-kr? :high valid-kr? )
         :iii (s/cat :sig valid-i? :low valid-i? :high valid-i? )
         :akk (s/cat :sig valid-ar? :low valid-kr? :high valid-kr? )
         ))
(stest/instrument `wrap)

(defn wrap:a
  {:arglists '([asig klow khigh])}
  [sig low high]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "wrap"
                      [sig low high]
                      *global*)]
    (new out-types ast)))

(s/fdef wrap:a
  :args (s/cat :sig valid-ar? :low valid-kr? :high valid-kr? ))
(stest/instrument `wrap:a)

(defn wrap:i
  {:arglists '([isig ilow ihigh])}
  [sig low high]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "wrap"
                      [sig low high]
                      *global*)]
    (new out-types ast)))

(s/fdef wrap:i
  :args (s/cat :sig valid-i? :low valid-i? :high valid-i? ))
(stest/instrument `wrap:i)

(defn wrap:k
  {:arglists '([ksig klow khigh])}
  [sig low high]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "wrap"
                      [sig low high]
                      *global*)]
    (new out-types ast)))

(s/fdef wrap:k
  :args (s/cat :sig valid-kr? :low valid-kr? :high valid-kr? ))
(stest/instrument `wrap:k)

(defn s16b14
  {:arglists '([ichan ictlno_msb2 ictlno_lsb3 imin4 imax5 initvalue6 ifn7 ictlno_msb8 ictlno_lsb9 imin10 imax11 initvalue12 ifn13 ifn14 ifn15 ifn16 ifn17 ifn18 ifn19 ifn20 ifn21 ifn22 ifn23 ifn24 ifn25 ifn26 ifn27 ifn28 ifn29 ifn30 ifn31 ifn32 ifn33 ifn34 ifn35 ifn36 ifn37 ifn38 ifn39 ifn40 ifn41 ifn42 ifn43 ifn44 ifn45 ifn46 ifn47 ifn48 ifn49 ifn50 ifn51 ifn52 ifn53 ifn54 ifn55 ifn56 ifn57 ifn58 ifn59 ifn60 ifn61 ifn62 ifn63 ifn64 ifn65 ifn66 ifn67 ifn68 ifn69 ifn70 ifn71 ifn72 ifn73 ifn74 ifn75 ifn76 ifn77 ifn78 ifn79 ifn80 ifn81] [ichan ictlno_msb2 ictlno_lsb3 imin4 imax5 initvalue6 ifn7 ictlno_msb8 ictlno_lsb9 imin10 imax11 initvalue12 ifn13 ifn14 ifn15 ifn16 ifn17 ifn18 ifn19 ifn20 ifn21 ifn22 ifn23 ifn24 ifn25 ifn26 ifn27 ifn28 ifn29 ifn30 ifn31 ifn32 ifn33 ifn34 ifn35 ifn36 ifn37 ifn38 ifn39 ifn40 ifn41 ifn42 ifn43 ifn44 ifn45 ifn46 ifn47 ifn48 ifn49 ifn50 ifn51 ifn52 ifn53 ifn54 ifn55 ifn56 ifn57 ifn58 ifn59 ifn60 ifn61 ifn62 ifn63 ifn64 ifn65 ifn66 ifn67 ifn68 ifn69 ifn70 ifn71 ifn72 ifn73 ifn74 ifn75 ifn76 ifn77 ifn78 ifn79 ifn80 ifn81 ifn82 ifn83 ifn84 ifn85 ifn86 ifn87 ifn88 ifn89 ifn90 ifn91 ifn92 ifn93 ifn94 ifn95 ifn96 ifn97])}
  [chan ctlno_msb2 ctlno_lsb3 min4 max5 nitvalue6 fn7 ctlno_msb8 ctlno_lsb9 min10 max11 nitvalue12 fn13 fn14 fn15 fn16 fn17 fn18 fn19 fn20 fn21 fn22 fn23 fn24 fn25 fn26 fn27 fn28 fn29 fn30 fn31 fn32 fn33 fn34 fn35 fn36 fn37 fn38 fn39 fn40 fn41 fn42 fn43 fn44 fn45 fn46 fn47 fn48 fn49 fn50 fn51 fn52 fn53 fn54 fn55 fn56 fn57 fn58 fn59 fn60 fn61 fn62 fn63 fn64 fn65 fn66 fn67 fn68 fn69 fn70 fn71 fn72 fn73 fn74 fn75 fn76 fn77 fn78 fn79 fn80 fn81]
  (let [out-types-quoted '[Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable]
        out-types [Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable Variable]
        ast (ast-node out-types-quoted
                      "s16b14"
                      [chan ctlno_msb2 ctlno_lsb3 min4 max5 nitvalue6 fn7 ctlno_msb8 ctlno_lsb9 min10 max11 nitvalue12 fn13 fn14 fn15 fn16 fn17 fn18 fn19 fn20 fn21 fn22 fn23 fn24 fn25 fn26 fn27 fn28 fn29 fn30 fn31 fn32 fn33 fn34 fn35 fn36 fn37 fn38 fn39 fn40 fn41 fn42 fn43 fn44 fn45 fn46 fn47 fn48 fn49 fn50 fn51 fn52 fn53 fn54 fn55 fn56 fn57 fn58 fn59 fn60 fn61 fn62 fn63 fn64 fn65 fn66 fn67 fn68 fn69 fn70 fn71 fn72 fn73 fn74 fn75 fn76 fn77 fn78 fn79 fn80 fn81]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef s16b14
  :args (s/alt
         :iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii (s/cat :chan valid-i? :ctlno_msb2 valid-i? :ctlno_lsb3 valid-i? :min4 valid-i? :max5 valid-i? :nitvalue6 valid-i? :fn7 valid-i? :ctlno_msb8 valid-i? :ctlno_lsb9 valid-i? :min10 valid-i? :max11 valid-i? :nitvalue12 valid-i? :fn13 valid-i? :fn14 valid-i? :fn15 valid-i? :fn16 valid-i? :fn17 valid-i? :fn18 valid-i? :fn19 valid-i? :fn20 valid-i? :fn21 valid-i? :fn22 valid-i? :fn23 valid-i? :fn24 valid-i? :fn25 valid-i? :fn26 valid-i? :fn27 valid-i? :fn28 valid-i? :fn29 valid-i? :fn30 valid-i? :fn31 valid-i? :fn32 valid-i? :fn33 valid-i? :fn34 valid-i? :fn35 valid-i? :fn36 valid-i? :fn37 valid-i? :fn38 valid-i? :fn39 valid-i? :fn40 valid-i? :fn41 valid-i? :fn42 valid-i? :fn43 valid-i? :fn44 valid-i? :fn45 valid-i? :fn46 valid-i? :fn47 valid-i? :fn48 valid-i? :fn49 valid-i? :fn50 valid-i? :fn51 valid-i? :fn52 valid-i? :fn53 valid-i? :fn54 valid-i? :fn55 valid-i? :fn56 valid-i? :fn57 valid-i? :fn58 valid-i? :fn59 valid-i? :fn60 valid-i? :fn61 valid-i? :fn62 valid-i? :fn63 valid-i? :fn64 valid-i? :fn65 valid-i? :fn66 valid-i? :fn67 valid-i? :fn68 valid-i? :fn69 valid-i? :fn70 valid-i? :fn71 valid-i? :fn72 valid-i? :fn73 valid-i? :fn74 valid-i? :fn75 valid-i? :fn76 valid-i? :fn77 valid-i? :fn78 valid-i? :fn79 valid-i? :fn80 valid-i? :fn81 valid-i? :fn82 valid-i? :fn83 valid-i? :fn84 valid-i? :fn85 valid-i? :fn86 valid-i? :fn87 valid-i? :fn88 valid-i? :fn89 valid-i? :fn90 valid-i? :fn91 valid-i? :fn92 valid-i? :fn93 valid-i? :fn94 valid-i? :fn95 valid-i? :fn96 valid-i? :fn97 valid-i? )
         :iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii (s/cat :chan valid-i? :ctlno_msb2 valid-i? :ctlno_lsb3 valid-i? :min4 valid-i? :max5 valid-i? :nitvalue6 valid-i? :fn7 valid-i? :ctlno_msb8 valid-i? :ctlno_lsb9 valid-i? :min10 valid-i? :max11 valid-i? :nitvalue12 valid-i? :fn13 valid-i? :fn14 valid-i? :fn15 valid-i? :fn16 valid-i? :fn17 valid-i? :fn18 valid-i? :fn19 valid-i? :fn20 valid-i? :fn21 valid-i? :fn22 valid-i? :fn23 valid-i? :fn24 valid-i? :fn25 valid-i? :fn26 valid-i? :fn27 valid-i? :fn28 valid-i? :fn29 valid-i? :fn30 valid-i? :fn31 valid-i? :fn32 valid-i? :fn33 valid-i? :fn34 valid-i? :fn35 valid-i? :fn36 valid-i? :fn37 valid-i? :fn38 valid-i? :fn39 valid-i? :fn40 valid-i? :fn41 valid-i? :fn42 valid-i? :fn43 valid-i? :fn44 valid-i? :fn45 valid-i? :fn46 valid-i? :fn47 valid-i? :fn48 valid-i? :fn49 valid-i? :fn50 valid-i? :fn51 valid-i? :fn52 valid-i? :fn53 valid-i? :fn54 valid-i? :fn55 valid-i? :fn56 valid-i? :fn57 valid-i? :fn58 valid-i? :fn59 valid-i? :fn60 valid-i? :fn61 valid-i? :fn62 valid-i? :fn63 valid-i? :fn64 valid-i? :fn65 valid-i? :fn66 valid-i? :fn67 valid-i? :fn68 valid-i? :fn69 valid-i? :fn70 valid-i? :fn71 valid-i? :fn72 valid-i? :fn73 valid-i? :fn74 valid-i? :fn75 valid-i? :fn76 valid-i? :fn77 valid-i? :fn78 valid-i? :fn79 valid-i? :fn80 valid-i? :fn81 valid-i? )
         ))
(stest/instrument `s16b14)

(defn tone
  {:arglists '([asig ahp & iskip*] [asig khp & iskip*])}
  [sig hp & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "tone"
                      [sig hp skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef tone
  :args (s/alt
         :aki (s/cat :sig valid-ar? :hp valid-kr? :skip* (s/? valid-i?*) )
         :aai (s/cat :sig valid-ar? :hp valid-ar? :skip* (s/? valid-i?*) )
         ))
(stest/instrument `tone)

(defn tableshufflei
  {:arglists '([itablenum])}
  [tablenum]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "tableshufflei"
                      [tablenum]
                      *global*)]
    (new out-types ast)))

(s/fdef tableshufflei
  :args (s/cat :tablenum valid-i? ))
(stest/instrument `tableshufflei)

(defn prepiano
  {:arglists '([ifreq iNS iD iK iT5 iB kbcl kbcr imass ihvfreq iinit ipos ivel isfreq isspread & irattles* irubbers*])}
  [freq NS D K T5 B bcl bcr mass hvfreq init pos vel sfreq sspread & [ rattles* rubbers* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "prepiano"
                      [freq NS D K T5 B bcl bcr mass hvfreq init pos vel sfreq sspread rattles* rubbers*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef prepiano
  :args (s/cat :freq valid-i? :NS valid-i? :D valid-i? :K valid-i? :T5 valid-i? :B valid-i? :bcl valid-kr? :bcr valid-kr? :mass valid-i? :hvfreq valid-i? :init valid-i? :pos valid-i? :vel valid-i? :sfreq valid-i? :sspread valid-i? :rattles* (s/? valid-i?*) :rubbers* (s/? valid-i?*) ))
(stest/instrument `prepiano)

(defn ptable
  {:arglists '([xindex itable & ixmode* ixoff* iwrap*] [iindex itable & ixmode* ixoff* iwrap*] [xindex itable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "ptable"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef ptable
  :args (s/alt
         :iiiii (s/cat :index valid-i? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) )
         :xiiii (s/cat :index valid-x? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) )
         ))
(stest/instrument `ptable)

(defn ptable:a
  {:arglists '([xindex itable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "ptable"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef ptable:a
  :args (s/cat :index valid-x? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) ))
(stest/instrument `ptable:a)

(defn ptable:i
  {:arglists '([iindex itable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "ptable"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef ptable:i
  :args (s/cat :index valid-i? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) ))
(stest/instrument `ptable:i)

(defn ptable:k
  {:arglists '([xindex itable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "ptable"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef ptable:k
  :args (s/cat :index valid-x? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) ))
(stest/instrument `ptable:k)

(defn zdf_1pole_mode
  {:arglists '([ain xcenter-frequency & istor*])}
  [in center-frequency & [ stor* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "zdf_1pole_mode"
                      [in center-frequency stor*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef zdf_1pole_mode
  :args (s/cat :in valid-ar? :center-frequency valid-x? :stor* (s/? valid-i?*) ))
(stest/instrument `zdf_1pole_mode)

(defn tabmorphi
  {:arglists '([kindex kweightpoint ktabnum3 ktabnum4 & ifn1* ifn2* ifn3* ifn4* ifnN5* ifnN6* ifnN7* ifnN8* ifnN9* ifnN10* ifnN11* ifnN12* ifnN13* ifnN14* ifnN15* ifnN16*])}
  [index weightpoint tabnum3 tabnum4 & [ fn1* fn2* fn3* fn4* fnN5* fnN6* fnN7* fnN8* fnN9* fnN10* fnN11* fnN12* fnN13* fnN14* fnN15* fnN16* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "tabmorphi"
                      [index weightpoint tabnum3 tabnum4 fn1* fn2* fn3* fn4* fnN5* fnN6* fnN7* fnN8* fnN9* fnN10* fnN11* fnN12* fnN13* fnN14* fnN15* fnN16*]
                      *global*)]
    (new out-types ast)))

(s/fdef tabmorphi
  :args (s/cat :index valid-kr? :weightpoint valid-kr? :tabnum3 valid-kr? :tabnum4 valid-kr? :fn1* (s/? valid-i?*) :fn2* (s/? valid-i?*) :fn3* (s/? valid-i?*) :fn4* (s/? valid-i?*) :fnN5* (s/? valid-i?*) :fnN6* (s/? valid-i?*) :fnN7* (s/? valid-i?*) :fnN8* (s/? valid-i?*) :fnN9* (s/? valid-i?*) :fnN10* (s/? valid-i?*) :fnN11* (s/? valid-i?*) :fnN12* (s/? valid-i?*) :fnN13* (s/? valid-i?*) :fnN14* (s/? valid-i?*) :fnN15* (s/? valid-i?*) :fnN16* (s/? valid-i?*) ))
(stest/instrument `tabmorphi)

(defn loscilx
  {:arglists '([xamp kcps itable & iwsize* ibas* istrt* imod* ibeg* iend*])}
  [amp cps table & [ wsize* bas* strt* mod* beg* end* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "loscilx"
                      [amp cps table wsize* bas* strt* mod* beg* end*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef loscilx
  :args (s/cat :amp valid-x? :cps valid-kr? :table valid-i? :wsize* (s/? valid-i?*) :bas* (s/? valid-i?*) :strt* (s/? valid-i?*) :mod* (s/? valid-i?*) :beg* (s/? valid-i?*) :end* (s/? valid-i?*) ))
(stest/instrument `loscilx)

(defn rnd31
  {:arglists '([kscale krpow & iseed*] [iscale irpow & iseed*] [kscale krpow & iseed*])}
  [scale rpow & [ seed* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "rnd31"
                      [scale rpow seed*]
                      *global*)]
    (new out-types ast)))

(s/fdef rnd31
  :args (s/alt
         :iii (s/cat :scale valid-i? :rpow valid-i? :seed* (s/? valid-i?*) )
         :kki (s/cat :scale valid-kr? :rpow valid-kr? :seed* (s/? valid-i?*) )
         ))
(stest/instrument `rnd31)

(defn rnd31:a
  {:arglists '([kscale krpow & iseed*])}
  [scale rpow & [ seed* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "rnd31"
                      [scale rpow seed*]
                      *global*)]
    (new out-types ast)))

(s/fdef rnd31:a
  :args (s/cat :scale valid-kr? :rpow valid-kr? :seed* (s/? valid-i?*) ))
(stest/instrument `rnd31:a)

(defn rnd31:i
  {:arglists '([iscale irpow & iseed*])}
  [scale rpow & [ seed* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "rnd31"
                      [scale rpow seed*]
                      *global*)]
    (new out-types ast)))

(s/fdef rnd31:i
  :args (s/cat :scale valid-i? :rpow valid-i? :seed* (s/? valid-i?*) ))
(stest/instrument `rnd31:i)

(defn rnd31:k
  {:arglists '([kscale krpow & iseed*])}
  [scale rpow & [ seed* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "rnd31"
                      [scale rpow seed*]
                      *global*)]
    (new out-types ast)))

(s/fdef rnd31:k
  :args (s/cat :scale valid-kr? :rpow valid-kr? :seed* (s/? valid-i?*) ))
(stest/instrument `rnd31:k)

(defn duserrnd
  {:arglists '([ktableNum] [itableNum] [ktableNum])}
  [tableNum]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "duserrnd"
                      [tableNum]
                      *global*)]
    (new out-types ast)))

(s/fdef duserrnd
  :args (s/alt
         :i (s/cat :tableNum valid-i? )
         :k (s/cat :tableNum valid-kr? )
         ))
(stest/instrument `duserrnd)

(defn duserrnd:a
  {:arglists '([ktableNum])}
  [tableNum]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "duserrnd"
                      [tableNum]
                      *global*)]
    (new out-types ast)))

(s/fdef duserrnd:a
  :args (s/cat :tableNum valid-kr? ))
(stest/instrument `duserrnd:a)

(defn duserrnd:i
  {:arglists '([itableNum])}
  [tableNum]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "duserrnd"
                      [tableNum]
                      *global*)]
    (new out-types ast)))

(s/fdef duserrnd:i
  :args (s/cat :tableNum valid-i? ))
(stest/instrument `duserrnd:i)

(defn duserrnd:k
  {:arglists '([ktableNum])}
  [tableNum]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "duserrnd"
                      [tableNum]
                      *global*)]
    (new out-types ast)))

(s/fdef duserrnd:k
  :args (s/cat :tableNum valid-kr? ))
(stest/instrument `duserrnd:k)

(defn outz
  {:arglists '([ksig1])}
  [sig1]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outz"
                      [sig1]
                      *global*)]
    (new out-types ast)))

(s/fdef outz
  :args (s/cat :sig1 valid-kr? ))
(stest/instrument `outz)

(defn pvsifd
  {:arglists '([ain ifftsize ihopsize iwintype & iscal*])}
  [in fftsize hopsize wintype & [ scal* ]]
  (let [out-types-quoted '[FrequencySignal FrequencySignal]
        out-types [FrequencySignal FrequencySignal]
        ast (ast-node out-types-quoted
                      "pvsifd"
                      [in fftsize hopsize wintype scal*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef pvsifd
  :args (s/cat :in valid-ar? :fftsize valid-i? :hopsize valid-i? :wintype valid-i? :scal* (s/? valid-i?*) ))
(stest/instrument `pvsifd)

(defn setksmps
  {:arglists '([iksmps])}
  [ksmps]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "setksmps"
                      [ksmps]
                      *global*)]
    (new out-types ast)))

(s/fdef setksmps
  :args (s/cat :ksmps valid-i? ))
(stest/instrument `setksmps)

(defn mode
  {:arglists '([ain xfreq xQ & iskip*])}
  [in freq Q & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "mode"
                      [in freq Q skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef mode
  :args (s/cat :in valid-ar? :freq valid-x? :Q valid-x? :skip* (s/? valid-i?*) ))
(stest/instrument `mode)

(defn ftsavek
  {:arglists '([Sfilename ktrig iflag & ifn1* ifn2* ifn3* ifn4* ifn5* ifn6* ifn7* ifn8* ifn9* ifn10* ifn11* ifn12* ifn13* ifn14* ifn15* ifn16*] [ifilename ktrig iflag & ifn1* ifn2* ifn3* ifn4* ifn5* ifn6* ifn7* ifn8* ifn9* ifn10* ifn11* ifn12* ifn13* ifn14* ifn15* ifn16*])}
  [filename trig flag & [ fn1* fn2* fn3* fn4* fn5* fn6* fn7* fn8* fn9* fn10* fn11* fn12* fn13* fn14* fn15* fn16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "ftsavek"
                      [filename trig flag fn1* fn2* fn3* fn4* fn5* fn6* fn7* fn8* fn9* fn10* fn11* fn12* fn13* fn14* fn15* fn16*]
                      *global*)]
    (new out-types ast)))

(s/fdef ftsavek
  :args (s/alt
         :ikiiiiiiiiiiiiiiiii (s/cat :filename valid-i? :trig valid-kr? :flag valid-i? :fn1* (s/? valid-i?*) :fn2* (s/? valid-i?*) :fn3* (s/? valid-i?*) :fn4* (s/? valid-i?*) :fn5* (s/? valid-i?*) :fn6* (s/? valid-i?*) :fn7* (s/? valid-i?*) :fn8* (s/? valid-i?*) :fn9* (s/? valid-i?*) :fn10* (s/? valid-i?*) :fn11* (s/? valid-i?*) :fn12* (s/? valid-i?*) :fn13* (s/? valid-i?*) :fn14* (s/? valid-i?*) :fn15* (s/? valid-i?*) :fn16* (s/? valid-i?*) )
         :Skiiiiiiiiiiiiiiiii (s/cat :filename valid-S? :trig valid-kr? :flag valid-i? :fn1* (s/? valid-i?*) :fn2* (s/? valid-i?*) :fn3* (s/? valid-i?*) :fn4* (s/? valid-i?*) :fn5* (s/? valid-i?*) :fn6* (s/? valid-i?*) :fn7* (s/? valid-i?*) :fn8* (s/? valid-i?*) :fn9* (s/? valid-i?*) :fn10* (s/? valid-i?*) :fn11* (s/? valid-i?*) :fn12* (s/? valid-i?*) :fn13* (s/? valid-i?*) :fn14* (s/? valid-i?*) :fn15* (s/? valid-i?*) :fn16* (s/? valid-i?*) )
         ))
(stest/instrument `ftsavek)

(defn linen
  {:arglists '([aamp irise idur idec] [kamp irise idur idec] [kamp irise idur idec])}
  [amp rise dur dec]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "linen"
                      [amp rise dur dec]
                      *global*)]
    (new out-types ast)))

(s/fdef linen
  :args (s/alt
         :kiii (s/cat :amp valid-kr? :rise valid-i? :dur valid-i? :dec valid-i? )
         :aiii (s/cat :amp valid-ar? :rise valid-i? :dur valid-i? :dec valid-i? )
         ))
(stest/instrument `linen)

(defn linen:a
  {:arglists '([aamp irise idur idec] [kamp irise idur idec])}
  [amp rise dur dec]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "linen"
                      [amp rise dur dec]
                      *global*)]
    (new out-types ast)))

(s/fdef linen:a
  :args (s/alt
         :kiii (s/cat :amp valid-kr? :rise valid-i? :dur valid-i? :dec valid-i? )
         :aiii (s/cat :amp valid-ar? :rise valid-i? :dur valid-i? :dec valid-i? )
         ))
(stest/instrument `linen:a)

(defn linen:k
  {:arglists '([kamp irise idur idec])}
  [amp rise dur dec]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "linen"
                      [amp rise dur dec]
                      *global*)]
    (new out-types ast)))

(s/fdef linen:k
  :args (s/cat :amp valid-kr? :rise valid-i? :dur valid-i? :dec valid-i? ))
(stest/instrument `linen:k)

(defn phasorbnk
  {:arglists '([xcps kindex icnt & iphase*] [xcps kindex icnt & iphase*])}
  [cps index cnt & [ phase* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "phasorbnk"
                      [cps index cnt phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef phasorbnk
  :args (s/alt
         :xkii (s/cat :cps valid-x? :index valid-kr? :cnt valid-i? :phase* (s/? valid-i?*) )
         ))
(stest/instrument `phasorbnk)

(defn phasorbnk:a
  {:arglists '([xcps kindex icnt & iphase*])}
  [cps index cnt & [ phase* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "phasorbnk"
                      [cps index cnt phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef phasorbnk:a
  :args (s/cat :cps valid-x? :index valid-kr? :cnt valid-i? :phase* (s/? valid-i?*) ))
(stest/instrument `phasorbnk:a)

(defn phasorbnk:k
  {:arglists '([xcps kindex icnt & iphase*])}
  [cps index cnt & [ phase* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "phasorbnk"
                      [cps index cnt phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef phasorbnk:k
  :args (s/cat :cps valid-x? :index valid-kr? :cnt valid-i? :phase* (s/? valid-i?*) ))
(stest/instrument `phasorbnk:k)

(defn pvscale
  {:arglists '([fsigin kscal & kkeepform* kgain* kcoefs*] [fsigin xscal & kkeepform* kgain* kcoefs*])}
  [sigin scal & [ keepform* gain* coefs* ]]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvscale"
                      [sigin scal keepform* gain* coefs*]
                      *global*)]
    (new out-types ast)))

(s/fdef pvscale
  :args (s/alt
         :fxkkk (s/cat :sigin valid-f? :scal valid-x? :keepform* (s/? valid-kr?*) :gain* (s/? valid-kr?*) :coefs* (s/? valid-kr?*) )
         :fkkkk (s/cat :sigin valid-f? :scal valid-kr? :keepform* (s/? valid-kr?*) :gain* (s/? valid-kr?*) :coefs* (s/? valid-kr?*) )
         ))
(stest/instrument `pvscale)

(defn product
  {:arglists '([& asignalorarray1* asig2* asig3* asig4* asig5* asig6* asig7* asig8* asig9* asig10* asig11* asig12* asig13* asig14* asig15* asig16* asig17* asig18* asig19* asig20* asig21* asig22* asig23* asig24* asig25* asig26* asig27* asig28* asig29* asig30* asig31* asig32*] [isignalorarrayArr] [ksignalorarrayArr])}
  [& [ signalorarray1* sig2* sig3* sig4* sig5* sig6* sig7* sig8* sig9* sig10* sig11* sig12* sig13* sig14* sig15* sig16* sig17* sig18* sig19* sig20* sig21* sig22* sig23* sig24* sig25* sig26* sig27* sig28* sig29* sig30* sig31* sig32* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "product"
                      [signalorarray1* sig2* sig3* sig4* sig5* sig6* sig7* sig8* sig9* sig10* sig11* sig12* sig13* sig14* sig15* sig16* sig17* sig18* sig19* sig20* sig21* sig22* sig23* sig24* sig25* sig26* sig27* sig28* sig29* sig30* sig31* sig32*]
                      *global*)]
    (new out-types ast)))

(s/fdef product
  :args (s/alt
         :kArr (s/cat :signalorarray valid-kArr? )
         :iArr (s/cat :signalorarray valid-iArr? )
         :aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa (s/cat :signalorarray1* (s/? valid-ar?*) :sig2* (s/? valid-ar?*) :sig3* (s/? valid-ar?*) :sig4* (s/? valid-ar?*) :sig5* (s/? valid-ar?*) :sig6* (s/? valid-ar?*) :sig7* (s/? valid-ar?*) :sig8* (s/? valid-ar?*) :sig9* (s/? valid-ar?*) :sig10* (s/? valid-ar?*) :sig11* (s/? valid-ar?*) :sig12* (s/? valid-ar?*) :sig13* (s/? valid-ar?*) :sig14* (s/? valid-ar?*) :sig15* (s/? valid-ar?*) :sig16* (s/? valid-ar?*) :sig17* (s/? valid-ar?*) :sig18* (s/? valid-ar?*) :sig19* (s/? valid-ar?*) :sig20* (s/? valid-ar?*) :sig21* (s/? valid-ar?*) :sig22* (s/? valid-ar?*) :sig23* (s/? valid-ar?*) :sig24* (s/? valid-ar?*) :sig25* (s/? valid-ar?*) :sig26* (s/? valid-ar?*) :sig27* (s/? valid-ar?*) :sig28* (s/? valid-ar?*) :sig29* (s/? valid-ar?*) :sig30* (s/? valid-ar?*) :sig31* (s/? valid-ar?*) :sig32* (s/? valid-ar?*) )
         ))
(stest/instrument `product)

(defn product:a
  {:arglists '([& asignalorarray1* asig2* asig3* asig4* asig5* asig6* asig7* asig8* asig9* asig10* asig11* asig12* asig13* asig14* asig15* asig16* asig17* asig18* asig19* asig20* asig21* asig22* asig23* asig24* asig25* asig26* asig27* asig28* asig29* asig30* asig31* asig32*])}
  [& [ signalorarray1* sig2* sig3* sig4* sig5* sig6* sig7* sig8* sig9* sig10* sig11* sig12* sig13* sig14* sig15* sig16* sig17* sig18* sig19* sig20* sig21* sig22* sig23* sig24* sig25* sig26* sig27* sig28* sig29* sig30* sig31* sig32* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "product"
                      [signalorarray1* sig2* sig3* sig4* sig5* sig6* sig7* sig8* sig9* sig10* sig11* sig12* sig13* sig14* sig15* sig16* sig17* sig18* sig19* sig20* sig21* sig22* sig23* sig24* sig25* sig26* sig27* sig28* sig29* sig30* sig31* sig32*]
                      *global*)]
    (new out-types ast)))

(s/fdef product:a
  :args (s/cat :signalorarray1* (s/? valid-ar?*) :sig2* (s/? valid-ar?*) :sig3* (s/? valid-ar?*) :sig4* (s/? valid-ar?*) :sig5* (s/? valid-ar?*) :sig6* (s/? valid-ar?*) :sig7* (s/? valid-ar?*) :sig8* (s/? valid-ar?*) :sig9* (s/? valid-ar?*) :sig10* (s/? valid-ar?*) :sig11* (s/? valid-ar?*) :sig12* (s/? valid-ar?*) :sig13* (s/? valid-ar?*) :sig14* (s/? valid-ar?*) :sig15* (s/? valid-ar?*) :sig16* (s/? valid-ar?*) :sig17* (s/? valid-ar?*) :sig18* (s/? valid-ar?*) :sig19* (s/? valid-ar?*) :sig20* (s/? valid-ar?*) :sig21* (s/? valid-ar?*) :sig22* (s/? valid-ar?*) :sig23* (s/? valid-ar?*) :sig24* (s/? valid-ar?*) :sig25* (s/? valid-ar?*) :sig26* (s/? valid-ar?*) :sig27* (s/? valid-ar?*) :sig28* (s/? valid-ar?*) :sig29* (s/? valid-ar?*) :sig30* (s/? valid-ar?*) :sig31* (s/? valid-ar?*) :sig32* (s/? valid-ar?*) ))
(stest/instrument `product:a)

(defn product:i
  {:arglists '([isignalorarrayArr])}
  [signalorarray]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "product"
                      [signalorarray]
                      *global*)]
    (new out-types ast)))

(s/fdef product:i
  :args (s/cat :signalorarray valid-iArr? ))
(stest/instrument `product:i)

(defn product:k
  {:arglists '([ksignalorarrayArr])}
  [signalorarray]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "product"
                      [signalorarray]
                      *global*)]
    (new out-types ast)))

(s/fdef product:k
  :args (s/cat :signalorarray valid-kArr? ))
(stest/instrument `product:k)

(defn turnon
  {:arglists '([Sinsnum & itime*] [iinsnum & itime*])}
  [insnum & [ time* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "turnon"
                      [insnum time*]
                      *global*)]
    (new out-types ast)))

(s/fdef turnon
  :args (s/alt
         :ii (s/cat :insnum valid-i? :time* (s/? valid-i?*) )
         :Si (s/cat :insnum valid-S? :time* (s/? valid-i?*) )
         ))
(stest/instrument `turnon)

(defn strcatk
  {:arglists '([Ssrc1 Ssrc2])}
  [src1 src2]
  (let [out-types-quoted 'String
        out-types String
        ast (ast-node out-types-quoted
                      "strcatk"
                      [src1 src2]
                      *global*)]
    (new out-types ast)))

(s/fdef strcatk
  :args (s/cat :src1 valid-S? :src2 valid-S? ))
(stest/instrument `strcatk)

(defn scantable
  {:arglists '([kamp kpch ipos imass istiff idamp ivel])}
  [amp pch pos mass stiff damp vel]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "scantable"
                      [amp pch pos mass stiff damp vel]
                      *global*)]
    (new out-types ast)))

(s/fdef scantable
  :args (s/cat :amp valid-kr? :pch valid-kr? :pos valid-i? :mass valid-i? :stiff valid-i? :damp valid-i? :vel valid-i? ))
(stest/instrument `scantable)

(defn vaget
  {:arglists '([kindex avar])}
  [index var]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "vaget"
                      [index var]
                      *global*)]
    (new out-types ast)))

(s/fdef vaget
  :args (s/cat :index valid-kr? :var valid-ar? ))
(stest/instrument `vaget)

(defn schedwhen
  {:arglists '([ktrigger Sinsname kwhen kdur & ip1* ip2* ip3* ip4* ip5* ip6* ip7* ip8* ip9* ip10* ip11* ip12* ip13* ip14* ip15* ip16*] [ktrigger kinsname kwhen kdur & ip1* ip2* ip3* ip4* ip5* ip6* ip7* ip8* ip9* ip10* ip11* ip12* ip13* ip14* ip15* ip16*])}
  [trigger insname when dur & [ p1* p2* p3* p4* p5* p6* p7* p8* p9* p10* p11* p12* p13* p14* p15* p16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "schedwhen"
                      [trigger insname when dur p1* p2* p3* p4* p5* p6* p7* p8* p9* p10* p11* p12* p13* p14* p15* p16*]
                      *global*)]
    (new out-types ast)))

(s/fdef schedwhen
  :args (s/alt
         :kkkkiiiiiiiiiiiiiiii (s/cat :trigger valid-kr? :insname valid-kr? :when valid-kr? :dur valid-kr? :p1* (s/? valid-i?*) :p2* (s/? valid-i?*) :p3* (s/? valid-i?*) :p4* (s/? valid-i?*) :p5* (s/? valid-i?*) :p6* (s/? valid-i?*) :p7* (s/? valid-i?*) :p8* (s/? valid-i?*) :p9* (s/? valid-i?*) :p10* (s/? valid-i?*) :p11* (s/? valid-i?*) :p12* (s/? valid-i?*) :p13* (s/? valid-i?*) :p14* (s/? valid-i?*) :p15* (s/? valid-i?*) :p16* (s/? valid-i?*) )
         :kSkkiiiiiiiiiiiiiiii (s/cat :trigger valid-kr? :insname valid-S? :when valid-kr? :dur valid-kr? :p1* (s/? valid-i?*) :p2* (s/? valid-i?*) :p3* (s/? valid-i?*) :p4* (s/? valid-i?*) :p5* (s/? valid-i?*) :p6* (s/? valid-i?*) :p7* (s/? valid-i?*) :p8* (s/? valid-i?*) :p9* (s/? valid-i?*) :p10* (s/? valid-i?*) :p11* (s/? valid-i?*) :p12* (s/? valid-i?*) :p13* (s/? valid-i?*) :p14* (s/? valid-i?*) :p15* (s/? valid-i?*) :p16* (s/? valid-i?*) )
         ))
(stest/instrument `schedwhen)

(defn resony
  {:arglists '([asig kbf kbandwidth inum ksep & isepmode* iscale* iskip*])}
  [sig bf bandwidth num sep & [ sepmode* scale* skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "resony"
                      [sig bf bandwidth num sep sepmode* scale* skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef resony
  :args (s/cat :sig valid-ar? :bf valid-kr? :bandwidth valid-kr? :num valid-i? :sep valid-kr? :sepmode* (s/? valid-i?*) :scale* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `resony)

(defn outkpb
  {:arglists '([kchn kvalue kmin kmax])}
  [chn value min max]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outkpb"
                      [chn value min max]
                      *global*)]
    (new out-types ast)))

(s/fdef outkpb
  :args (s/cat :chn valid-kr? :value valid-kr? :min valid-kr? :max valid-kr? ))
(stest/instrument `outkpb)

(defn joystick
  {:arglists '([kdevice ktab])}
  [device tab]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "joystick"
                      [device tab]
                      *global*)]
    (new out-types ast)))

(s/fdef joystick
  :args (s/cat :device valid-kr? :tab valid-kr? ))
(stest/instrument `joystick)

(defn times
  {:arglists '( )}
  []
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "times"
                      []
                      *global*)]
    (new out-types ast)))


(defn times:i
  {:arglists '()}
  []
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "times"
                      []
                      *global*)]
    (new out-types ast)))


(defn times:k
  {:arglists '()}
  []
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "times"
                      []
                      *global*)]
    (new out-types ast)))


(defn nreverb
  {:arglists '([asig ktime khdif & iskip* inumCombs* ifnCombs* inumAlpas* ifnAlpas*])}
  [sig time hdif & [ skip* numCombs* fnCombs* numAlpas* fnAlpas* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "nreverb"
                      [sig time hdif skip* numCombs* fnCombs* numAlpas* fnAlpas*]
                      *global*)]
    (new out-types ast)))

(s/fdef nreverb
  :args (s/cat :sig valid-ar? :time valid-kr? :hdif valid-kr? :skip* (s/? valid-i?*) :numCombs* (s/? valid-i?*) :fnCombs* (s/? valid-i?*) :numAlpas* (s/? valid-i?*) :fnAlpas* (s/? valid-i?*) ))
(stest/instrument `nreverb)

(defn max_k
  {:arglists '([asig ktrig itype])}
  [sig trig type]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "max_k"
                      [sig trig type]
                      *global*)]
    (new out-types ast)))

(s/fdef max_k
  :args (s/cat :sig valid-ar? :trig valid-kr? :type valid-i? ))
(stest/instrument `max_k)

(defn distort1
  {:arglists '([asig kpregain kpostgain kshape4 kshape5 & imode*])}
  [sig pregain postgain shape4 shape5 & [ mode* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "distort1"
                      [sig pregain postgain shape4 shape5 mode*]
                      *global*)]
    (new out-types ast)))

(s/fdef distort1
  :args (s/cat :sig valid-ar? :pregain valid-kr? :postgain valid-kr? :shape4 valid-kr? :shape5 valid-kr? :mode* (s/? valid-i?*) ))
(stest/instrument `distort1)

(defn K35_hpf
  {:arglists '([ain xcenter-frequency xQ & knlp* ksaturation* istor*])}
  [in center-frequency Q & [ nlp* saturation* stor* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "K35_hpf"
                      [in center-frequency Q nlp* saturation* stor*]
                      *global*)]
    (new out-types ast)))

(s/fdef K35_hpf
  :args (s/cat :in valid-ar? :center-frequency valid-x? :Q valid-x? :nlp* (s/? valid-kr?*) :saturation* (s/? valid-kr?*) :stor* (s/? valid-i?*) ))
(stest/instrument `K35_hpf)

(defn prints
  {:arglists '([Sstring & xval1* xval2* xval3* xval4* xval5* xval6* xval7* xval8* xval9* xval10* xval11* xval12* xval13* xval14* xval15* xval16*] [istring & xval1* xval2* xval3* xval4* xval5* xval6* xval7* xval8* xval9* xval10* xval11* xval12* xval13* xval14* xval15* xval16*])}
  [string & [ val1* val2* val3* val4* val5* val6* val7* val8* val9* val10* val11* val12* val13* val14* val15* val16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "prints"
                      [string val1* val2* val3* val4* val5* val6* val7* val8* val9* val10* val11* val12* val13* val14* val15* val16*]
                      *global*)]
    (new out-types ast)))

(s/fdef prints
  :args (s/alt
         :ixxxxxxxxxxxxxxxx (s/cat :string valid-i? :val1* (s/? valid-x?*) :val2* (s/? valid-x?*) :val3* (s/? valid-x?*) :val4* (s/? valid-x?*) :val5* (s/? valid-x?*) :val6* (s/? valid-x?*) :val7* (s/? valid-x?*) :val8* (s/? valid-x?*) :val9* (s/? valid-x?*) :val10* (s/? valid-x?*) :val11* (s/? valid-x?*) :val12* (s/? valid-x?*) :val13* (s/? valid-x?*) :val14* (s/? valid-x?*) :val15* (s/? valid-x?*) :val16* (s/? valid-x?*) )
         :Sxxxxxxxxxxxxxxxx (s/cat :string valid-S? :val1* (s/? valid-x?*) :val2* (s/? valid-x?*) :val3* (s/? valid-x?*) :val4* (s/? valid-x?*) :val5* (s/? valid-x?*) :val6* (s/? valid-x?*) :val7* (s/? valid-x?*) :val8* (s/? valid-x?*) :val9* (s/? valid-x?*) :val10* (s/? valid-x?*) :val11* (s/? valid-x?*) :val12* (s/? valid-x?*) :val13* (s/? valid-x?*) :val14* (s/? valid-x?*) :val15* (s/? valid-x?*) :val16* (s/? valid-x?*) )
         ))
(stest/instrument `prints)

(defn oscil1
  {:arglists '([idel kamp idur & itable*])}
  [del amp dur & [ table* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "oscil1"
                      [del amp dur table*]
                      *global*)]
    (new out-types ast)))

(s/fdef oscil1
  :args (s/cat :del valid-i? :amp valid-kr? :dur valid-i? :table* (s/? valid-i?*) ))
(stest/instrument `oscil1)

(defn upsamp
  {:arglists '([ksig])}
  [sig]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "upsamp"
                      [sig]
                      *global*)]
    (new out-types ast)))

(s/fdef upsamp
  :args (s/cat :sig valid-kr? ))
(stest/instrument `upsamp)

(defn portk
  {:arglists '([ksig khtim & isig*])}
  [sig htim & [ sig* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "portk"
                      [sig htim sig*]
                      *global*)]
    (new out-types ast)))

(s/fdef portk
  :args (s/cat :sig valid-kr? :htim valid-kr? :sig* (s/? valid-i?*) ))
(stest/instrument `portk)

(defn reverb2
  {:arglists '([asig ktime khdif & iskip* inumCombs* ifnCombs* inumAlpas* ifnAlpas*])}
  [sig time hdif & [ skip* numCombs* fnCombs* numAlpas* fnAlpas* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "reverb2"
                      [sig time hdif skip* numCombs* fnCombs* numAlpas* fnAlpas*]
                      *global*)]
    (new out-types ast)))

(s/fdef reverb2
  :args (s/cat :sig valid-ar? :time valid-kr? :hdif valid-kr? :skip* (s/? valid-i?*) :numCombs* (s/? valid-i?*) :fnCombs* (s/? valid-i?*) :numAlpas* (s/? valid-i?*) :fnAlpas* (s/? valid-i?*) ))
(stest/instrument `reverb2)

(defn schedule
  {:arglists '([Sinsname iwhen idur & xp1* xp2* xp3* xp4* xp5* xp6* xp7* xp8* xp9* xp10* xp11* xp12* xp13* xp14* xp15* xp16*] [Sinsname iwhen idur & ip1* ip2* ip3* ip4* ip5* ip6* ip7* ip8* ip9* ip10* ip11* ip12* ip13* ip14* ip15* ip16*] [iinsname iwhen idur & xp1* xp2* xp3* xp4* xp5* xp6* xp7* xp8* xp9* xp10* xp11* xp12* xp13* xp14* xp15* xp16*] [iinsname iwhen idur & ip1* ip2* ip3* ip4* ip5* ip6* ip7* ip8* ip9* ip10* ip11* ip12* ip13* ip14* ip15* ip16*])}
  [insname when dur & [ p1* p2* p3* p4* p5* p6* p7* p8* p9* p10* p11* p12* p13* p14* p15* p16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "schedule"
                      [insname when dur p1* p2* p3* p4* p5* p6* p7* p8* p9* p10* p11* p12* p13* p14* p15* p16*]
                      *global*)]
    (new out-types ast)))

(s/fdef schedule
  :args (s/alt
         :iiiiiiiiiiiiiiiiiii (s/cat :insname valid-i? :when valid-i? :dur valid-i? :p1* (s/? valid-i?*) :p2* (s/? valid-i?*) :p3* (s/? valid-i?*) :p4* (s/? valid-i?*) :p5* (s/? valid-i?*) :p6* (s/? valid-i?*) :p7* (s/? valid-i?*) :p8* (s/? valid-i?*) :p9* (s/? valid-i?*) :p10* (s/? valid-i?*) :p11* (s/? valid-i?*) :p12* (s/? valid-i?*) :p13* (s/? valid-i?*) :p14* (s/? valid-i?*) :p15* (s/? valid-i?*) :p16* (s/? valid-i?*) )
         :iiixxxxxxxxxxxxxxxx (s/cat :insname valid-i? :when valid-i? :dur valid-i? :p1* (s/? valid-x?*) :p2* (s/? valid-x?*) :p3* (s/? valid-x?*) :p4* (s/? valid-x?*) :p5* (s/? valid-x?*) :p6* (s/? valid-x?*) :p7* (s/? valid-x?*) :p8* (s/? valid-x?*) :p9* (s/? valid-x?*) :p10* (s/? valid-x?*) :p11* (s/? valid-x?*) :p12* (s/? valid-x?*) :p13* (s/? valid-x?*) :p14* (s/? valid-x?*) :p15* (s/? valid-x?*) :p16* (s/? valid-x?*) )
         :Siiiiiiiiiiiiiiiiii (s/cat :insname valid-S? :when valid-i? :dur valid-i? :p1* (s/? valid-i?*) :p2* (s/? valid-i?*) :p3* (s/? valid-i?*) :p4* (s/? valid-i?*) :p5* (s/? valid-i?*) :p6* (s/? valid-i?*) :p7* (s/? valid-i?*) :p8* (s/? valid-i?*) :p9* (s/? valid-i?*) :p10* (s/? valid-i?*) :p11* (s/? valid-i?*) :p12* (s/? valid-i?*) :p13* (s/? valid-i?*) :p14* (s/? valid-i?*) :p15* (s/? valid-i?*) :p16* (s/? valid-i?*) )
         :Siixxxxxxxxxxxxxxxx (s/cat :insname valid-S? :when valid-i? :dur valid-i? :p1* (s/? valid-x?*) :p2* (s/? valid-x?*) :p3* (s/? valid-x?*) :p4* (s/? valid-x?*) :p5* (s/? valid-x?*) :p6* (s/? valid-x?*) :p7* (s/? valid-x?*) :p8* (s/? valid-x?*) :p9* (s/? valid-x?*) :p10* (s/? valid-x?*) :p11* (s/? valid-x?*) :p12* (s/? valid-x?*) :p13* (s/? valid-x?*) :p14* (s/? valid-x?*) :p15* (s/? valid-x?*) :p16* (s/? valid-x?*) )
         ))
(stest/instrument `schedule)

(defn dssilist
  {:arglists '()}
  []
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "dssilist"
                      []
                      *global*)]
    (new out-types ast)))


(defn wgbrass
  {:arglists '([kamp kfreq ktens iatt kvibf kvamp & itable* iminfreq*])}
  [amp freq tens att vibf vamp & [ table* minfreq* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "wgbrass"
                      [amp freq tens att vibf vamp table* minfreq*]
                      *global*)]
    (new out-types ast)))

(s/fdef wgbrass
  :args (s/cat :amp valid-kr? :freq valid-kr? :tens valid-kr? :att valid-i? :vibf valid-kr? :vamp valid-kr? :table* (s/? valid-i?*) :minfreq* (s/? valid-i?*) ))
(stest/instrument `wgbrass)

(defn sc_phasor
  {:arglists '([atrig arate kstart kend & kresetPos*] [atrig krate kstart kend & kresetPos*] [ktrig krate kstart kend & kresetPos*])}
  [trig rate start end & [ resetPos* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "sc_phasor"
                      [trig rate start end resetPos*]
                      *global*)]
    (new out-types ast)))

(s/fdef sc_phasor
  :args (s/alt
         :kkkkk (s/cat :trig valid-kr? :rate valid-kr? :start valid-kr? :end valid-kr? :resetPos* (s/? valid-kr?*) )
         :akkkk (s/cat :trig valid-ar? :rate valid-kr? :start valid-kr? :end valid-kr? :resetPos* (s/? valid-kr?*) )
         :aakkk (s/cat :trig valid-ar? :rate valid-ar? :start valid-kr? :end valid-kr? :resetPos* (s/? valid-kr?*) )
         ))
(stest/instrument `sc_phasor)

(defn sc_phasor:a
  {:arglists '([atrig arate kstart kend & kresetPos*] [atrig krate kstart kend & kresetPos*])}
  [trig rate start end & [ resetPos* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "sc_phasor"
                      [trig rate start end resetPos*]
                      *global*)]
    (new out-types ast)))

(s/fdef sc_phasor:a
  :args (s/alt
         :akkkk (s/cat :trig valid-ar? :rate valid-kr? :start valid-kr? :end valid-kr? :resetPos* (s/? valid-kr?*) )
         :aakkk (s/cat :trig valid-ar? :rate valid-ar? :start valid-kr? :end valid-kr? :resetPos* (s/? valid-kr?*) )
         ))
(stest/instrument `sc_phasor:a)

(defn sc_phasor:k
  {:arglists '([ktrig krate kstart kend & kresetPos*])}
  [trig rate start end & [ resetPos* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "sc_phasor"
                      [trig rate start end resetPos*]
                      *global*)]
    (new out-types ast)))

(s/fdef sc_phasor:k
  :args (s/cat :trig valid-kr? :rate valid-kr? :start valid-kr? :end valid-kr? :resetPos* (s/? valid-kr?*) ))
(stest/instrument `sc_phasor:k)

(defn readscore
  {:arglists '([Sin])}
  [in]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "readscore"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef readscore
  :args (s/cat :in valid-S? ))
(stest/instrument `readscore)

(defn sin
  {:arglists '([aarg1] [iarg1] [iarg1Arr] [karg1] [karg1Arr])}
  [arg1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "sin"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sin
  :args (s/alt
         :kArr (s/cat :arg1 valid-kArr? )
         :k (s/cat :arg1 valid-kr? )
         :iArr (s/cat :arg1 valid-iArr? )
         :i (s/cat :arg1 valid-i? )
         :a (s/cat :arg1 valid-ar? )
         ))
(stest/instrument `sin)

(defn sin:a
  {:arglists '([aarg1])}
  [arg1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "sin"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sin:a
  :args (s/cat :arg1 valid-ar? ))
(stest/instrument `sin:a)

(defn sin:i
  {:arglists '([iarg1])}
  [arg1]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "sin"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sin:i
  :args (s/cat :arg1 valid-i? ))
(stest/instrument `sin:i)

(defn sin:iArr
  {:arglists '([iarg1Arr])}
  [arg1]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "sin"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sin:iArr
  :args (s/cat :arg1 valid-iArr? ))
(stest/instrument `sin:iArr)

(defn sin:k
  {:arglists '([karg1])}
  [arg1]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "sin"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sin:k
  :args (s/cat :arg1 valid-kr? ))
(stest/instrument `sin:k)

(defn sin:kArr
  {:arglists '([karg1Arr])}
  [arg1]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "sin"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sin:kArr
  :args (s/cat :arg1 valid-kArr? ))
(stest/instrument `sin:kArr)

(defn vexpseg
  {:arglists '([ifnout ielements & ifn1* idur2* ifn3* idur4* ifn5* ifn6* ifn7* ifn8* ifn9* ifn10* ifn11* ifn12* ifn13* ifn14* ifn15* ifn16*])}
  [fnout elements & [ fn1* dur2* fn3* dur4* fn5* fn6* fn7* fn8* fn9* fn10* fn11* fn12* fn13* fn14* fn15* fn16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vexpseg"
                      [fnout elements fn1* dur2* fn3* dur4* fn5* fn6* fn7* fn8* fn9* fn10* fn11* fn12* fn13* fn14* fn15* fn16*]
                      *global*)]
    (new out-types ast)))

(s/fdef vexpseg
  :args (s/cat :fnout valid-i? :elements valid-i? :fn1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :fn3* (s/? valid-i?*) :dur4* (s/? valid-i?*) :fn5* (s/? valid-i?*) :fn6* (s/? valid-i?*) :fn7* (s/? valid-i?*) :fn8* (s/? valid-i?*) :fn9* (s/? valid-i?*) :fn10* (s/? valid-i?*) :fn11* (s/? valid-i?*) :fn12* (s/? valid-i?*) :fn13* (s/? valid-i?*) :fn14* (s/? valid-i?*) :fn15* (s/? valid-i?*) :fn16* (s/? valid-i?*) ))
(stest/instrument `vexpseg)

(defn pvsdiskin
  {:arglists '([SFname ktscal kgain & ioffset* ichan* kchan*] [iFname ktscal kgain & ioffset* ichan* kchan*])}
  [Fname tscal gain & [ offset* chan* chan* ]]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvsdiskin"
                      [Fname tscal gain offset* chan* chan*]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsdiskin
  :args (s/alt
         :ikkiik (s/cat :Fname valid-i? :tscal valid-kr? :gain valid-kr? :offset* (s/? valid-i?*) :chan* (s/? valid-i?*) :chan* (s/? valid-kr?*) )
         :Skkiik (s/cat :Fname valid-S? :tscal valid-kr? :gain valid-kr? :offset* (s/? valid-i?*) :chan* (s/? valid-i?*) :chan* (s/? valid-kr?*) )
         ))
(stest/instrument `pvsdiskin)

(defn outq2
  {:arglists '([asig])}
  [sig]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outq2"
                      [sig]
                      *global*)]
    (new out-types ast)))

(s/fdef outq2
  :args (s/cat :sig valid-ar? ))
(stest/instrument `outq2)

(defn MixerGetLevel
  {:arglists '([isend ibuss])}
  [send buss]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "MixerGetLevel"
                      [send buss]
                      *global*)]
    (new out-types ast)))

(s/fdef MixerGetLevel
  :args (s/cat :send valid-i? :buss valid-i? ))
(stest/instrument `MixerGetLevel)

(defn limit
  {:arglists '([asig klow khigh] [isig ilow ihigh] [isigArr ilow ihigh] [ksig klow khigh] [ksigArr klow khigh])}
  [sig low high]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "limit"
                      [sig low high]
                      *global*)]
    (new out-types ast)))

(s/fdef limit
  :args (s/alt
         :kArrkk (s/cat :sig valid-kArr? :low valid-kr? :high valid-kr? )
         :kkk (s/cat :sig valid-kr? :low valid-kr? :high valid-kr? )
         :iArrii (s/cat :sig valid-iArr? :low valid-i? :high valid-i? )
         :iii (s/cat :sig valid-i? :low valid-i? :high valid-i? )
         :akk (s/cat :sig valid-ar? :low valid-kr? :high valid-kr? )
         ))
(stest/instrument `limit)

(defn limit:a
  {:arglists '([asig klow khigh])}
  [sig low high]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "limit"
                      [sig low high]
                      *global*)]
    (new out-types ast)))

(s/fdef limit:a
  :args (s/cat :sig valid-ar? :low valid-kr? :high valid-kr? ))
(stest/instrument `limit:a)

(defn limit:i
  {:arglists '([isig ilow ihigh])}
  [sig low high]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "limit"
                      [sig low high]
                      *global*)]
    (new out-types ast)))

(s/fdef limit:i
  :args (s/cat :sig valid-i? :low valid-i? :high valid-i? ))
(stest/instrument `limit:i)

(defn limit:iArr
  {:arglists '([isigArr ilow ihigh])}
  [sig low high]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "limit"
                      [sig low high]
                      *global*)]
    (new out-types ast)))

(s/fdef limit:iArr
  :args (s/cat :sig valid-iArr? :low valid-i? :high valid-i? ))
(stest/instrument `limit:iArr)

(defn limit:k
  {:arglists '([ksig klow khigh])}
  [sig low high]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "limit"
                      [sig low high]
                      *global*)]
    (new out-types ast)))

(s/fdef limit:k
  :args (s/cat :sig valid-kr? :low valid-kr? :high valid-kr? ))
(stest/instrument `limit:k)

(defn limit:kArr
  {:arglists '([ksigArr klow khigh])}
  [sig low high]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "limit"
                      [sig low high]
                      *global*)]
    (new out-types ast)))

(s/fdef limit:kArr
  :args (s/cat :sig valid-kArr? :low valid-kr? :high valid-kr? ))
(stest/instrument `limit:kArr)

(defn nstrnum
  {:arglists '([Sname] [iname])}
  [name]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "nstrnum"
                      [name]
                      *global*)]
    (new out-types ast)))

(s/fdef nstrnum
  :args (s/alt
         :i (s/cat :name valid-i? )
         :S (s/cat :name valid-S? )
         ))
(stest/instrument `nstrnum)

(defn outh
  {:arglists '([& asig1* asig2* asig3* asig4* asig5* asig6* asig7* asig8* asig9* asig10* asig11* asig12* asig13* asig14* asig15* asig16* asig17* asig18* asig19* asig20* asig21* asig22* asig23* asig24* asig25* asig26* asig27* asig28* asig29* asig30* asig31* asig32*])}
  [& [ sig1* sig2* sig3* sig4* sig5* sig6* sig7* sig8* sig9* sig10* sig11* sig12* sig13* sig14* sig15* sig16* sig17* sig18* sig19* sig20* sig21* sig22* sig23* sig24* sig25* sig26* sig27* sig28* sig29* sig30* sig31* sig32* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outh"
                      [sig1* sig2* sig3* sig4* sig5* sig6* sig7* sig8* sig9* sig10* sig11* sig12* sig13* sig14* sig15* sig16* sig17* sig18* sig19* sig20* sig21* sig22* sig23* sig24* sig25* sig26* sig27* sig28* sig29* sig30* sig31* sig32*]
                      *global*)]
    (new out-types ast)))

(s/fdef outh
  :args (s/cat :sig1* (s/? valid-ar?*) :sig2* (s/? valid-ar?*) :sig3* (s/? valid-ar?*) :sig4* (s/? valid-ar?*) :sig5* (s/? valid-ar?*) :sig6* (s/? valid-ar?*) :sig7* (s/? valid-ar?*) :sig8* (s/? valid-ar?*) :sig9* (s/? valid-ar?*) :sig10* (s/? valid-ar?*) :sig11* (s/? valid-ar?*) :sig12* (s/? valid-ar?*) :sig13* (s/? valid-ar?*) :sig14* (s/? valid-ar?*) :sig15* (s/? valid-ar?*) :sig16* (s/? valid-ar?*) :sig17* (s/? valid-ar?*) :sig18* (s/? valid-ar?*) :sig19* (s/? valid-ar?*) :sig20* (s/? valid-ar?*) :sig21* (s/? valid-ar?*) :sig22* (s/? valid-ar?*) :sig23* (s/? valid-ar?*) :sig24* (s/? valid-ar?*) :sig25* (s/? valid-ar?*) :sig26* (s/? valid-ar?*) :sig27* (s/? valid-ar?*) :sig28* (s/? valid-ar?*) :sig29* (s/? valid-ar?*) :sig30* (s/? valid-ar?*) :sig31* (s/? valid-ar?*) :sig32* (s/? valid-ar?*) ))
(stest/instrument `outh)

(defn vpowv
  {:arglists '([ifn1 ifn2 kelements & kdstoffset* ksrcoffset* kverbose*])}
  [fn1 fn2 elements & [ dstoffset* srcoffset* verbose* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vpowv"
                      [fn1 fn2 elements dstoffset* srcoffset* verbose*]
                      *global*)]
    (new out-types ast)))

(s/fdef vpowv
  :args (s/cat :fn1 valid-i? :fn2 valid-i? :elements valid-kr? :dstoffset* (s/? valid-kr?*) :srcoffset* (s/? valid-kr?*) :verbose* (s/? valid-kr?*) ))
(stest/instrument `vpowv)

(defn lineto
  {:arglists '([ksig ktime])}
  [sig time]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "lineto"
                      [sig time]
                      *global*)]
    (new out-types ast)))

(s/fdef lineto
  :args (s/cat :sig valid-kr? :time valid-kr? ))
(stest/instrument `lineto)

(defn readclock
  {:arglists '([inum])}
  [num]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "readclock"
                      [num]
                      *global*)]
    (new out-types ast)))

(s/fdef readclock
  :args (s/cat :num valid-i? ))
(stest/instrument `readclock)

(defn ATScross
  {:arglists '([ktimepnt kfmod Satsfile itable kmylev kbuflev ipartials & ipartialoffset* ipartialincr* ipartialincr* ipartialincr*] [ktimepnt kfmod iatsfile itable kmylev kbuflev ipartials & ipartialoffset* ipartialincr* ipartialincr* ipartialincr*])}
  [timepnt fmod atsfile table mylev buflev partials & [ partialoffset* partialincr* partialincr* partialincr* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "ATScross"
                      [timepnt fmod atsfile table mylev buflev partials partialoffset* partialincr* partialincr* partialincr*]
                      *global*)]
    (new out-types ast)))

(s/fdef ATScross
  :args (s/alt
         :kkiikkiiiii (s/cat :timepnt valid-kr? :fmod valid-kr? :atsfile valid-i? :table valid-i? :mylev valid-kr? :buflev valid-kr? :partials valid-i? :partialoffset* (s/? valid-i?*) :partialincr* (s/? valid-i?*) :partialincr* (s/? valid-i?*) :partialincr* (s/? valid-i?*) )
         :kkSikkiiiii (s/cat :timepnt valid-kr? :fmod valid-kr? :atsfile valid-S? :table valid-i? :mylev valid-kr? :buflev valid-kr? :partials valid-i? :partialoffset* (s/? valid-i?*) :partialincr* (s/? valid-i?*) :partialincr* (s/? valid-i?*) :partialincr* (s/? valid-i?*) )
         ))
(stest/instrument `ATScross)

(defn pvstrace
  {:arglists '([fsigin kn])}
  [sigin n]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvstrace"
                      [sigin n]
                      *global*)]
    (new out-types ast)))

(s/fdef pvstrace
  :args (s/cat :sigin valid-f? :n valid-kr? ))
(stest/instrument `pvstrace)

(defn outic
  {:arglists '([ichn inum ivalue imin imax])}
  [chn num value min max]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outic"
                      [chn num value min max]
                      *global*)]
    (new out-types ast)))

(s/fdef outic
  :args (s/cat :chn valid-i? :num valid-i? :value valid-i? :min valid-i? :max valid-i? ))
(stest/instrument `outic)

(defn valpass
  {:arglists '([asig krvt xlpt imaxlpt & iskip* insmps*])}
  [sig rvt lpt maxlpt & [ skip* nsmps* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "valpass"
                      [sig rvt lpt maxlpt skip* nsmps*]
                      *global*)]
    (new out-types ast)))

(s/fdef valpass
  :args (s/cat :sig valid-ar? :rvt valid-kr? :lpt valid-x? :maxlpt valid-i? :skip* (s/? valid-i?*) :nsmps* (s/? valid-i?*) ))
(stest/instrument `valpass)

(defn hypot
  {:arglists '([iarg1Arr iarg2Arr] [karg1Arr karg2Arr])}
  [arg1 arg2]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "hypot"
                      [arg1 arg2]
                      *global*)]
    (new out-types ast)))

(s/fdef hypot
  :args (s/alt
         :kArrkArr (s/cat :arg1 valid-kArr? :arg2 valid-kArr? )
         :iArriArr (s/cat :arg1 valid-iArr? :arg2 valid-iArr? )
         ))
(stest/instrument `hypot)

(defn hypot:iArr
  {:arglists '([iarg1Arr iarg2Arr])}
  [arg1 arg2]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "hypot"
                      [arg1 arg2]
                      *global*)]
    (new out-types ast)))

(s/fdef hypot:iArr
  :args (s/cat :arg1 valid-iArr? :arg2 valid-iArr? ))
(stest/instrument `hypot:iArr)

(defn hypot:kArr
  {:arglists '([karg1Arr karg2Arr])}
  [arg1 arg2]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "hypot"
                      [arg1 arg2]
                      *global*)]
    (new out-types ast)))

(s/fdef hypot:kArr
  :args (s/cat :arg1 valid-kArr? :arg2 valid-kArr? ))
(stest/instrument `hypot:kArr)

(defn serialPrint
  {:arglists '([iPort])}
  [Port]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "serialPrint"
                      [Port]
                      *global*)]
    (new out-types ast)))

(s/fdef serialPrint
  :args (s/cat :Port valid-i? ))
(stest/instrument `serialPrint)

(defn cossegr
  {:arglists '([ia idur2 & ib1* idur2* ic3* irel4* iz5* iz6* iz7* iz8* iz9* iz10* iz11* iz12* iz13* iz14* iz15* iz16*] [ia idur2 & ib1* idur2* ic3* irel4* iz5* iz6* iz7* iz8* iz9* iz10* iz11* iz12* iz13* iz14* iz15* iz16*])}
  [a dur2 & [ b1* dur2* c3* rel4* z5* z6* z7* z8* z9* z10* z11* z12* z13* z14* z15* z16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "cossegr"
                      [a dur2 b1* dur2* c3* rel4* z5* z6* z7* z8* z9* z10* z11* z12* z13* z14* z15* z16*]
                      *global*)]
    (new out-types ast)))

(s/fdef cossegr
  :args (s/alt
         :iiiiiiiiiiiiiiiiii (s/cat :a valid-i? :dur2 valid-i? :b1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :c3* (s/? valid-i?*) :rel4* (s/? valid-i?*) :z5* (s/? valid-i?*) :z6* (s/? valid-i?*) :z7* (s/? valid-i?*) :z8* (s/? valid-i?*) :z9* (s/? valid-i?*) :z10* (s/? valid-i?*) :z11* (s/? valid-i?*) :z12* (s/? valid-i?*) :z13* (s/? valid-i?*) :z14* (s/? valid-i?*) :z15* (s/? valid-i?*) :z16* (s/? valid-i?*) )
         ))
(stest/instrument `cossegr)

(defn cossegr:a
  {:arglists '([ia idur2 & ib1* idur2* ic3* irel4* iz5* iz6* iz7* iz8* iz9* iz10* iz11* iz12* iz13* iz14* iz15* iz16*])}
  [a dur2 & [ b1* dur2* c3* rel4* z5* z6* z7* z8* z9* z10* z11* z12* z13* z14* z15* z16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "cossegr"
                      [a dur2 b1* dur2* c3* rel4* z5* z6* z7* z8* z9* z10* z11* z12* z13* z14* z15* z16*]
                      *global*)]
    (new out-types ast)))

(s/fdef cossegr:a
  :args (s/cat :a valid-i? :dur2 valid-i? :b1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :c3* (s/? valid-i?*) :rel4* (s/? valid-i?*) :z5* (s/? valid-i?*) :z6* (s/? valid-i?*) :z7* (s/? valid-i?*) :z8* (s/? valid-i?*) :z9* (s/? valid-i?*) :z10* (s/? valid-i?*) :z11* (s/? valid-i?*) :z12* (s/? valid-i?*) :z13* (s/? valid-i?*) :z14* (s/? valid-i?*) :z15* (s/? valid-i?*) :z16* (s/? valid-i?*) ))
(stest/instrument `cossegr:a)

(defn cossegr:k
  {:arglists '([ia idur2 & ib1* idur2* ic3* irel4* iz5* iz6* iz7* iz8* iz9* iz10* iz11* iz12* iz13* iz14* iz15* iz16*])}
  [a dur2 & [ b1* dur2* c3* rel4* z5* z6* z7* z8* z9* z10* z11* z12* z13* z14* z15* z16* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "cossegr"
                      [a dur2 b1* dur2* c3* rel4* z5* z6* z7* z8* z9* z10* z11* z12* z13* z14* z15* z16*]
                      *global*)]
    (new out-types ast)))

(s/fdef cossegr:k
  :args (s/cat :a valid-i? :dur2 valid-i? :b1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :c3* (s/? valid-i?*) :rel4* (s/? valid-i?*) :z5* (s/? valid-i?*) :z6* (s/? valid-i?*) :z7* (s/? valid-i?*) :z8* (s/? valid-i?*) :z9* (s/? valid-i?*) :z10* (s/? valid-i?*) :z11* (s/? valid-i?*) :z12* (s/? valid-i?*) :z13* (s/? valid-i?*) :z14* (s/? valid-i?*) :z15* (s/? valid-i?*) :z16* (s/? valid-i?*) ))
(stest/instrument `cossegr:k)

(defn pvsdisp
  {:arglists '([fsig & ibins* iwtflg*])}
  [sig & [ bins* wtflg* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "pvsdisp"
                      [sig bins* wtflg*]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsdisp
  :args (s/cat :sig valid-f? :bins* (s/? valid-i?*) :wtflg* (s/? valid-i?*) ))
(stest/instrument `pvsdisp)

(defn ficlose
  {:arglists '([Sfilename] [ifilename])}
  [filename]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "ficlose"
                      [filename]
                      *global*)]
    (new out-types ast)))

(s/fdef ficlose
  :args (s/alt
         :i (s/cat :filename valid-i? )
         :S (s/cat :filename valid-S? )
         ))
(stest/instrument `ficlose)

(defn fmin
  {:arglists '([iargArr iarg2] [iargArr iarg2Arr] [kargArr karg2] [kargArr karg2Arr])}
  [arg arg2]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "fmin"
                      [arg arg2]
                      *global*)]
    (new out-types ast)))

(s/fdef fmin
  :args (s/alt
         :kArrkArr (s/cat :arg valid-kArr? :arg2 valid-kArr? )
         :kArrk (s/cat :arg valid-kArr? :arg2 valid-kr? )
         :iArriArr (s/cat :arg valid-iArr? :arg2 valid-iArr? )
         :iArri (s/cat :arg valid-iArr? :arg2 valid-i? )
         ))
(stest/instrument `fmin)

(defn fmin:iArr
  {:arglists '([iargArr iarg2] [iargArr iarg2Arr])}
  [arg arg2]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "fmin"
                      [arg arg2]
                      *global*)]
    (new out-types ast)))

(s/fdef fmin:iArr
  :args (s/alt
         :iArriArr (s/cat :arg valid-iArr? :arg2 valid-iArr? )
         :iArri (s/cat :arg valid-iArr? :arg2 valid-i? )
         ))
(stest/instrument `fmin:iArr)

(defn fmin:kArr
  {:arglists '([kargArr karg2] [kargArr karg2Arr])}
  [arg arg2]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "fmin"
                      [arg arg2]
                      *global*)]
    (new out-types ast)))

(s/fdef fmin:kArr
  :args (s/alt
         :kArrkArr (s/cat :arg valid-kArr? :arg2 valid-kArr? )
         :kArrk (s/cat :arg valid-kArr? :arg2 valid-kr? )
         ))
(stest/instrument `fmin:kArr)

(defn atone
  {:arglists '([asig khp & iskip*] [asig khp & iskip*])}
  [sig hp & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "atone"
                      [sig hp skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef atone
  :args (s/alt
         :aki (s/cat :sig valid-ar? :hp valid-kr? :skip* (s/? valid-i?*) )
         ))
(stest/instrument `atone)

(defn chnget
  {:arglists '([Ss] [Ss] [Ss] [Ss])}
  [s]
  (let [out-types-quoted 'String
        out-types String
        ast (ast-node out-types-quoted
                      "chnget"
                      [s]
                      *global*)]
    (new out-types ast)))

(s/fdef chnget
  :args (s/alt
         :S (s/cat :s valid-S? )
         ))
(stest/instrument `chnget)

(defn chnget:S
  {:arglists '([Ss])}
  [s]
  (let [out-types-quoted 'String
        out-types String
        ast (ast-node out-types-quoted
                      "chnget"
                      [s]
                      *global*)]
    (new out-types ast)))

(s/fdef chnget:S
  :args (s/cat :s valid-S? ))
(stest/instrument `chnget:S)

(defn chnget:a
  {:arglists '([Ss])}
  [s]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "chnget"
                      [s]
                      *global*)]
    (new out-types ast)))

(s/fdef chnget:a
  :args (s/cat :s valid-S? ))
(stest/instrument `chnget:a)

(defn chnget:i
  {:arglists '([Ss])}
  [s]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "chnget"
                      [s]
                      *global*)]
    (new out-types ast)))

(s/fdef chnget:i
  :args (s/cat :s valid-S? ))
(stest/instrument `chnget:i)

(defn chnget:k
  {:arglists '([Ss])}
  [s]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "chnget"
                      [s]
                      *global*)]
    (new out-types ast)))

(s/fdef chnget:k
  :args (s/cat :s valid-S? ))
(stest/instrument `chnget:k)

(defn adsr
  {:arglists '([iatt idec islev irel & idel*] [iatt idec islev irel & idel*])}
  [att dec slev rel & [ del* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "adsr"
                      [att dec slev rel del*]
                      *global*)]
    (new out-types ast)))

(s/fdef adsr
  :args (s/alt
         :iiiii (s/cat :att valid-i? :dec valid-i? :slev valid-i? :rel valid-i? :del* (s/? valid-i?*) )
         ))
(stest/instrument `adsr)

(defn adsr:a
  {:arglists '([iatt idec islev irel & idel*])}
  [att dec slev rel & [ del* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "adsr"
                      [att dec slev rel del*]
                      *global*)]
    (new out-types ast)))

(s/fdef adsr:a
  :args (s/cat :att valid-i? :dec valid-i? :slev valid-i? :rel valid-i? :del* (s/? valid-i?*) ))
(stest/instrument `adsr:a)

(defn adsr:k
  {:arglists '([iatt idec islev irel & idel*])}
  [att dec slev rel & [ del* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "adsr"
                      [att dec slev rel del*]
                      *global*)]
    (new out-types ast)))

(s/fdef adsr:k
  :args (s/cat :att valid-i? :dec valid-i? :slev valid-i? :rel valid-i? :del* (s/? valid-i?*) ))
(stest/instrument `adsr:k)

(defn vcopy
  {:arglists '([ifn1 ifn2 kelements & kdstoffset* ksrcoffset* kverbose*])}
  [fn1 fn2 elements & [ dstoffset* srcoffset* verbose* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vcopy"
                      [fn1 fn2 elements dstoffset* srcoffset* verbose*]
                      *global*)]
    (new out-types ast)))

(s/fdef vcopy
  :args (s/cat :fn1 valid-i? :fn2 valid-i? :elements valid-kr? :dstoffset* (s/? valid-kr?*) :srcoffset* (s/? valid-kr?*) :verbose* (s/? valid-kr?*) ))
(stest/instrument `vcopy)

(defn fini
  {:arglists '([Sfilename iskipframes iformat & in1* in2* in3* in4* in5* in6* in7* in8* in9* in10* in11* in12* in13* in14* in15* in16*] [ifilename iskipframes iformat & in1* in2* in3* in4* in5* in6* in7* in8* in9* in10* in11* in12* in13* in14* in15* in16*])}
  [filename skipframes format & [ n1* n2* n3* n4* n5* n6* n7* n8* n9* n10* n11* n12* n13* n14* n15* n16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "fini"
                      [filename skipframes format n1* n2* n3* n4* n5* n6* n7* n8* n9* n10* n11* n12* n13* n14* n15* n16*]
                      *global*)]
    (new out-types ast)))

(s/fdef fini
  :args (s/alt
         :iiiiiiiiiiiiiiiiiii (s/cat :filename valid-i? :skipframes valid-i? :format valid-i? :n1* (s/? valid-i?*) :n2* (s/? valid-i?*) :n3* (s/? valid-i?*) :n4* (s/? valid-i?*) :n5* (s/? valid-i?*) :n6* (s/? valid-i?*) :n7* (s/? valid-i?*) :n8* (s/? valid-i?*) :n9* (s/? valid-i?*) :n10* (s/? valid-i?*) :n11* (s/? valid-i?*) :n12* (s/? valid-i?*) :n13* (s/? valid-i?*) :n14* (s/? valid-i?*) :n15* (s/? valid-i?*) :n16* (s/? valid-i?*) )
         :Siiiiiiiiiiiiiiiiii (s/cat :filename valid-S? :skipframes valid-i? :format valid-i? :n1* (s/? valid-i?*) :n2* (s/? valid-i?*) :n3* (s/? valid-i?*) :n4* (s/? valid-i?*) :n5* (s/? valid-i?*) :n6* (s/? valid-i?*) :n7* (s/? valid-i?*) :n8* (s/? valid-i?*) :n9* (s/? valid-i?*) :n10* (s/? valid-i?*) :n11* (s/? valid-i?*) :n12* (s/? valid-i?*) :n13* (s/? valid-i?*) :n14* (s/? valid-i?*) :n15* (s/? valid-i?*) :n16* (s/? valid-i?*) )
         ))
(stest/instrument `fini)

(defn hvs3
  {:arglists '([kx ky kz inumParms inumPointsX inumPointsY inumPointsZ iOutTab iPositionsTab iSnapTab & iConfigTab*])}
  [x y z numParms numPointsX numPointsY numPointsZ OutTab PositionsTab SnapTab & [ ConfigTab* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "hvs3"
                      [x y z numParms numPointsX numPointsY numPointsZ OutTab PositionsTab SnapTab ConfigTab*]
                      *global*)]
    (new out-types ast)))

(s/fdef hvs3
  :args (s/cat :x valid-kr? :y valid-kr? :z valid-kr? :numParms valid-i? :numPointsX valid-i? :numPointsY valid-i? :numPointsZ valid-i? :OutTab valid-i? :PositionsTab valid-i? :SnapTab valid-i? :ConfigTab* (s/? valid-i?*) ))
(stest/instrument `hvs3)

(defn xscansmap
  {:arglists '([kpos kvel iscan kamp kvamp & iwhich*])}
  [pos vel scan amp vamp & [ which* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "xscansmap"
                      [pos vel scan amp vamp which*]
                      *global*)]
    (new out-types ast)))

(s/fdef xscansmap
  :args (s/cat :pos valid-kr? :vel valid-kr? :scan valid-i? :amp valid-kr? :vamp valid-kr? :which* (s/? valid-i?*) ))
(stest/instrument `xscansmap)

(defn stix
  {:arglists '([iamp idettack & inum* idamp* imaxshake*])}
  [amp dettack & [ num* damp* maxshake* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "stix"
                      [amp dettack num* damp* maxshake*]
                      *global*)]
    (new out-types ast)))

(s/fdef stix
  :args (s/cat :amp valid-i? :dettack valid-i? :num* (s/? valid-i?*) :damp* (s/? valid-i?*) :maxshake* (s/? valid-i?*) ))
(stest/instrument `stix)

(defn dumpk3
  {:arglists '([ksig1 ksig2 ksig3 Sfilname iformat iprd] [ksig1 ksig2 ksig3 ifilname iformat iprd])}
  [sig1 sig2 sig3 filname format prd]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "dumpk3"
                      [sig1 sig2 sig3 filname format prd]
                      *global*)]
    (new out-types ast)))

(s/fdef dumpk3
  :args (s/alt
         :kkkiii (s/cat :sig1 valid-kr? :sig2 valid-kr? :sig3 valid-kr? :filname valid-i? :format valid-i? :prd valid-i? )
         :kkkSii (s/cat :sig1 valid-kr? :sig2 valid-kr? :sig3 valid-kr? :filname valid-S? :format valid-i? :prd valid-i? )
         ))
(stest/instrument `dumpk3)

(defn vibrato
  {:arglists '([kAverageAmp kAverageFreq kRandAmountAmp kRandAmountFreq kAmpMinRate kAmpMaxRate kcpsMinRate kcpsMaxRate itable & iphase*])}
  [AverageAmp AverageFreq RandAmountAmp RandAmountFreq AmpMinRate AmpMaxRate cpsMinRate cpsMaxRate table & [ phase* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "vibrato"
                      [AverageAmp AverageFreq RandAmountAmp RandAmountFreq AmpMinRate AmpMaxRate cpsMinRate cpsMaxRate table phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef vibrato
  :args (s/cat :AverageAmp valid-kr? :AverageFreq valid-kr? :RandAmountAmp valid-kr? :RandAmountFreq valid-kr? :AmpMinRate valid-kr? :AmpMaxRate valid-kr? :cpsMinRate valid-kr? :cpsMaxRate valid-kr? :table valid-i? :phase* (s/? valid-i?*) ))
(stest/instrument `vibrato)

(defn partials
  {:arglists '([ffr fphase kthresh kminpts kmaxgap imaxtracks])}
  [fr phase thresh minpts maxgap maxtracks]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "partials"
                      [fr phase thresh minpts maxgap maxtracks]
                      *global*)]
    (new out-types ast)))

(s/fdef partials
  :args (s/cat :fr valid-f? :phase valid-f? :thresh valid-kr? :minpts valid-kr? :maxgap valid-kr? :maxtracks valid-i? ))
(stest/instrument `partials)

(defn expseg
  {:arglists '([ia idur2 & ib1* idur2* ic3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*] [ia idur2 & ib1* idur2* ic3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a dur2 & [ b1* dur2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "expseg"
                      [a dur2 b1* dur2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef expseg
  :args (s/alt
         :iiiiiiiiiiiiiiiiii (s/cat :a valid-i? :dur2 valid-i? :b1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :c3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) )
         ))
(stest/instrument `expseg)

(defn expseg:a
  {:arglists '([ia idur2 & ib1* idur2* ic3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a dur2 & [ b1* dur2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "expseg"
                      [a dur2 b1* dur2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef expseg:a
  :args (s/cat :a valid-i? :dur2 valid-i? :b1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :c3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) ))
(stest/instrument `expseg:a)

(defn expseg:k
  {:arglists '([ia idur2 & ib1* idur2* ic3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a dur2 & [ b1* dur2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "expseg"
                      [a dur2 b1* dur2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef expseg:k
  :args (s/cat :a valid-i? :dur2 valid-i? :b1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :c3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) ))
(stest/instrument `expseg:k)

(defn veloc
  {:arglists '([& ilow* ihigh*])}
  [& [ low* high* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "veloc"
                      [low* high*]
                      *global*)]
    (new out-types ast)))

(s/fdef veloc
  :args (s/cat :low* (s/? valid-i?*) :high* (s/? valid-i?*) ))
(stest/instrument `veloc)

(defn tambourine
  {:arglists '([kamp idettack & inum* idamp* imaxshake* ifreq* ifreq1* ifreq1*])}
  [amp dettack & [ num* damp* maxshake* freq* freq1* freq1* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "tambourine"
                      [amp dettack num* damp* maxshake* freq* freq1* freq1*]
                      *global*)]
    (new out-types ast)))

(s/fdef tambourine
  :args (s/cat :amp valid-kr? :dettack valid-i? :num* (s/? valid-i?*) :damp* (s/? valid-i?*) :maxshake* (s/? valid-i?*) :freq* (s/? valid-i?*) :freq1* (s/? valid-i?*) :freq1* (s/? valid-i?*) ))
(stest/instrument `tambourine)

(defn gauss
  {:arglists '([krange] [krange] [krange])}
  [range]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "gauss"
                      [range]
                      *global*)]
    (new out-types ast)))

(s/fdef gauss
  :args (s/alt
         :k (s/cat :range valid-kr? )
         ))
(stest/instrument `gauss)

(defn gauss:a
  {:arglists '([krange])}
  [range]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "gauss"
                      [range]
                      *global*)]
    (new out-types ast)))

(s/fdef gauss:a
  :args (s/cat :range valid-kr? ))
(stest/instrument `gauss:a)

(defn gauss:i
  {:arglists '([krange])}
  [range]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "gauss"
                      [range]
                      *global*)]
    (new out-types ast)))

(s/fdef gauss:i
  :args (s/cat :range valid-kr? ))
(stest/instrument `gauss:i)

(defn gauss:k
  {:arglists '([krange])}
  [range]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "gauss"
                      [range]
                      *global*)]
    (new out-types ast)))

(s/fdef gauss:k
  :args (s/cat :range valid-kr? ))
(stest/instrument `gauss:k)

(defn midicontrolchange
  {:arglists '([xcontroller xcontrollervalue & ilow* ihigh*])}
  [controller controllervalue & [ low* high* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "midicontrolchange"
                      [controller controllervalue low* high*]
                      *global*)]
    (new out-types ast)))

(s/fdef midicontrolchange
  :args (s/cat :controller valid-x? :controllervalue valid-x? :low* (s/? valid-i?*) :high* (s/? valid-i?*) ))
(stest/instrument `midicontrolchange)

(defn midiout
  {:arglists '([kstatus kchan kdata3 kdata4])}
  [status chan data3 data4]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "midiout"
                      [status chan data3 data4]
                      *global*)]
    (new out-types ast)))

(s/fdef midiout
  :args (s/cat :status valid-kr? :chan valid-kr? :data3 valid-kr? :data4 valid-kr? ))
(stest/instrument `midiout)

(defn c2r
  {:arglists '([iinArr] [kinArr])}
  [in]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "c2r"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef c2r
  :args (s/alt
         :kArr (s/cat :in valid-kArr? )
         :iArr (s/cat :in valid-iArr? )
         ))
(stest/instrument `c2r)

(defn c2r:iArr
  {:arglists '([iinArr])}
  [in]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "c2r"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef c2r:iArr
  :args (s/cat :in valid-iArr? ))
(stest/instrument `c2r:iArr)

(defn c2r:kArr
  {:arglists '([kinArr])}
  [in]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "c2r"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef c2r:kArr
  :args (s/cat :in valid-kArr? ))
(stest/instrument `c2r:kArr)

(defn xadsr
  {:arglists '([iatt idec islev irel & idel*] [iatt idec islev irel & idel*])}
  [att dec slev rel & [ del* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "xadsr"
                      [att dec slev rel del*]
                      *global*)]
    (new out-types ast)))

(s/fdef xadsr
  :args (s/alt
         :iiiii (s/cat :att valid-i? :dec valid-i? :slev valid-i? :rel valid-i? :del* (s/? valid-i?*) )
         ))
(stest/instrument `xadsr)

(defn xadsr:a
  {:arglists '([iatt idec islev irel & idel*])}
  [att dec slev rel & [ del* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "xadsr"
                      [att dec slev rel del*]
                      *global*)]
    (new out-types ast)))

(s/fdef xadsr:a
  :args (s/cat :att valid-i? :dec valid-i? :slev valid-i? :rel valid-i? :del* (s/? valid-i?*) ))
(stest/instrument `xadsr:a)

(defn xadsr:k
  {:arglists '([iatt idec islev irel & idel*])}
  [att dec slev rel & [ del* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "xadsr"
                      [att dec slev rel del*]
                      *global*)]
    (new out-types ast)))

(s/fdef xadsr:k
  :args (s/cat :att valid-i? :dec valid-i? :slev valid-i? :rel valid-i? :del* (s/? valid-i?*) ))
(stest/instrument `xadsr:k)

(defn connect
  {:arglists '([Ssource1 Soutlet2 Ssink3 Sinlet4 & iinlet1*] [Ssource1 Soutlet2 isink3 Sinlet4 & iinlet1*] [isource1 Soutlet2 Ssink3 Sinlet4 & iinlet1*] [isource1 Soutlet2 isink3 Sinlet4 & iinlet1*])}
  [source1 outlet2 sink3 inlet4 & [ inlet1* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "connect"
                      [source1 outlet2 sink3 inlet4 inlet1*]
                      *global*)]
    (new out-types ast)))

(s/fdef connect
  :args (s/alt
         :iSiSi (s/cat :source1 valid-i? :outlet2 valid-S? :sink3 valid-i? :inlet4 valid-S? :inlet1* (s/? valid-i?*) )
         :iSSSi (s/cat :source1 valid-i? :outlet2 valid-S? :sink3 valid-S? :inlet4 valid-S? :inlet1* (s/? valid-i?*) )
         :SSiSi (s/cat :source1 valid-S? :outlet2 valid-S? :sink3 valid-i? :inlet4 valid-S? :inlet1* (s/? valid-i?*) )
         :SSSSi (s/cat :source1 valid-S? :outlet2 valid-S? :sink3 valid-S? :inlet4 valid-S? :inlet1* (s/? valid-i?*) )
         ))
(stest/instrument `connect)

(defn pvs2tab
  {:arglists '([kmagsArr ffreqs] [kmagsArr kfreqsArr fsig])}
  [mags freqs]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "pvs2tab"
                      [mags freqs]
                      *global*)]
    (new out-types ast)))

(s/fdef pvs2tab
  :args (s/alt
         :kArrkArrf (s/cat :mags valid-kArr? :freqs valid-kArr? :sig valid-f? )
         :kArrf (s/cat :mags valid-kArr? :freqs valid-f? )
         ))
(stest/instrument `pvs2tab)

(defn outleta
  {:arglists '([Sname asignal])}
  [name signal]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outleta"
                      [name signal]
                      *global*)]
    (new out-types ast)))

(s/fdef outleta
  :args (s/cat :name valid-S? :signal valid-ar? ))
(stest/instrument `outleta)

(defn linrand
  {:arglists '([krange] [krange] [krange])}
  [range]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "linrand"
                      [range]
                      *global*)]
    (new out-types ast)))

(s/fdef linrand
  :args (s/alt
         :k (s/cat :range valid-kr? )
         ))
(stest/instrument `linrand)

(defn linrand:a
  {:arglists '([krange])}
  [range]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "linrand"
                      [range]
                      *global*)]
    (new out-types ast)))

(s/fdef linrand:a
  :args (s/cat :range valid-kr? ))
(stest/instrument `linrand:a)

(defn linrand:i
  {:arglists '([krange])}
  [range]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "linrand"
                      [range]
                      *global*)]
    (new out-types ast)))

(s/fdef linrand:i
  :args (s/cat :range valid-kr? ))
(stest/instrument `linrand:i)

(defn linrand:k
  {:arglists '([krange])}
  [range]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "linrand"
                      [range]
                      *global*)]
    (new out-types ast)))

(s/fdef linrand:k
  :args (s/cat :range valid-kr? ))
(stest/instrument `linrand:k)

(defn integ
  {:arglists '([xsig & iskip*] [xsig & iskip*])}
  [sig & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "integ"
                      [sig skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef integ
  :args (s/alt
         :xi (s/cat :sig valid-x? :skip* (s/? valid-i?*) )
         ))
(stest/instrument `integ)

(defn integ:a
  {:arglists '([xsig & iskip*])}
  [sig & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "integ"
                      [sig skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef integ:a
  :args (s/cat :sig valid-x? :skip* (s/? valid-i?*) ))
(stest/instrument `integ:a)

(defn integ:k
  {:arglists '([xsig & iskip*])}
  [sig & [ skip* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "integ"
                      [sig skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef integ:k
  :args (s/cat :sig valid-x? :skip* (s/? valid-i?*) ))
(stest/instrument `integ:k)

(defn gaussi
  {:arglists '([krange xamp xcps] [krange xamp xcps] [krange xamp xcps])}
  [range amp cps]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "gaussi"
                      [range amp cps]
                      *global*)]
    (new out-types ast)))

(s/fdef gaussi
  :args (s/alt
         :kxx (s/cat :range valid-kr? :amp valid-x? :cps valid-x? )
         ))
(stest/instrument `gaussi)

(defn gaussi:a
  {:arglists '([krange xamp xcps])}
  [range amp cps]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "gaussi"
                      [range amp cps]
                      *global*)]
    (new out-types ast)))

(s/fdef gaussi:a
  :args (s/cat :range valid-kr? :amp valid-x? :cps valid-x? ))
(stest/instrument `gaussi:a)

(defn gaussi:i
  {:arglists '([krange xamp xcps])}
  [range amp cps]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "gaussi"
                      [range amp cps]
                      *global*)]
    (new out-types ast)))

(s/fdef gaussi:i
  :args (s/cat :range valid-kr? :amp valid-x? :cps valid-x? ))
(stest/instrument `gaussi:i)

(defn gaussi:k
  {:arglists '([krange xamp xcps])}
  [range amp cps]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "gaussi"
                      [range amp cps]
                      *global*)]
    (new out-types ast)))

(s/fdef gaussi:k
  :args (s/cat :range valid-kr? :amp valid-x? :cps valid-x? ))
(stest/instrument `gaussi:k)

(defn cmplxprod
  {:arglists '([kin1Arr kin2Arr])}
  [in1 in2]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "cmplxprod"
                      [in1 in2]
                      *global*)]
    (new out-types ast)))

(s/fdef cmplxprod
  :args (s/cat :in1 valid-kArr? :in2 valid-kArr? ))
(stest/instrument `cmplxprod)

(defn loopxseg
  {:arglists '([kfreq ktrig iphase & ktime1* kvalue2* ktime3* kvalue4* ktime5* kvalue6* kvalue7* kvalue8* kvalue9* kvalue10* kvalue11* kvalue12* kvalue13* kvalue14* kvalue15* kvalue16*])}
  [freq trig phase & [ time1* value2* time3* value4* time5* value6* value7* value8* value9* value10* value11* value12* value13* value14* value15* value16* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "loopxseg"
                      [freq trig phase time1* value2* time3* value4* time5* value6* value7* value8* value9* value10* value11* value12* value13* value14* value15* value16*]
                      *global*)]
    (new out-types ast)))

(s/fdef loopxseg
  :args (s/cat :freq valid-kr? :trig valid-kr? :phase valid-i? :time1* (s/? valid-kr?*) :value2* (s/? valid-kr?*) :time3* (s/? valid-kr?*) :value4* (s/? valid-kr?*) :time5* (s/? valid-kr?*) :value6* (s/? valid-kr?*) :value7* (s/? valid-kr?*) :value8* (s/? valid-kr?*) :value9* (s/? valid-kr?*) :value10* (s/? valid-kr?*) :value11* (s/? valid-kr?*) :value12* (s/? valid-kr?*) :value13* (s/? valid-kr?*) :value14* (s/? valid-kr?*) :value15* (s/? valid-kr?*) :value16* (s/? valid-kr?*) ))
(stest/instrument `loopxseg)

(defn poscil3
  {:arglists '([aamp acps & itable* iphase*] [aamp kcps & itable* iphase*] [kamp acps & itable* iphase*] [kamp kcps & itable* iphase*] [kamp kcps & itable* iphase*])}
  [amp cps & [ table* phase* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "poscil3"
                      [amp cps table* phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef poscil3
  :args (s/alt
         :kkii (s/cat :amp valid-kr? :cps valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :kaii (s/cat :amp valid-kr? :cps valid-ar? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :akii (s/cat :amp valid-ar? :cps valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :aaii (s/cat :amp valid-ar? :cps valid-ar? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         ))
(stest/instrument `poscil3)

(defn poscil3:a
  {:arglists '([aamp acps & itable* iphase*] [aamp kcps & itable* iphase*] [kamp acps & itable* iphase*] [kamp kcps & itable* iphase*])}
  [amp cps & [ table* phase* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "poscil3"
                      [amp cps table* phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef poscil3:a
  :args (s/alt
         :kkii (s/cat :amp valid-kr? :cps valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :kaii (s/cat :amp valid-kr? :cps valid-ar? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :akii (s/cat :amp valid-ar? :cps valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :aaii (s/cat :amp valid-ar? :cps valid-ar? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         ))
(stest/instrument `poscil3:a)

(defn poscil3:k
  {:arglists '([kamp kcps & itable* iphase*])}
  [amp cps & [ table* phase* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "poscil3"
                      [amp cps table* phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef poscil3:k
  :args (s/cat :amp valid-kr? :cps valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) ))
(stest/instrument `poscil3:k)

(defn seed
  {:arglists '([ival])}
  [val]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "seed"
                      [val]
                      *global*)]
    (new out-types ast)))

(s/fdef seed
  :args (s/cat :val valid-i? ))
(stest/instrument `seed)

(defn resonk
  {:arglists '([ksig kcenter-frequency kbandwidth & iscale* iskip*])}
  [sig center-frequency bandwidth & [ scale* skip* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "resonk"
                      [sig center-frequency bandwidth scale* skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef resonk
  :args (s/cat :sig valid-kr? :center-frequency valid-kr? :bandwidth valid-kr? :scale* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `resonk)

(defn mp3len
  {:arglists '([Sfilcod] [ifilcod])}
  [filcod]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "mp3len"
                      [filcod]
                      *global*)]
    (new out-types ast)))

(s/fdef mp3len
  :args (s/alt
         :i (s/cat :filcod valid-i? )
         :S (s/cat :filcod valid-S? )
         ))
(stest/instrument `mp3len)

(defn minarray
  {:arglists '([iarrayArr] [karrayArr])}
  [array]
  (let [out-types-quoted '[Variable ]
        out-types [Variable ]
        ast (ast-node out-types-quoted
                      "minarray"
                      [array]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef minarray
  :args (s/alt
         :kArr (s/cat :array valid-kArr? )
         :iArr (s/cat :array valid-iArr? )
         ))
(stest/instrument `minarray)

(defn vbap
  {:arglists '([asig kazim & kelev* kspread* ilayout*] [asig kazim & kelev* kspread* ilayout*])}
  [sig azim & [ elev* spread* layout* ]]
  (let [out-types-quoted 'AudioArray
        out-types AudioArray
        ast (ast-node out-types-quoted
                      "vbap"
                      [sig azim elev* spread* layout*]
                      *global*)]
    (new out-types ast)))

(s/fdef vbap
  :args (s/alt
         :akkki (s/cat :sig valid-ar? :azim valid-kr? :elev* (s/? valid-kr?*) :spread* (s/? valid-kr?*) :layout* (s/? valid-i?*) )
         ))
(stest/instrument `vbap)

(defn vbap:aArr
  {:arglists '([asig kazim & kelev* kspread* ilayout*])}
  [sig azim & [ elev* spread* layout* ]]
  (let [out-types-quoted 'AudioArray
        out-types AudioArray
        ast (ast-node out-types-quoted
                      "vbap"
                      [sig azim elev* spread* layout*]
                      *global*)]
    (new out-types ast)))

(s/fdef vbap:aArr
  :args (s/cat :sig valid-ar? :azim valid-kr? :elev* (s/? valid-kr?*) :spread* (s/? valid-kr?*) :layout* (s/? valid-i?*) ))
(stest/instrument `vbap:aArr)

(defn vbap:a
  {:arglists '([asig kazim & kelev* kspread* ilayout*])}
  [sig azim & [ elev* spread* layout* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "vbap"
                      [sig azim elev* spread* layout*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef vbap:a
  :args (s/cat :sig valid-ar? :azim valid-kr? :elev* (s/? valid-kr?*) :spread* (s/? valid-kr?*) :layout* (s/? valid-i?*) ))
(stest/instrument `vbap:a)

(defn vco2init
  {:arglists '([iwave & ibasfn* ipmul* iminsiz* imaxsiz* isrcft*])}
  [wave & [ basfn* pmul* minsiz* maxsiz* srcft* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "vco2init"
                      [wave basfn* pmul* minsiz* maxsiz* srcft*]
                      *global*)]
    (new out-types ast)))

(s/fdef vco2init
  :args (s/cat :wave valid-i? :basfn* (s/? valid-i?*) :pmul* (s/? valid-i?*) :minsiz* (s/? valid-i?*) :maxsiz* (s/? valid-i?*) :srcft* (s/? valid-i?*) ))
(stest/instrument `vco2init)

(defn setscorepos
  {:arglists '([ipos])}
  [pos]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "setscorepos"
                      [pos]
                      *global*)]
    (new out-types ast)))

(s/fdef setscorepos
  :args (s/cat :pos valid-i? ))
(stest/instrument `setscorepos)

(defn schedkwhen
  {:arglists '([ktrigger kmintim kmaxnum Sinsname kwhen & kdur1* kp2* kp3* kp4* kp5* kp6* kp7* kp8* kp9* kp10* kp11* kp12* kp13* kp14* kp15* kp16*] [ktrigger kmintim kmaxnum kinsname kwhen & kdur1* kp2* kp3* kp4* kp5* kp6* kp7* kp8* kp9* kp10* kp11* kp12* kp13* kp14* kp15* kp16*])}
  [trigger mintim maxnum insname when & [ dur1* p2* p3* p4* p5* p6* p7* p8* p9* p10* p11* p12* p13* p14* p15* p16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "schedkwhen"
                      [trigger mintim maxnum insname when dur1* p2* p3* p4* p5* p6* p7* p8* p9* p10* p11* p12* p13* p14* p15* p16*]
                      *global*)]
    (new out-types ast)))

(s/fdef schedkwhen
  :args (s/alt
         :kkkkkkkkkkkkkkkkkkkkk (s/cat :trigger valid-kr? :mintim valid-kr? :maxnum valid-kr? :insname valid-kr? :when valid-kr? :dur1* (s/? valid-kr?*) :p2* (s/? valid-kr?*) :p3* (s/? valid-kr?*) :p4* (s/? valid-kr?*) :p5* (s/? valid-kr?*) :p6* (s/? valid-kr?*) :p7* (s/? valid-kr?*) :p8* (s/? valid-kr?*) :p9* (s/? valid-kr?*) :p10* (s/? valid-kr?*) :p11* (s/? valid-kr?*) :p12* (s/? valid-kr?*) :p13* (s/? valid-kr?*) :p14* (s/? valid-kr?*) :p15* (s/? valid-kr?*) :p16* (s/? valid-kr?*) )
         :kkkSkkkkkkkkkkkkkkkkk (s/cat :trigger valid-kr? :mintim valid-kr? :maxnum valid-kr? :insname valid-S? :when valid-kr? :dur1* (s/? valid-kr?*) :p2* (s/? valid-kr?*) :p3* (s/? valid-kr?*) :p4* (s/? valid-kr?*) :p5* (s/? valid-kr?*) :p6* (s/? valid-kr?*) :p7* (s/? valid-kr?*) :p8* (s/? valid-kr?*) :p9* (s/? valid-kr?*) :p10* (s/? valid-kr?*) :p11* (s/? valid-kr?*) :p12* (s/? valid-kr?*) :p13* (s/? valid-kr?*) :p14* (s/? valid-kr?*) :p15* (s/? valid-kr?*) :p16* (s/? valid-kr?*) )
         ))
(stest/instrument `schedkwhen)

(defn harmon
  {:arglists '([asig kestfrq kmaxvar kgenfreq4 kgenfreq5 imode iminfrq iprd])}
  [sig estfrq maxvar genfreq4 genfreq5 mode minfrq prd]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "harmon"
                      [sig estfrq maxvar genfreq4 genfreq5 mode minfrq prd]
                      *global*)]
    (new out-types ast)))

(s/fdef harmon
  :args (s/cat :sig valid-ar? :estfrq valid-kr? :maxvar valid-kr? :genfreq4 valid-kr? :genfreq5 valid-kr? :mode valid-i? :minfrq valid-i? :prd valid-i? ))
(stest/instrument `harmon)

(defn pvsarp
  {:arglists '([fsigin kbin kdepth kgain])}
  [sigin bin depth gain]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvsarp"
                      [sigin bin depth gain]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsarp
  :args (s/cat :sigin valid-f? :bin valid-kr? :depth valid-kr? :gain valid-kr? ))
(stest/instrument `pvsarp)

(defn tablekt
  {:arglists '([xindex ktable & ixmode* ixoff* iwrap*] [xindex ktable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "tablekt"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef tablekt
  :args (s/alt
         :xkiii (s/cat :index valid-x? :table valid-kr? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) )
         ))
(stest/instrument `tablekt)

(defn tablekt:a
  {:arglists '([xindex ktable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "tablekt"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef tablekt:a
  :args (s/cat :index valid-x? :table valid-kr? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) ))
(stest/instrument `tablekt:a)

(defn tablekt:k
  {:arglists '([xindex ktable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "tablekt"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef tablekt:k
  :args (s/cat :index valid-x? :table valid-kr? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) ))
(stest/instrument `tablekt:k)

(defn insremot
  {:arglists '([Sdestination Ssource & instrnum1* instrnum2* instrnum3* instrnum4* instrnum5* instrnum6* instrnum7* instrnum8* instrnum9* instrnum10* instrnum11* instrnum12* instrnum13* instrnum14* instrnum15* instrnum16*])}
  [destination source & [ nstrnum1* nstrnum2* nstrnum3* nstrnum4* nstrnum5* nstrnum6* nstrnum7* nstrnum8* nstrnum9* nstrnum10* nstrnum11* nstrnum12* nstrnum13* nstrnum14* nstrnum15* nstrnum16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "insremot"
                      [destination source nstrnum1* nstrnum2* nstrnum3* nstrnum4* nstrnum5* nstrnum6* nstrnum7* nstrnum8* nstrnum9* nstrnum10* nstrnum11* nstrnum12* nstrnum13* nstrnum14* nstrnum15* nstrnum16*]
                      *global*)]
    (new out-types ast)))

(s/fdef insremot
  :args (s/cat :destination valid-S? :source valid-S? :nstrnum1* (s/? valid-i?*) :nstrnum2* (s/? valid-i?*) :nstrnum3* (s/? valid-i?*) :nstrnum4* (s/? valid-i?*) :nstrnum5* (s/? valid-i?*) :nstrnum6* (s/? valid-i?*) :nstrnum7* (s/? valid-i?*) :nstrnum8* (s/? valid-i?*) :nstrnum9* (s/? valid-i?*) :nstrnum10* (s/? valid-i?*) :nstrnum11* (s/? valid-i?*) :nstrnum12* (s/? valid-i?*) :nstrnum13* (s/? valid-i?*) :nstrnum14* (s/? valid-i?*) :nstrnum15* (s/? valid-i?*) :nstrnum16* (s/? valid-i?*) ))
(stest/instrument `insremot)

(defn minabsaccum
  {:arglists '([aAccumulator aInput])}
  [Accumulator Input]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "minabsaccum"
                      [Accumulator Input]
                      *global*)]
    (new out-types ast)))

(s/fdef minabsaccum
  :args (s/cat :Accumulator valid-ar? :Input valid-ar? ))
(stest/instrument `minabsaccum)

(defn mvclpf3
  {:arglists '([ain acenter-frequency aresonance & istor*] [ain acenter-frequency kresonance & istor*] [ain kcenter-frequency aresonance & istor*] [ain kcenter-frequency kresonance & istor*])}
  [in center-frequency resonance & [ stor* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "mvclpf3"
                      [in center-frequency resonance stor*]
                      *global*)]
    (new out-types ast)))

(s/fdef mvclpf3
  :args (s/alt
         :akki (s/cat :in valid-ar? :center-frequency valid-kr? :resonance valid-kr? :stor* (s/? valid-i?*) )
         :akai (s/cat :in valid-ar? :center-frequency valid-kr? :resonance valid-ar? :stor* (s/? valid-i?*) )
         :aaki (s/cat :in valid-ar? :center-frequency valid-ar? :resonance valid-kr? :stor* (s/? valid-i?*) )
         :aaai (s/cat :in valid-ar? :center-frequency valid-ar? :resonance valid-ar? :stor* (s/? valid-i?*) )
         ))
(stest/instrument `mvclpf3)

(defn tonek
  {:arglists '([ksig khp & iskip*])}
  [sig hp & [ skip* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "tonek"
                      [sig hp skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef tonek
  :args (s/cat :sig valid-kr? :hp valid-kr? :skip* (s/? valid-i?*) ))
(stest/instrument `tonek)

(defn phs
  {:arglists '([kinArr])}
  [in]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "phs"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef phs
  :args (s/cat :in valid-kArr? ))
(stest/instrument `phs)

(defn guiro
  {:arglists '([kamp idettack & inum* idamp* imaxshake* ifreq* ifreq1*])}
  [amp dettack & [ num* damp* maxshake* freq* freq1* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "guiro"
                      [amp dettack num* damp* maxshake* freq* freq1*]
                      *global*)]
    (new out-types ast)))

(s/fdef guiro
  :args (s/cat :amp valid-kr? :dettack valid-i? :num* (s/? valid-i?*) :damp* (s/? valid-i?*) :maxshake* (s/? valid-i?*) :freq* (s/? valid-i?*) :freq1* (s/? valid-i?*) ))
(stest/instrument `guiro)

(defn exp
  {:arglists '([aarg1] [iarg1] [iarg1Arr] [karg1] [karg1Arr])}
  [arg1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "exp"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef exp
  :args (s/alt
         :kArr (s/cat :arg1 valid-kArr? )
         :k (s/cat :arg1 valid-kr? )
         :iArr (s/cat :arg1 valid-iArr? )
         :i (s/cat :arg1 valid-i? )
         :a (s/cat :arg1 valid-ar? )
         ))
(stest/instrument `exp)

(defn exp:a
  {:arglists '([aarg1])}
  [arg1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "exp"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef exp:a
  :args (s/cat :arg1 valid-ar? ))
(stest/instrument `exp:a)

(defn exp:i
  {:arglists '([iarg1])}
  [arg1]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "exp"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef exp:i
  :args (s/cat :arg1 valid-i? ))
(stest/instrument `exp:i)

(defn exp:iArr
  {:arglists '([iarg1Arr])}
  [arg1]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "exp"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef exp:iArr
  :args (s/cat :arg1 valid-iArr? ))
(stest/instrument `exp:iArr)

(defn exp:k
  {:arglists '([karg1])}
  [arg1]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "exp"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef exp:k
  :args (s/cat :arg1 valid-kr? ))
(stest/instrument `exp:k)

(defn exp:kArr
  {:arglists '([karg1Arr])}
  [arg1]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "exp"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef exp:kArr
  :args (s/cat :arg1 valid-kArr? ))
(stest/instrument `exp:kArr)

(defn xscanmap
  {:arglists '([iscan kamp kvamp & iwhich*])}
  [scan amp vamp & [ which* ]]
  (let [out-types-quoted '[ControlSignal ControlSignal]
        out-types [ControlSignal ControlSignal]
        ast (ast-node out-types-quoted
                      "xscanmap"
                      [scan amp vamp which*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef xscanmap
  :args (s/cat :scan valid-i? :amp valid-kr? :vamp valid-kr? :which* (s/? valid-i?*) ))
(stest/instrument `xscanmap)

(defn getcfg
  {:arglists '([iopt])}
  [opt]
  (let [out-types-quoted 'String
        out-types String
        ast (ast-node out-types-quoted
                      "getcfg"
                      [opt]
                      *global*)]
    (new out-types ast)))

(s/fdef getcfg
  :args (s/cat :opt valid-i? ))
(stest/instrument `getcfg)

(defn sorta
  {:arglists '([iarg1Arr] [karg1Arr])}
  [arg1]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "sorta"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sorta
  :args (s/alt
         :kArr (s/cat :arg1 valid-kArr? )
         :iArr (s/cat :arg1 valid-iArr? )
         ))
(stest/instrument `sorta)

(defn sorta:iArr
  {:arglists '([iarg1Arr])}
  [arg1]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "sorta"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sorta:iArr
  :args (s/cat :arg1 valid-iArr? ))
(stest/instrument `sorta:iArr)

(defn sorta:kArr
  {:arglists '([karg1Arr])}
  [arg1]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "sorta"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sorta:kArr
  :args (s/cat :arg1 valid-kArr? ))
(stest/instrument `sorta:kArr)

(defn maparray
  {:arglists '([iiArr Sinarray] [kiArr Sinarray])}
  [i inarray]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "maparray"
                      [i inarray]
                      *global*)]
    (new out-types ast)))

(s/fdef maparray
  :args (s/alt
         :kArrS (s/cat :i valid-kArr? :inarray valid-S? )
         :iArrS (s/cat :i valid-iArr? :inarray valid-S? )
         ))
(stest/instrument `maparray)

(defn maparray:iArr
  {:arglists '([iiArr Sinarray])}
  [i inarray]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "maparray"
                      [i inarray]
                      *global*)]
    (new out-types ast)))

(s/fdef maparray:iArr
  :args (s/cat :i valid-iArr? :inarray valid-S? ))
(stest/instrument `maparray:iArr)

(defn maparray:kArr
  {:arglists '([kiArr Sinarray])}
  [i inarray]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "maparray"
                      [i inarray]
                      *global*)]
    (new out-types ast)))

(s/fdef maparray:kArr
  :args (s/cat :i valid-kArr? :inarray valid-S? ))
(stest/instrument `maparray:kArr)

(defn nlfilt
  {:arglists '([ain ka kb kd kC kL])}
  [in a b d C L]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "nlfilt"
                      [in a b d C L]
                      *global*)]
    (new out-types ast)))

(s/fdef nlfilt
  :args (s/cat :in valid-ar? :a valid-kr? :b valid-kr? :d valid-kr? :C valid-kr? :L valid-kr? ))
(stest/instrument `nlfilt)

(defn vmultv
  {:arglists '([ifn1 ifn2 kelements & kdstoffset* ksrcoffset* kverbose*])}
  [fn1 fn2 elements & [ dstoffset* srcoffset* verbose* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vmultv"
                      [fn1 fn2 elements dstoffset* srcoffset* verbose*]
                      *global*)]
    (new out-types ast)))

(s/fdef vmultv
  :args (s/cat :fn1 valid-i? :fn2 valid-i? :elements valid-kr? :dstoffset* (s/? valid-kr?*) :srcoffset* (s/? valid-kr?*) :verbose* (s/? valid-kr?*) ))
(stest/instrument `vmultv)

(defn modmatrix
  {:arglists '([iresfn isrcmodfn isrcparmfn imodscale inum_mod inum_parm kupdate])}
  [resfn srcmodfn srcparmfn modscale num_mod num_parm update]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "modmatrix"
                      [resfn srcmodfn srcparmfn modscale num_mod num_parm update]
                      *global*)]
    (new out-types ast)))

(s/fdef modmatrix
  :args (s/cat :resfn valid-i? :srcmodfn valid-i? :srcparmfn valid-i? :modscale valid-i? :num_mod valid-i? :num_parm valid-i? :update valid-kr? ))
(stest/instrument `modmatrix)

(defn select
  {:arglists '([aarg1 aarg2 aless aequal amore])}
  [arg1 arg2 less equal more]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "select"
                      [arg1 arg2 less equal more]
                      *global*)]
    (new out-types ast)))

(s/fdef select
  :args (s/cat :arg1 valid-ar? :arg2 valid-ar? :less valid-ar? :equal valid-ar? :more valid-ar? ))
(stest/instrument `select)

(defn wguide1
  {:arglists '([asig xfreq kcutoff kfeedback])}
  [sig freq cutoff feedback]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "wguide1"
                      [sig freq cutoff feedback]
                      *global*)]
    (new out-types ast)))

(s/fdef wguide1
  :args (s/cat :sig valid-ar? :freq valid-x? :cutoff valid-kr? :feedback valid-kr? ))
(stest/instrument `wguide1)

(defn resonz
  {:arglists '([asig xcenter-frequency xbandwidth & iscale* iskip*])}
  [sig center-frequency bandwidth & [ scale* skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "resonz"
                      [sig center-frequency bandwidth scale* skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef resonz
  :args (s/cat :sig valid-ar? :center-frequency valid-x? :bandwidth valid-x? :scale* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `resonz)

(defn dctinv
  {:arglists '([iinArr] [kinArr])}
  [in]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "dctinv"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef dctinv
  :args (s/alt
         :kArr (s/cat :in valid-kArr? )
         :iArr (s/cat :in valid-iArr? )
         ))
(stest/instrument `dctinv)

(defn dctinv:iArr
  {:arglists '([iinArr])}
  [in]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "dctinv"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef dctinv:iArr
  :args (s/cat :in valid-iArr? ))
(stest/instrument `dctinv:iArr)

(defn dctinv:kArr
  {:arglists '([kinArr])}
  [in]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "dctinv"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef dctinv:kArr
  :args (s/cat :in valid-kArr? ))
(stest/instrument `dctinv:kArr)

(defn outletk
  {:arglists '([Sname ksignal])}
  [name signal]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outletk"
                      [name signal]
                      *global*)]
    (new out-types ast)))

(s/fdef outletk
  :args (s/cat :name valid-S? :signal valid-kr? ))
(stest/instrument `outletk)

(defn sfplay3
  {:arglists '([ivel inotenum xamp xfreq ipreindex & iflag* ioffset* ienv*])}
  [vel notenum amp freq preindex & [ flag* offset* env* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "sfplay3"
                      [vel notenum amp freq preindex flag* offset* env*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef sfplay3
  :args (s/cat :vel valid-i? :notenum valid-i? :amp valid-x? :freq valid-x? :preindex valid-i? :flag* (s/? valid-i?*) :offset* (s/? valid-i?*) :env* (s/? valid-i?*) ))
(stest/instrument `sfplay3)

(defn prealloc
  {:arglists '([Sinsname icount & icount*] [iinsname icount & icount*])}
  [insname count & [ count* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "prealloc"
                      [insname count count*]
                      *global*)]
    (new out-types ast)))

(s/fdef prealloc
  :args (s/alt
         :iii (s/cat :insname valid-i? :count valid-i? :count* (s/? valid-i?*) )
         :Sii (s/cat :insname valid-S? :count valid-i? :count* (s/? valid-i?*) )
         ))
(stest/instrument `prealloc)

(defn fof2
  {:arglists '([xamp xfund xform koct kband kris kdur kdec iolaps ifna ifnb itotdur kphase kgliss & iskip*])}
  [amp fund form oct band ris dur dec olaps fna fnb totdur phase gliss & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "fof2"
                      [amp fund form oct band ris dur dec olaps fna fnb totdur phase gliss skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef fof2
  :args (s/cat :amp valid-x? :fund valid-x? :form valid-x? :oct valid-kr? :band valid-kr? :ris valid-kr? :dur valid-kr? :dec valid-kr? :olaps valid-i? :fna valid-i? :fnb valid-i? :totdur valid-i? :phase valid-kr? :gliss valid-kr? :skip* (s/? valid-i?*) ))
(stest/instrument `fof2)

(defn vtablei
  {:arglists '([iindex itable interp ixmode & iout1* iout2* iout3* ioutN4* ioutN5* ioutN6* ioutN7* ioutN8* ioutN9* ioutN10* ioutN11* ioutN12* ioutN13* ioutN14* ioutN15* ioutN16*])}
  [index table nterp xmode & [ out1* out2* out3* outN4* outN5* outN6* outN7* outN8* outN9* outN10* outN11* outN12* outN13* outN14* outN15* outN16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vtablei"
                      [index table nterp xmode out1* out2* out3* outN4* outN5* outN6* outN7* outN8* outN9* outN10* outN11* outN12* outN13* outN14* outN15* outN16*]
                      *global*)]
    (new out-types ast)))

(s/fdef vtablei
  :args (s/cat :index valid-i? :table valid-i? :nterp valid-i? :xmode valid-i? :out1* (s/? valid-i?*) :out2* (s/? valid-i?*) :out3* (s/? valid-i?*) :outN4* (s/? valid-i?*) :outN5* (s/? valid-i?*) :outN6* (s/? valid-i?*) :outN7* (s/? valid-i?*) :outN8* (s/? valid-i?*) :outN9* (s/? valid-i?*) :outN10* (s/? valid-i?*) :outN11* (s/? valid-i?*) :outN12* (s/? valid-i?*) :outN13* (s/? valid-i?*) :outN14* (s/? valid-i?*) :outN15* (s/? valid-i?*) :outN16* (s/? valid-i?*) ))
(stest/instrument `vtablei)

(defn harmon3
  {:arglists '([asig koct kfrq3 kfrq4 kfrq5 icpsmode ilowest & ipolarity*])}
  [sig oct frq3 frq4 frq5 cpsmode lowest & [ polarity* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "harmon3"
                      [sig oct frq3 frq4 frq5 cpsmode lowest polarity*]
                      *global*)]
    (new out-types ast)))

(s/fdef harmon3
  :args (s/cat :sig valid-ar? :oct valid-kr? :frq3 valid-kr? :frq4 valid-kr? :frq5 valid-kr? :cpsmode valid-i? :lowest valid-i? :polarity* (s/? valid-i?*) ))
(stest/instrument `harmon3)

(defn timeinstk
  {:arglists '()}
  []
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "timeinstk"
                      []
                      *global*)]
    (new out-types ast)))


(defn ftgen
  {:arglists '([itable itime isize Sgen Sarray & iarray1* iarray2* iarray3* iarray4* iarray5* iarray6* iarray7* iarray8* iarray9* iarray10* iarray11* iarray12* iarray13* iarray14* iarray15* iarray16*] [itable itime isize Sgen iarrayArr] [itable itime isize Sgen iarray & iarray1* iarray2* iarray3* iarray4* iarray5* iarray6* iarray7* iarray8* iarray9* iarray10* iarray11* iarray12* iarray13* iarray14* iarray15* iarray16*] [itable itime isize igen Sarray & iarray1* iarray2* iarray3* iarray4* iarray5* iarray6* iarray7* iarray8* iarray9* iarray10* iarray11* iarray12* iarray13* iarray14* iarray15* iarray16*] [itable itime isize igen iarrayArr] [itable itime isize igen iarray & iarray1* iarray2* iarray3* iarray4* iarray5* iarray6* iarray7* iarray8* iarray9* iarray10* iarray11* iarray12* iarray13* iarray14* iarray15* iarray16*])}
  [table time size gen array & [ array1* array2* array3* array4* array5* array6* array7* array8* array9* array10* array11* array12* array13* array14* array15* array16* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "ftgen"
                      [table time size gen array array1* array2* array3* array4* array5* array6* array7* array8* array9* array10* array11* array12* array13* array14* array15* array16*]
                      *global*)]
    (new out-types ast)))

(s/fdef ftgen
  :args (s/alt
         :iiiiiiiiiiiiiiiiiiiii (s/cat :table valid-i? :time valid-i? :size valid-i? :gen valid-i? :array valid-i? :array1* (s/? valid-i?*) :array2* (s/? valid-i?*) :array3* (s/? valid-i?*) :array4* (s/? valid-i?*) :array5* (s/? valid-i?*) :array6* (s/? valid-i?*) :array7* (s/? valid-i?*) :array8* (s/? valid-i?*) :array9* (s/? valid-i?*) :array10* (s/? valid-i?*) :array11* (s/? valid-i?*) :array12* (s/? valid-i?*) :array13* (s/? valid-i?*) :array14* (s/? valid-i?*) :array15* (s/? valid-i?*) :array16* (s/? valid-i?*) )
         :iiiiiArr (s/cat :table valid-i? :time valid-i? :size valid-i? :gen valid-i? :array valid-iArr? )
         :iiiiSiiiiiiiiiiiiiiii (s/cat :table valid-i? :time valid-i? :size valid-i? :gen valid-i? :array valid-S? :array1* (s/? valid-i?*) :array2* (s/? valid-i?*) :array3* (s/? valid-i?*) :array4* (s/? valid-i?*) :array5* (s/? valid-i?*) :array6* (s/? valid-i?*) :array7* (s/? valid-i?*) :array8* (s/? valid-i?*) :array9* (s/? valid-i?*) :array10* (s/? valid-i?*) :array11* (s/? valid-i?*) :array12* (s/? valid-i?*) :array13* (s/? valid-i?*) :array14* (s/? valid-i?*) :array15* (s/? valid-i?*) :array16* (s/? valid-i?*) )
         :iiiSiiiiiiiiiiiiiiiii (s/cat :table valid-i? :time valid-i? :size valid-i? :gen valid-S? :array valid-i? :array1* (s/? valid-i?*) :array2* (s/? valid-i?*) :array3* (s/? valid-i?*) :array4* (s/? valid-i?*) :array5* (s/? valid-i?*) :array6* (s/? valid-i?*) :array7* (s/? valid-i?*) :array8* (s/? valid-i?*) :array9* (s/? valid-i?*) :array10* (s/? valid-i?*) :array11* (s/? valid-i?*) :array12* (s/? valid-i?*) :array13* (s/? valid-i?*) :array14* (s/? valid-i?*) :array15* (s/? valid-i?*) :array16* (s/? valid-i?*) )
         :iiiSiArr (s/cat :table valid-i? :time valid-i? :size valid-i? :gen valid-S? :array valid-iArr? )
         :iiiSSiiiiiiiiiiiiiiii (s/cat :table valid-i? :time valid-i? :size valid-i? :gen valid-S? :array valid-S? :array1* (s/? valid-i?*) :array2* (s/? valid-i?*) :array3* (s/? valid-i?*) :array4* (s/? valid-i?*) :array5* (s/? valid-i?*) :array6* (s/? valid-i?*) :array7* (s/? valid-i?*) :array8* (s/? valid-i?*) :array9* (s/? valid-i?*) :array10* (s/? valid-i?*) :array11* (s/? valid-i?*) :array12* (s/? valid-i?*) :array13* (s/? valid-i?*) :array14* (s/? valid-i?*) :array15* (s/? valid-i?*) :array16* (s/? valid-i?*) )
         ))
(stest/instrument `ftgen)

(defn outkc
  {:arglists '([kchn knum kvalue kmin kmax])}
  [chn num value min max]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outkc"
                      [chn num value min max]
                      *global*)]
    (new out-types ast)))

(s/fdef outkc
  :args (s/cat :chn valid-kr? :num valid-kr? :value valid-kr? :min valid-kr? :max valid-kr? ))
(stest/instrument `outkc)

(defn vmult
  {:arglists '([itable kval kelements & kdstoffset* kverbose*])}
  [table val elements & [ dstoffset* verbose* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vmult"
                      [table val elements dstoffset* verbose*]
                      *global*)]
    (new out-types ast)))

(s/fdef vmult
  :args (s/cat :table valid-i? :val valid-kr? :elements valid-kr? :dstoffset* (s/? valid-kr?*) :verbose* (s/? valid-kr?*) ))
(stest/instrument `vmult)

(defn chnset
  {:arglists '([Ss Sval] [as Sval] [is Sval] [ks Sval])}
  [s val]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "chnset"
                      [s val]
                      *global*)]
    (new out-types ast)))

(s/fdef chnset
  :args (s/alt
         :kS (s/cat :s valid-kr? :val valid-S? )
         :iS (s/cat :s valid-i? :val valid-S? )
         :aS (s/cat :s valid-ar? :val valid-S? )
         :SS (s/cat :s valid-S? :val valid-S? )
         ))
(stest/instrument `chnset)

(defn opcode
  {:arglists '()}
  []
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "opcode"
                      []
                      *global*)]
    (new out-types ast)))


(defn seqtime
  {:arglists '([ktime_unit kstart kloop kinitndx kfn_times])}
  [time_unit start loop initndx fn_times]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "seqtime"
                      [time_unit start loop initndx fn_times]
                      *global*)]
    (new out-types ast)))

(s/fdef seqtime
  :args (s/cat :time_unit valid-kr? :start valid-kr? :loop valid-kr? :initndx valid-kr? :fn_times valid-kr? ))
(stest/instrument `seqtime)

(defn syncloop
  {:arglists '([kamp kfreq kpitch kgrsize kprate klstart klend ifun8 ifun9 iolaps & istart* iskip*])}
  [amp freq pitch grsize prate lstart lend fun8 fun9 olaps & [ start* skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "syncloop"
                      [amp freq pitch grsize prate lstart lend fun8 fun9 olaps start* skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef syncloop
  :args (s/cat :amp valid-kr? :freq valid-kr? :pitch valid-kr? :grsize valid-kr? :prate valid-kr? :lstart valid-kr? :lend valid-kr? :fun8 valid-i? :fun9 valid-i? :olaps valid-i? :start* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `syncloop)

(defn lpfreson
  {:arglists '([asig kfrqratio])}
  [sig frqratio]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "lpfreson"
                      [sig frqratio]
                      *global*)]
    (new out-types ast)))

(s/fdef lpfreson
  :args (s/cat :sig valid-ar? :frqratio valid-kr? ))
(stest/instrument `lpfreson)

(defn dates
  {:arglists '([& itime*])}
  [& [ time* ]]
  (let [out-types-quoted 'String
        out-types String
        ast (ast-node out-types-quoted
                      "dates"
                      [time*]
                      *global*)]
    (new out-types ast)))

(s/fdef dates
  :args (s/cat :time* (s/? valid-i?*) ))
(stest/instrument `dates)

(defn pvsgain
  {:arglists '([fsigin kgain])}
  [sigin gain]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvsgain"
                      [sigin gain]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsgain
  :args (s/cat :sigin valid-f? :gain valid-kr? ))
(stest/instrument `pvsgain)

(defn biquada
  {:arglists '([asig ab2 ab3 ab4 aa5 aa6 aa7 & iskip*])}
  [sig b2 b3 b4 a5 a6 a7 & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "biquada"
                      [sig b2 b3 b4 a5 a6 a7 skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef biquada
  :args (s/cat :sig valid-ar? :b2 valid-ar? :b3 valid-ar? :b4 valid-ar? :a5 valid-ar? :a6 valid-ar? :a7 valid-ar? :skip* (s/? valid-i?*) ))
(stest/instrument `biquada)

(defn strlenk
  {:arglists '([Sstr])}
  [str]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "strlenk"
                      [str]
                      *global*)]
    (new out-types ast)))

(s/fdef strlenk
  :args (s/cat :str valid-S? ))
(stest/instrument `strlenk)

(defn framebuffer
  {:arglists '([ain isize] [kin isize])}
  [in size]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "framebuffer"
                      [in size]
                      *global*)]
    (new out-types ast)))

(s/fdef framebuffer
  :args (s/alt
         :ki (s/cat :in valid-kr? :size valid-i? )
         :ai (s/cat :in valid-ar? :size valid-i? )
         ))
(stest/instrument `framebuffer)

(defn framebuffer:kArr
  {:arglists '([ain isize])}
  [in size]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "framebuffer"
                      [in size]
                      *global*)]
    (new out-types ast)))

(s/fdef framebuffer:kArr
  :args (s/cat :in valid-ar? :size valid-i? ))
(stest/instrument `framebuffer:kArr)

(defn framebuffer:a
  {:arglists '([kin isize])}
  [in size]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "framebuffer"
                      [in size]
                      *global*)]
    (new out-types ast)))

(s/fdef framebuffer:a
  :args (s/cat :in valid-kr? :size valid-i? ))
(stest/instrument `framebuffer:a)

(defn lenarray
  {:arglists '([iarrayArr & iwhich*] [karrayArr & iwhich*])}
  [array & [ which* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "lenarray"
                      [array which*]
                      *global*)]
    (new out-types ast)))

(s/fdef lenarray
  :args (s/alt
         :kArri (s/cat :array valid-kArr? :which* (s/? valid-i?*) )
         :iArri (s/cat :array valid-iArr? :which* (s/? valid-i?*) )
         ))
(stest/instrument `lenarray)

(defn lenarray:i
  {:arglists '([iarrayArr & iwhich*])}
  [array & [ which* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "lenarray"
                      [array which*]
                      *global*)]
    (new out-types ast)))

(s/fdef lenarray:i
  :args (s/cat :array valid-iArr? :which* (s/? valid-i?*) ))
(stest/instrument `lenarray:i)

(defn lenarray:k
  {:arglists '([karrayArr & iwhich*])}
  [array & [ which* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "lenarray"
                      [array which*]
                      *global*)]
    (new out-types ast)))

(s/fdef lenarray:k
  :args (s/cat :array valid-kArr? :which* (s/? valid-i?*) ))
(stest/instrument `lenarray:k)

(defn hrtfreverb
  {:arglists '([asrc ilowrt2 ihighrt3 Sfilel Sfiler & isr* imfp* iorder*])}
  [src lowrt2 highrt3 filel filer & [ sr* mfp* order* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal Variable]
        out-types [AudioSignal AudioSignal Variable]
        ast (ast-node out-types-quoted
                      "hrtfreverb"
                      [src lowrt2 highrt3 filel filer sr* mfp* order*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef hrtfreverb
  :args (s/cat :src valid-ar? :lowrt2 valid-i? :highrt3 valid-i? :filel valid-S? :filer valid-S? :sr* (s/? valid-i?*) :mfp* (s/? valid-i?*) :order* (s/? valid-i?*) ))
(stest/instrument `hrtfreverb)

(defn scans
  {:arglists '([kamp kfreq itable id & iorder*])}
  [amp freq table d & [ order* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "scans"
                      [amp freq table d order*]
                      *global*)]
    (new out-types ast)))

(s/fdef scans
  :args (s/cat :amp valid-kr? :freq valid-kr? :table valid-i? :d valid-i? :order* (s/? valid-i?*) ))
(stest/instrument `scans)

(defn vdelayxq
  {:arglists '([ain1 ain2 ain3 ain4 adl imd iws & ist*])}
  [in1 in2 in3 in4 dl md ws & [ st* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "vdelayxq"
                      [in1 in2 in3 in4 dl md ws st*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef vdelayxq
  :args (s/cat :in1 valid-ar? :in2 valid-ar? :in3 valid-ar? :in4 valid-ar? :dl valid-ar? :md valid-i? :ws valid-i? :st* (s/? valid-i?*) ))
(stest/instrument `vdelayxq)

(defn wgpluck2
  {:arglists '([iplk kamp icps kpick krefl])}
  [plk amp cps pick refl]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "wgpluck2"
                      [plk amp cps pick refl]
                      *global*)]
    (new out-types ast)))

(s/fdef wgpluck2
  :args (s/cat :plk valid-i? :amp valid-kr? :cps valid-i? :pick valid-kr? :refl valid-kr? ))
(stest/instrument `wgpluck2)

(defn remove
  {:arglists '([iinsnum] [Sinsnum])}
  [insnum]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "remove"
                      [insnum]
                      *global*)]
    (new out-types ast)))

(s/fdef remove
  :args (s/alt
         :S (s/cat :insnum valid-S? )
         :i (s/cat :insnum valid-i? )
         ))
(stest/instrument `remove)

(defn fold
  {:arglists '([asig kincr])}
  [sig incr]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "fold"
                      [sig incr]
                      *global*)]
    (new out-types ast)))

(s/fdef fold
  :args (s/cat :sig valid-ar? :incr valid-kr? ))
(stest/instrument `fold)

(defn mpulse
  {:arglists '([kamp kintvl & ioffset*])}
  [amp intvl & [ offset* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "mpulse"
                      [amp intvl offset*]
                      *global*)]
    (new out-types ast)))

(s/fdef mpulse
  :args (s/cat :amp valid-kr? :intvl valid-kr? :offset* (s/? valid-i?*) ))
(stest/instrument `mpulse)

(defn hvs1
  {:arglists '([kx inumParms inumPointsX iOutTab iPositionsTab iSnapTab & iConfigTab*])}
  [x numParms numPointsX OutTab PositionsTab SnapTab & [ ConfigTab* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "hvs1"
                      [x numParms numPointsX OutTab PositionsTab SnapTab ConfigTab*]
                      *global*)]
    (new out-types ast)))

(s/fdef hvs1
  :args (s/cat :x valid-kr? :numParms valid-i? :numPointsX valid-i? :OutTab valid-i? :PositionsTab valid-i? :SnapTab valid-i? :ConfigTab* (s/? valid-i?*) ))
(stest/instrument `hvs1)

(defn chn_S
  {:arglists '([Sname imode])}
  [name mode]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "chn_S"
                      [name mode]
                      *global*)]
    (new out-types ast)))

(s/fdef chn_S
  :args (s/cat :name valid-S? :mode valid-i? ))
(stest/instrument `chn_S)

(defn vexpv_i
  {:arglists '([ifn1 ifn2 ielements & idstoffset* isrcoffset*])}
  [fn1 fn2 elements & [ dstoffset* srcoffset* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vexpv_i"
                      [fn1 fn2 elements dstoffset* srcoffset*]
                      *global*)]
    (new out-types ast)))

(s/fdef vexpv_i
  :args (s/cat :fn1 valid-i? :fn2 valid-i? :elements valid-i? :dstoffset* (s/? valid-i?*) :srcoffset* (s/? valid-i?*) ))
(stest/instrument `vexpv_i)

(defn pvcross
  {:arglists '([ktimpnt kfmod Sfile kampscale4 kampscale5 & ispecwp*] [ktimpnt kfmod ifile kampscale4 kampscale5 & ispecwp*])}
  [timpnt fmod file ampscale4 ampscale5 & [ specwp* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "pvcross"
                      [timpnt fmod file ampscale4 ampscale5 specwp*]
                      *global*)]
    (new out-types ast)))

(s/fdef pvcross
  :args (s/alt
         :kkikki (s/cat :timpnt valid-kr? :fmod valid-kr? :file valid-i? :ampscale4 valid-kr? :ampscale5 valid-kr? :specwp* (s/? valid-i?*) )
         :kkSkki (s/cat :timpnt valid-kr? :fmod valid-kr? :file valid-S? :ampscale4 valid-kr? :ampscale5 valid-kr? :specwp* (s/? valid-i?*) )
         ))
(stest/instrument `pvcross)

(defn randi
  {:arglists '([xamp xcps iseed & isize* ioffset*] [xamp xcps iseed & isize* ioffset*])}
  [amp cps seed & [ size* offset* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "randi"
                      [amp cps seed size* offset*]
                      *global*)]
    (new out-types ast)))

(s/fdef randi
  :args (s/alt
         :xxiii (s/cat :amp valid-x? :cps valid-x? :seed valid-i? :size* (s/? valid-i?*) :offset* (s/? valid-i?*) )
         ))
(stest/instrument `randi)

(defn randi:a
  {:arglists '([xamp xcps iseed & isize* ioffset*])}
  [amp cps seed & [ size* offset* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "randi"
                      [amp cps seed size* offset*]
                      *global*)]
    (new out-types ast)))

(s/fdef randi:a
  :args (s/cat :amp valid-x? :cps valid-x? :seed valid-i? :size* (s/? valid-i?*) :offset* (s/? valid-i?*) ))
(stest/instrument `randi:a)

(defn randi:k
  {:arglists '([xamp xcps iseed & isize* ioffset*])}
  [amp cps seed & [ size* offset* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "randi"
                      [amp cps seed size* offset*]
                      *global*)]
    (new out-types ast)))

(s/fdef randi:k
  :args (s/cat :amp valid-x? :cps valid-x? :seed valid-i? :size* (s/? valid-i?*) :offset* (s/? valid-i?*) ))
(stest/instrument `randi:k)

(defn compilestr
  {:arglists '([Sorch])}
  [orch]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "compilestr"
                      [orch]
                      *global*)]
    (new out-types ast)))

(s/fdef compilestr
  :args (s/cat :orch valid-S? ))
(stest/instrument `compilestr)

(defn cpstuni
  {:arglists '([index itable])}
  [ndex table]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "cpstuni"
                      [ndex table]
                      *global*)]
    (new out-types ast)))

(s/fdef cpstuni
  :args (s/cat :ndex valid-i? :table valid-i? ))
(stest/instrument `cpstuni)

(defn log10
  {:arglists '([aarg1] [iarg1] [iarg1Arr] [karg1] [karg1Arr])}
  [arg1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "log10"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef log10
  :args (s/alt
         :kArr (s/cat :arg1 valid-kArr? )
         :k (s/cat :arg1 valid-kr? )
         :iArr (s/cat :arg1 valid-iArr? )
         :i (s/cat :arg1 valid-i? )
         :a (s/cat :arg1 valid-ar? )
         ))
(stest/instrument `log10)

(defn log10:a
  {:arglists '([aarg1])}
  [arg1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "log10"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef log10:a
  :args (s/cat :arg1 valid-ar? ))
(stest/instrument `log10:a)

(defn log10:i
  {:arglists '([iarg1])}
  [arg1]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "log10"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef log10:i
  :args (s/cat :arg1 valid-i? ))
(stest/instrument `log10:i)

(defn log10:iArr
  {:arglists '([iarg1Arr])}
  [arg1]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "log10"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef log10:iArr
  :args (s/cat :arg1 valid-iArr? ))
(stest/instrument `log10:iArr)

(defn log10:k
  {:arglists '([karg1])}
  [arg1]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "log10"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef log10:k
  :args (s/cat :arg1 valid-kr? ))
(stest/instrument `log10:k)

(defn log10:kArr
  {:arglists '([karg1Arr])}
  [arg1]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "log10"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef log10:kArr
  :args (s/cat :arg1 valid-kArr? ))
(stest/instrument `log10:kArr)

(defn mton
  {:arglists '([imidi] [kmidi])}
  [midi]
  (let [out-types-quoted 'String
        out-types String
        ast (ast-node out-types-quoted
                      "mton"
                      [midi]
                      *global*)]
    (new out-types ast)))

(s/fdef mton
  :args (s/alt
         :k (s/cat :midi valid-kr? )
         :i (s/cat :midi valid-i? )
         ))
(stest/instrument `mton)

(defn midion2
  {:arglists '([kchn knum kvel ktrig])}
  [chn num vel trig]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "midion2"
                      [chn num vel trig]
                      *global*)]
    (new out-types ast)))

(s/fdef midion2
  :args (s/cat :chn valid-kr? :num valid-kr? :vel valid-kr? :trig valid-kr? ))
(stest/instrument `midion2)

(defn pvscent
  {:arglists '([fsig])}
  [sig]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "pvscent"
                      [sig]
                      *global*)]
    (new out-types ast)))

(s/fdef pvscent
  :args (s/cat :sig valid-f? ))
(stest/instrument `pvscent)

(defn readk2
  {:arglists '([Sfilname iformat iprd] [ifilname iformat iprd])}
  [filname format prd]
  (let [out-types-quoted '[ControlSignal ControlSignal]
        out-types [ControlSignal ControlSignal]
        ast (ast-node out-types-quoted
                      "readk2"
                      [filname format prd]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef readk2
  :args (s/alt
         :iii (s/cat :filname valid-i? :format valid-i? :prd valid-i? )
         :Sii (s/cat :filname valid-S? :format valid-i? :prd valid-i? )
         ))
(stest/instrument `readk2)

(defn harmon4
  {:arglists '([asig koct kfrq3 kfrq4 kfrq5 kfrq6 icpsmode ilowest & ipolarity*])}
  [sig oct frq3 frq4 frq5 frq6 cpsmode lowest & [ polarity* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "harmon4"
                      [sig oct frq3 frq4 frq5 frq6 cpsmode lowest polarity*]
                      *global*)]
    (new out-types ast)))

(s/fdef harmon4
  :args (s/cat :sig valid-ar? :oct valid-kr? :frq3 valid-kr? :frq4 valid-kr? :frq5 valid-kr? :frq6 valid-kr? :cpsmode valid-i? :lowest valid-i? :polarity* (s/? valid-i?*) ))
(stest/instrument `harmon4)

(defn jitter
  {:arglists '([kamp kcpsMin kcpsMax])}
  [amp cpsMin cpsMax]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "jitter"
                      [amp cpsMin cpsMax]
                      *global*)]
    (new out-types ast)))

(s/fdef jitter
  :args (s/cat :amp valid-kr? :cpsMin valid-kr? :cpsMax valid-kr? ))
(stest/instrument `jitter)

(defn moogladder
  {:arglists '([ain acenter-frequency aresonance & istor*] [ain acenter-frequency kresonance & istor*] [ain kcenter-frequency aresonance & istor*] [ain kcenter-frequency kresonance & istor*])}
  [in center-frequency resonance & [ stor* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "moogladder"
                      [in center-frequency resonance stor*]
                      *global*)]
    (new out-types ast)))

(s/fdef moogladder
  :args (s/alt
         :akki (s/cat :in valid-ar? :center-frequency valid-kr? :resonance valid-kr? :stor* (s/? valid-i?*) )
         :akai (s/cat :in valid-ar? :center-frequency valid-kr? :resonance valid-ar? :stor* (s/? valid-i?*) )
         :aaki (s/cat :in valid-ar? :center-frequency valid-ar? :resonance valid-kr? :stor* (s/? valid-i?*) )
         :aaai (s/cat :in valid-ar? :center-frequency valid-ar? :resonance valid-ar? :stor* (s/? valid-i?*) )
         ))
(stest/instrument `moogladder)

(defn diode_ladder
  {:arglists '([ain xcenter-frequency xk & knlp* ksaturation* istor*])}
  [in center-frequency k & [ nlp* saturation* stor* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "diode_ladder"
                      [in center-frequency k nlp* saturation* stor*]
                      *global*)]
    (new out-types ast)))

(s/fdef diode_ladder
  :args (s/cat :in valid-ar? :center-frequency valid-x? :k valid-x? :nlp* (s/? valid-kr?*) :saturation* (s/? valid-kr?*) :stor* (s/? valid-i?*) ))
(stest/instrument `diode_ladder)

(defn notnum
  {:arglists '()}
  []
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "notnum"
                      []
                      *global*)]
    (new out-types ast)))


(defn delayk
  {:arglists '([ksig idelay & imode*])}
  [sig delay & [ mode* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "delayk"
                      [sig delay mode*]
                      *global*)]
    (new out-types ast)))

(s/fdef delayk
  :args (s/cat :sig valid-kr? :delay valid-i? :mode* (s/? valid-i?*) ))
(stest/instrument `delayk)

(defn ATSsinnoi
  {:arglists '([ktimepnt ksinlev knzlev kfmod Satsfile ipartials & ipartialoffset* ipartialincr*] [ktimepnt ksinlev knzlev kfmod iatsfile ipartials & ipartialoffset* ipartialincr*])}
  [timepnt sinlev nzlev fmod atsfile partials & [ partialoffset* partialincr* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "ATSsinnoi"
                      [timepnt sinlev nzlev fmod atsfile partials partialoffset* partialincr*]
                      *global*)]
    (new out-types ast)))

(s/fdef ATSsinnoi
  :args (s/alt
         :kkkkiiii (s/cat :timepnt valid-kr? :sinlev valid-kr? :nzlev valid-kr? :fmod valid-kr? :atsfile valid-i? :partials valid-i? :partialoffset* (s/? valid-i?*) :partialincr* (s/? valid-i?*) )
         :kkkkSiii (s/cat :timepnt valid-kr? :sinlev valid-kr? :nzlev valid-kr? :fmod valid-kr? :atsfile valid-S? :partials valid-i? :partialoffset* (s/? valid-i?*) :partialincr* (s/? valid-i?*) )
         ))
(stest/instrument `ATSsinnoi)

(defn fmax
  {:arglists '([iargArr iarg2] [iargArr iarg2Arr] [kargArr karg2] [kargArr karg2Arr])}
  [arg arg2]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "fmax"
                      [arg arg2]
                      *global*)]
    (new out-types ast)))

(s/fdef fmax
  :args (s/alt
         :kArrkArr (s/cat :arg valid-kArr? :arg2 valid-kArr? )
         :kArrk (s/cat :arg valid-kArr? :arg2 valid-kr? )
         :iArriArr (s/cat :arg valid-iArr? :arg2 valid-iArr? )
         :iArri (s/cat :arg valid-iArr? :arg2 valid-i? )
         ))
(stest/instrument `fmax)

(defn fmax:iArr
  {:arglists '([iargArr iarg2] [iargArr iarg2Arr])}
  [arg arg2]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "fmax"
                      [arg arg2]
                      *global*)]
    (new out-types ast)))

(s/fdef fmax:iArr
  :args (s/alt
         :iArriArr (s/cat :arg valid-iArr? :arg2 valid-iArr? )
         :iArri (s/cat :arg valid-iArr? :arg2 valid-i? )
         ))
(stest/instrument `fmax:iArr)

(defn fmax:kArr
  {:arglists '([kargArr karg2] [kargArr karg2Arr])}
  [arg arg2]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "fmax"
                      [arg arg2]
                      *global*)]
    (new out-types ast)))

(s/fdef fmax:kArr
  :args (s/alt
         :kArrkArr (s/cat :arg valid-kArr? :arg2 valid-kArr? )
         :kArrk (s/cat :arg valid-kArr? :arg2 valid-kr? )
         ))
(stest/instrument `fmax:kArr)

(defn dumpk2
  {:arglists '([ksig1 ksig2 Sfilname iformat iprd] [ksig1 ksig2 ifilname iformat iprd])}
  [sig1 sig2 filname format prd]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "dumpk2"
                      [sig1 sig2 filname format prd]
                      *global*)]
    (new out-types ast)))

(s/fdef dumpk2
  :args (s/alt
         :kkiii (s/cat :sig1 valid-kr? :sig2 valid-kr? :filname valid-i? :format valid-i? :prd valid-i? )
         :kkSii (s/cat :sig1 valid-kr? :sig2 valid-kr? :filname valid-S? :format valid-i? :prd valid-i? )
         ))
(stest/instrument `dumpk2)

(defn scoreline
  {:arglists '([Sin ktrig])}
  [in trig]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "scoreline"
                      [in trig]
                      *global*)]
    (new out-types ast)))

(s/fdef scoreline
  :args (s/cat :in valid-S? :trig valid-kr? ))
(stest/instrument `scoreline)

(defn moogvcf2
  {:arglists '([asig xcutoff-frequency xresonance & iscale* iskip*])}
  [sig cutoff-frequency resonance & [ scale* skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "moogvcf2"
                      [sig cutoff-frequency resonance scale* skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef moogvcf2
  :args (s/cat :sig valid-ar? :cutoff-frequency valid-x? :resonance valid-x? :scale* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `moogvcf2)

(defn pvsin
  {:arglists '([kchan & isize* iolap* iwinsize* iwintype* iformat*])}
  [chan & [ size* olap* winsize* wintype* format* ]]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvsin"
                      [chan size* olap* winsize* wintype* format*]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsin
  :args (s/cat :chan valid-kr? :size* (s/? valid-i?*) :olap* (s/? valid-i?*) :winsize* (s/? valid-i?*) :wintype* (s/? valid-i?*) :format* (s/? valid-i?*) ))
(stest/instrument `pvsin)

(defn dcblock
  {:arglists '([ain & igain*])}
  [in & [ gain* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "dcblock"
                      [in gain*]
                      *global*)]
    (new out-types ast)))

(s/fdef dcblock
  :args (s/cat :in valid-ar? :gain* (s/? valid-i?*) ))
(stest/instrument `dcblock)

(defn strtol
  {:arglists '([Sindex] [iindex])}
  [index]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "strtol"
                      [index]
                      *global*)]
    (new out-types ast)))

(s/fdef strtol
  :args (s/alt
         :i (s/cat :index valid-i? )
         :S (s/cat :index valid-S? )
         ))
(stest/instrument `strtol)

(defn sfplist
  {:arglists '([ifilhandle])}
  [filhandle]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "sfplist"
                      [filhandle]
                      *global*)]
    (new out-types ast)))

(s/fdef sfplist
  :args (s/cat :filhandle valid-i? ))
(stest/instrument `sfplist)

(defn vlimit
  {:arglists '([itable kmin kmax ielements])}
  [table min max elements]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vlimit"
                      [table min max elements]
                      *global*)]
    (new out-types ast)))

(s/fdef vlimit
  :args (s/cat :table valid-i? :min valid-kr? :max valid-kr? :elements valid-i? ))
(stest/instrument `vlimit)

(defn pdclip
  {:arglists '([ain kWidth kCenter & ibipolar* ifullscale*])}
  [in Width Center & [ bipolar* fullscale* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "pdclip"
                      [in Width Center bipolar* fullscale*]
                      *global*)]
    (new out-types ast)))

(s/fdef pdclip
  :args (s/cat :in valid-ar? :Width valid-kr? :Center valid-kr? :bipolar* (s/? valid-i?*) :fullscale* (s/? valid-i?*) ))
(stest/instrument `pdclip)

(defn pdhalf
  {:arglists '([ain kShapeAmount & ibipolar* ifullscale*])}
  [in ShapeAmount & [ bipolar* fullscale* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "pdhalf"
                      [in ShapeAmount bipolar* fullscale*]
                      *global*)]
    (new out-types ast)))

(s/fdef pdhalf
  :args (s/cat :in valid-ar? :ShapeAmount valid-kr? :bipolar* (s/? valid-i?*) :fullscale* (s/? valid-i?*) ))
(stest/instrument `pdhalf)

(defn vrandi
  {:arglists '([itable krange kcps ielements & idstoffset* iseed* isize* ioffset*])}
  [table range cps elements & [ dstoffset* seed* size* offset* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vrandi"
                      [table range cps elements dstoffset* seed* size* offset*]
                      *global*)]
    (new out-types ast)))

(s/fdef vrandi
  :args (s/cat :table valid-i? :range valid-kr? :cps valid-kr? :elements valid-i? :dstoffset* (s/? valid-i?*) :seed* (s/? valid-i?*) :size* (s/? valid-i?*) :offset* (s/? valid-i?*) ))
(stest/instrument `vrandi)

(defn butterhp
  {:arglists '([asig afreq & iskip*] [asig kfreq & iskip*])}
  [sig freq & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "butterhp"
                      [sig freq skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef butterhp
  :args (s/alt
         :aki (s/cat :sig valid-ar? :freq valid-kr? :skip* (s/? valid-i?*) )
         :aai (s/cat :sig valid-ar? :freq valid-ar? :skip* (s/? valid-i?*) )
         ))
(stest/instrument `butterhp)

(defn invalue
  {:arglists '([Schannel-name] [ichannel-name] [Schannel-name] [ichannel-name] [Schannel-name] [ichannel-name])}
  [channel-name]
  (let [out-types-quoted 'String
        out-types String
        ast (ast-node out-types-quoted
                      "invalue"
                      [channel-name]
                      *global*)]
    (new out-types ast)))

(s/fdef invalue
  :args (s/alt
         :i (s/cat :channel-name valid-i? )
         :S (s/cat :channel-name valid-S? )
         ))
(stest/instrument `invalue)

(defn invalue:S
  {:arglists '([Schannel-name] [ichannel-name])}
  [channel-name]
  (let [out-types-quoted 'String
        out-types String
        ast (ast-node out-types-quoted
                      "invalue"
                      [channel-name]
                      *global*)]
    (new out-types ast)))

(s/fdef invalue:S
  :args (s/alt
         :i (s/cat :channel-name valid-i? )
         :S (s/cat :channel-name valid-S? )
         ))
(stest/instrument `invalue:S)

(defn invalue:i
  {:arglists '([Schannel-name] [ichannel-name])}
  [channel-name]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "invalue"
                      [channel-name]
                      *global*)]
    (new out-types ast)))

(s/fdef invalue:i
  :args (s/alt
         :i (s/cat :channel-name valid-i? )
         :S (s/cat :channel-name valid-S? )
         ))
(stest/instrument `invalue:i)

(defn invalue:k
  {:arglists '([Schannel-name] [ichannel-name])}
  [channel-name]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "invalue"
                      [channel-name]
                      *global*)]
    (new out-types ast)))

(s/fdef invalue:k
  :args (s/alt
         :i (s/cat :channel-name valid-i? )
         :S (s/cat :channel-name valid-S? )
         ))
(stest/instrument `invalue:k)

(defn strindex
  {:arglists '([Sarg1 Sarg2])}
  [arg1 arg2]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "strindex"
                      [arg1 arg2]
                      *global*)]
    (new out-types ast)))

(s/fdef strindex
  :args (s/cat :arg1 valid-S? :arg2 valid-S? ))
(stest/instrument `strindex)

(defn sqrt
  {:arglists '([aarg1] [iarg1] [iarg1Arr] [karg1] [karg1Arr])}
  [arg1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "sqrt"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sqrt
  :args (s/alt
         :kArr (s/cat :arg1 valid-kArr? )
         :k (s/cat :arg1 valid-kr? )
         :iArr (s/cat :arg1 valid-iArr? )
         :i (s/cat :arg1 valid-i? )
         :a (s/cat :arg1 valid-ar? )
         ))
(stest/instrument `sqrt)

(defn sqrt:a
  {:arglists '([aarg1])}
  [arg1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "sqrt"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sqrt:a
  :args (s/cat :arg1 valid-ar? ))
(stest/instrument `sqrt:a)

(defn sqrt:i
  {:arglists '([iarg1])}
  [arg1]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "sqrt"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sqrt:i
  :args (s/cat :arg1 valid-i? ))
(stest/instrument `sqrt:i)

(defn sqrt:iArr
  {:arglists '([iarg1Arr])}
  [arg1]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "sqrt"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sqrt:iArr
  :args (s/cat :arg1 valid-iArr? ))
(stest/instrument `sqrt:iArr)

(defn sqrt:k
  {:arglists '([karg1])}
  [arg1]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "sqrt"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sqrt:k
  :args (s/cat :arg1 valid-kr? ))
(stest/instrument `sqrt:k)

(defn sqrt:kArr
  {:arglists '([karg1Arr])}
  [arg1]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "sqrt"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sqrt:kArr
  :args (s/cat :arg1 valid-kArr? ))
(stest/instrument `sqrt:kArr)

(defn butterlp
  {:arglists '([asig afreq & iskip*] [asig kfreq & iskip*])}
  [sig freq & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "butterlp"
                      [sig freq skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef butterlp
  :args (s/alt
         :aki (s/cat :sig valid-ar? :freq valid-kr? :skip* (s/? valid-i?*) )
         :aai (s/cat :sig valid-ar? :freq valid-ar? :skip* (s/? valid-i?*) )
         ))
(stest/instrument `butterlp)

(defn vtabk
  {:arglists '([kindex itable & kout1* kout2* kout3* koutN4* koutN5* koutN6* koutN7* koutN8* koutN9* koutN10* koutN11* koutN12* koutN13* koutN14* koutN15* koutN16*])}
  [index table & [ out1* out2* out3* outN4* outN5* outN6* outN7* outN8* outN9* outN10* outN11* outN12* outN13* outN14* outN15* outN16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vtabk"
                      [index table out1* out2* out3* outN4* outN5* outN6* outN7* outN8* outN9* outN10* outN11* outN12* outN13* outN14* outN15* outN16*]
                      *global*)]
    (new out-types ast)))

(s/fdef vtabk
  :args (s/cat :index valid-kr? :table valid-i? :out1* (s/? valid-kr?*) :out2* (s/? valid-kr?*) :out3* (s/? valid-kr?*) :outN4* (s/? valid-kr?*) :outN5* (s/? valid-kr?*) :outN6* (s/? valid-kr?*) :outN7* (s/? valid-kr?*) :outN8* (s/? valid-kr?*) :outN9* (s/? valid-kr?*) :outN10* (s/? valid-kr?*) :outN11* (s/? valid-kr?*) :outN12* (s/? valid-kr?*) :outN13* (s/? valid-kr?*) :outN14* (s/? valid-kr?*) :outN15* (s/? valid-kr?*) :outN16* (s/? valid-kr?*) ))
(stest/instrument `vtabk)

(defn printk2
  {:arglists '([kvar & inumspaces*])}
  [var & [ numspaces* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "printk2"
                      [var numspaces*]
                      *global*)]
    (new out-types ast)))

(s/fdef printk2
  :args (s/cat :var valid-kr? :numspaces* (s/? valid-i?*) ))
(stest/instrument `printk2)

(defn tempo
  {:arglists '([ktempo istarttempo])}
  [tempo starttempo]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "tempo"
                      [tempo starttempo]
                      *global*)]
    (new out-types ast)))

(s/fdef tempo
  :args (s/cat :tempo valid-kr? :starttempo valid-i? ))
(stest/instrument `tempo)

(defn sortd
  {:arglists '([iarg1Arr] [karg1Arr])}
  [arg1]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "sortd"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sortd
  :args (s/alt
         :kArr (s/cat :arg1 valid-kArr? )
         :iArr (s/cat :arg1 valid-iArr? )
         ))
(stest/instrument `sortd)

(defn sortd:iArr
  {:arglists '([iarg1Arr])}
  [arg1]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "sortd"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sortd:iArr
  :args (s/cat :arg1 valid-iArr? ))
(stest/instrument `sortd:iArr)

(defn sortd:kArr
  {:arglists '([karg1Arr])}
  [arg1]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "sortd"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sortd:kArr
  :args (s/cat :arg1 valid-kArr? ))
(stest/instrument `sortd:kArr)

(defn serialWrite_i
  {:arglists '([iPort SBytes] [iPort iBytes])}
  [Port Bytes]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "serialWrite_i"
                      [Port Bytes]
                      *global*)]
    (new out-types ast)))

(s/fdef serialWrite_i
  :args (s/alt
         :ii (s/cat :Port valid-i? :Bytes valid-i? )
         :iS (s/cat :Port valid-i? :Bytes valid-S? )
         ))
(stest/instrument `serialWrite_i)

(defn outic14
  {:arglists '([ichn imsb ilsb ivalue imin imax])}
  [chn msb lsb value min max]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outic14"
                      [chn msb lsb value min max]
                      *global*)]
    (new out-types ast)))

(s/fdef outic14
  :args (s/cat :chn valid-i? :msb valid-i? :lsb valid-i? :value valid-i? :min valid-i? :max valid-i? ))
(stest/instrument `outic14)

(defn lphasor
  {:arglists '([xtrns & ilps* ilpe* imode* istrt* istor* istor* istor*])}
  [trns & [ lps* lpe* mode* strt* stor* stor* stor* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "lphasor"
                      [trns lps* lpe* mode* strt* stor* stor* stor*]
                      *global*)]
    (new out-types ast)))

(s/fdef lphasor
  :args (s/cat :trns valid-x? :lps* (s/? valid-i?*) :lpe* (s/? valid-i?*) :mode* (s/? valid-i?*) :strt* (s/? valid-i?*) :stor* (s/? valid-i?*) :stor* (s/? valid-i?*) :stor* (s/? valid-i?*) ))
(stest/instrument `lphasor)

(defn bformenc1
  {:arglists '([asig kalpha kbeta] [asig kalpha kbeta])}
  [sig alpha beta]
  (let [out-types-quoted 'AudioArray
        out-types AudioArray
        ast (ast-node out-types-quoted
                      "bformenc1"
                      [sig alpha beta]
                      *global*)]
    (new out-types ast)))

(s/fdef bformenc1
  :args (s/alt
         :akk (s/cat :sig valid-ar? :alpha valid-kr? :beta valid-kr? )
         ))
(stest/instrument `bformenc1)

(defn bformenc1:aArr
  {:arglists '([asig kalpha kbeta])}
  [sig alpha beta]
  (let [out-types-quoted 'AudioArray
        out-types AudioArray
        ast (ast-node out-types-quoted
                      "bformenc1"
                      [sig alpha beta]
                      *global*)]
    (new out-types ast)))

(s/fdef bformenc1:aArr
  :args (s/cat :sig valid-ar? :alpha valid-kr? :beta valid-kr? ))
(stest/instrument `bformenc1:aArr)

(defn bformenc1:a
  {:arglists '([asig kalpha kbeta])}
  [sig alpha beta]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "bformenc1"
                      [sig alpha beta]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef bformenc1:a
  :args (s/cat :sig valid-ar? :alpha valid-kr? :beta valid-kr? ))
(stest/instrument `bformenc1:a)

(defn pareq
  {:arglists '([asig kc kv kq & imode* iskip*])}
  [sig c v q & [ mode* skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "pareq"
                      [sig c v q mode* skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef pareq
  :args (s/cat :sig valid-ar? :c valid-kr? :v valid-kr? :q valid-kr? :mode* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `pareq)

(defn control
  {:arglists '([knum])}
  [num]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "control"
                      [num]
                      *global*)]
    (new out-types ast)))

(s/fdef control
  :args (s/cat :num valid-kr? ))
(stest/instrument `control)

(defn zdf_1pole
  {:arglists '([ain xcenter-frequency & kmode* istor*])}
  [in center-frequency & [ mode* stor* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "zdf_1pole"
                      [in center-frequency mode* stor*]
                      *global*)]
    (new out-types ast)))

(s/fdef zdf_1pole
  :args (s/cat :in valid-ar? :center-frequency valid-x? :mode* (s/? valid-kr?*) :stor* (s/? valid-i?*) ))
(stest/instrument `zdf_1pole)

(defn pvsbufread2
  {:arglists '([ktime khandle kft3 kft4])}
  [time handle ft3 ft4]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvsbufread2"
                      [time handle ft3 ft4]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsbufread2
  :args (s/cat :time valid-kr? :handle valid-kr? :ft3 valid-kr? :ft4 valid-kr? ))
(stest/instrument `pvsbufread2)

(defn genarray_i
  {:arglists '([istart iend & inc*])}
  [start end & [ nc* ]]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "genarray_i"
                      [start end nc*]
                      *global*)]
    (new out-types ast)))

(s/fdef genarray_i
  :args (s/cat :start valid-i? :end valid-i? :nc* (s/? valid-i?*) ))
(stest/instrument `genarray_i)

(defn zakinit
  {:arglists '([isizea isizek])}
  [sizea sizek]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "zakinit"
                      [sizea sizek]
                      *global*)]
    (new out-types ast)))

(s/fdef zakinit
  :args (s/cat :sizea valid-i? :sizek valid-i? ))
(stest/instrument `zakinit)

(defn ctrl7
  {:arglists '([ichan ictlno kmin kmax & itable* icutoff*] [ichan ictlno imin imax & itable*] [ichan ictlno kmin kmax & itable*])}
  [chan ctlno min max & [ table* cutoff* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "ctrl7"
                      [chan ctlno min max table* cutoff*]
                      *global*)]
    (new out-types ast)))

(s/fdef ctrl7
  :args (s/alt
         :iikki (s/cat :chan valid-i? :ctlno valid-i? :min valid-kr? :max valid-kr? :table* (s/? valid-i?*) )
         :iiiii (s/cat :chan valid-i? :ctlno valid-i? :min valid-i? :max valid-i? :table* (s/? valid-i?*) )
         :iikkii (s/cat :chan valid-i? :ctlno valid-i? :min valid-kr? :max valid-kr? :table* (s/? valid-i?*) :cutoff* (s/? valid-i?*) )
         ))
(stest/instrument `ctrl7)

(defn ctrl7:a
  {:arglists '([ichan ictlno kmin kmax & itable* icutoff*])}
  [chan ctlno min max & [ table* cutoff* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "ctrl7"
                      [chan ctlno min max table* cutoff*]
                      *global*)]
    (new out-types ast)))

(s/fdef ctrl7:a
  :args (s/cat :chan valid-i? :ctlno valid-i? :min valid-kr? :max valid-kr? :table* (s/? valid-i?*) :cutoff* (s/? valid-i?*) ))
(stest/instrument `ctrl7:a)

(defn ctrl7:i
  {:arglists '([ichan ictlno imin imax & itable*])}
  [chan ctlno min max & [ table* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "ctrl7"
                      [chan ctlno min max table*]
                      *global*)]
    (new out-types ast)))

(s/fdef ctrl7:i
  :args (s/cat :chan valid-i? :ctlno valid-i? :min valid-i? :max valid-i? :table* (s/? valid-i?*) ))
(stest/instrument `ctrl7:i)

(defn ctrl7:k
  {:arglists '([ichan ictlno kmin kmax & itable*])}
  [chan ctlno min max & [ table* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "ctrl7"
                      [chan ctlno min max table*]
                      *global*)]
    (new out-types ast)))

(s/fdef ctrl7:k
  :args (s/cat :chan valid-i? :ctlno valid-i? :min valid-kr? :max valid-kr? :table* (s/? valid-i?*) ))
(stest/instrument `ctrl7:k)

(defn vpow_i
  {:arglists '([itable ival ielements & idstoffset*])}
  [table val elements & [ dstoffset* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vpow_i"
                      [table val elements dstoffset*]
                      *global*)]
    (new out-types ast)))

(s/fdef vpow_i
  :args (s/cat :table valid-i? :val valid-i? :elements valid-i? :dstoffset* (s/? valid-i?*) ))
(stest/instrument `vpow_i)

(defn zdf_2pole_mode
  {:arglists '([ain xcenter-frequency xQ & istor*])}
  [in center-frequency Q & [ stor* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "zdf_2pole_mode"
                      [in center-frequency Q stor*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef zdf_2pole_mode
  :args (s/cat :in valid-ar? :center-frequency valid-x? :Q valid-x? :stor* (s/? valid-i?*) ))
(stest/instrument `zdf_2pole_mode)

(defn wgbowedbar
  {:arglists '([kamp kfreq kpos kbowpres kgain & iconst* itvel* ibowpos* ilow*])}
  [amp freq pos bowpres gain & [ const* tvel* bowpos* low* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "wgbowedbar"
                      [amp freq pos bowpres gain const* tvel* bowpos* low*]
                      *global*)]
    (new out-types ast)))

(s/fdef wgbowedbar
  :args (s/cat :amp valid-kr? :freq valid-kr? :pos valid-kr? :bowpres valid-kr? :gain valid-kr? :const* (s/? valid-i?*) :tvel* (s/? valid-i?*) :bowpos* (s/? valid-i?*) :low* (s/? valid-i?*) ))
(stest/instrument `wgbowedbar)

(defn pvslock
  {:arglists '([fsigin klock])}
  [sigin lock]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvslock"
                      [sigin lock]
                      *global*)]
    (new out-types ast)))

(s/fdef pvslock
  :args (s/cat :sigin valid-f? :lock valid-kr? ))
(stest/instrument `pvslock)

(defn hrtfmove
  {:arglists '([asrc kAz kElev Sfilel Sfiler & imode* ifade* isr*])}
  [src Az Elev filel filer & [ mode* fade* sr* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "hrtfmove"
                      [src Az Elev filel filer mode* fade* sr*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef hrtfmove
  :args (s/cat :src valid-ar? :Az valid-kr? :Elev valid-kr? :filel valid-S? :filer valid-S? :mode* (s/? valid-i?*) :fade* (s/? valid-i?*) :sr* (s/? valid-i?*) ))
(stest/instrument `hrtfmove)

(defn dssiaudio
  {:arglists '([ihandle & xin1* xin2* xin3* xin4* xin5* xin6* xin7* xin8* xin9* xin10* xin11* xin12* xin13* xin14* xin15* xin16*])}
  [handle & [ in1* in2* in3* in4* in5* in6* in7* in8* in9* in10* in11* in12* in13* in14* in15* in16* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "dssiaudio"
                      [handle in1* in2* in3* in4* in5* in6* in7* in8* in9* in10* in11* in12* in13* in14* in15* in16*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef dssiaudio
  :args (s/cat :handle valid-i? :in1* (s/? valid-x?*) :in2* (s/? valid-x?*) :in3* (s/? valid-x?*) :in4* (s/? valid-x?*) :in5* (s/? valid-x?*) :in6* (s/? valid-x?*) :in7* (s/? valid-x?*) :in8* (s/? valid-x?*) :in9* (s/? valid-x?*) :in10* (s/? valid-x?*) :in11* (s/? valid-x?*) :in12* (s/? valid-x?*) :in13* (s/? valid-x?*) :in14* (s/? valid-x?*) :in15* (s/? valid-x?*) :in16* (s/? valid-x?*) ))
(stest/instrument `dssiaudio)

(defn vtable1k
  {:arglists '([ktable & kout1* kout2* kout3* koutN4* koutN5* koutN6* koutN7* koutN8* koutN9* koutN10* koutN11* koutN12* koutN13* koutN14* koutN15* koutN16*])}
  [table & [ out1* out2* out3* outN4* outN5* outN6* outN7* outN8* outN9* outN10* outN11* outN12* outN13* outN14* outN15* outN16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vtable1k"
                      [table out1* out2* out3* outN4* outN5* outN6* outN7* outN8* outN9* outN10* outN11* outN12* outN13* outN14* outN15* outN16*]
                      *global*)]
    (new out-types ast)))

(s/fdef vtable1k
  :args (s/cat :table valid-kr? :out1* (s/? valid-kr?*) :out2* (s/? valid-kr?*) :out3* (s/? valid-kr?*) :outN4* (s/? valid-kr?*) :outN5* (s/? valid-kr?*) :outN6* (s/? valid-kr?*) :outN7* (s/? valid-kr?*) :outN8* (s/? valid-kr?*) :outN9* (s/? valid-kr?*) :outN10* (s/? valid-kr?*) :outN11* (s/? valid-kr?*) :outN12* (s/? valid-kr?*) :outN13* (s/? valid-kr?*) :outN14* (s/? valid-kr?*) :outN15* (s/? valid-kr?*) :outN16* (s/? valid-kr?*) ))
(stest/instrument `vtable1k)

(defn butlp
  {:arglists '([asig afreq & iskip*] [asig kfreq & iskip*])}
  [sig freq & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "butlp"
                      [sig freq skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef butlp
  :args (s/alt
         :aki (s/cat :sig valid-ar? :freq valid-kr? :skip* (s/? valid-i?*) )
         :aai (s/cat :sig valid-ar? :freq valid-ar? :skip* (s/? valid-i?*) )
         ))
(stest/instrument `butlp)

(defn fouti
  {:arglists '([ihandle iformat iflag & iout1* iout2* iout3* ioutN4* ioutN5* ioutN6* ioutN7* ioutN8* ioutN9* ioutN10* ioutN11* ioutN12* ioutN13* ioutN14* ioutN15* ioutN16*])}
  [handle format flag & [ out1* out2* out3* outN4* outN5* outN6* outN7* outN8* outN9* outN10* outN11* outN12* outN13* outN14* outN15* outN16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "fouti"
                      [handle format flag out1* out2* out3* outN4* outN5* outN6* outN7* outN8* outN9* outN10* outN11* outN12* outN13* outN14* outN15* outN16*]
                      *global*)]
    (new out-types ast)))

(s/fdef fouti
  :args (s/cat :handle valid-i? :format valid-i? :flag valid-i? :out1* (s/? valid-i?*) :out2* (s/? valid-i?*) :out3* (s/? valid-i?*) :outN4* (s/? valid-i?*) :outN5* (s/? valid-i?*) :outN6* (s/? valid-i?*) :outN7* (s/? valid-i?*) :outN8* (s/? valid-i?*) :outN9* (s/? valid-i?*) :outN10* (s/? valid-i?*) :outN11* (s/? valid-i?*) :outN12* (s/? valid-i?*) :outN13* (s/? valid-i?*) :outN14* (s/? valid-i?*) :outN15* (s/? valid-i?*) :outN16* (s/? valid-i?*) ))
(stest/instrument `fouti)

(defn lowresx
  {:arglists '([asig xcutoff xresonance & inumlayer* iskip*])}
  [sig cutoff resonance & [ numlayer* skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "lowresx"
                      [sig cutoff resonance numlayer* skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef lowresx
  :args (s/cat :sig valid-ar? :cutoff valid-x? :resonance valid-x? :numlayer* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `lowresx)

(defn fprints
  {:arglists '([Sfilename Sstring & xval1* xval2* xval3* xval4* xval5* xval6* xval7* xval8* xval9* xval10* xval11* xval12* xval13* xval14* xval15* xval16*] [ifilename Sstring & xval1* xval2* xval3* xval4* xval5* xval6* xval7* xval8* xval9* xval10* xval11* xval12* xval13* xval14* xval15* xval16*])}
  [filename string & [ val1* val2* val3* val4* val5* val6* val7* val8* val9* val10* val11* val12* val13* val14* val15* val16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "fprints"
                      [filename string val1* val2* val3* val4* val5* val6* val7* val8* val9* val10* val11* val12* val13* val14* val15* val16*]
                      *global*)]
    (new out-types ast)))

(s/fdef fprints
  :args (s/alt
         :iSxxxxxxxxxxxxxxxx (s/cat :filename valid-i? :string valid-S? :val1* (s/? valid-x?*) :val2* (s/? valid-x?*) :val3* (s/? valid-x?*) :val4* (s/? valid-x?*) :val5* (s/? valid-x?*) :val6* (s/? valid-x?*) :val7* (s/? valid-x?*) :val8* (s/? valid-x?*) :val9* (s/? valid-x?*) :val10* (s/? valid-x?*) :val11* (s/? valid-x?*) :val12* (s/? valid-x?*) :val13* (s/? valid-x?*) :val14* (s/? valid-x?*) :val15* (s/? valid-x?*) :val16* (s/? valid-x?*) )
         :SSxxxxxxxxxxxxxxxx (s/cat :filename valid-S? :string valid-S? :val1* (s/? valid-x?*) :val2* (s/? valid-x?*) :val3* (s/? valid-x?*) :val4* (s/? valid-x?*) :val5* (s/? valid-x?*) :val6* (s/? valid-x?*) :val7* (s/? valid-x?*) :val8* (s/? valid-x?*) :val9* (s/? valid-x?*) :val10* (s/? valid-x?*) :val11* (s/? valid-x?*) :val12* (s/? valid-x?*) :val13* (s/? valid-x?*) :val14* (s/? valid-x?*) :val15* (s/? valid-x?*) :val16* (s/? valid-x?*) )
         ))
(stest/instrument `fprints)

(defn port
  {:arglists '([ksig ihtim & isig*])}
  [sig htim & [ sig* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "port"
                      [sig htim sig*]
                      *global*)]
    (new out-types ast)))

(s/fdef port
  :args (s/cat :sig valid-kr? :htim valid-i? :sig* (s/? valid-i?*) ))
(stest/instrument `port)

(defn nstance
  {:arglists '([Sinsname iwhen idur & ip1* ip2* ip3* ip4* ip5* ip6* ip7* ip8* ip9* ip10* ip11* ip12* ip13* ip14* ip15* ip16*] [iinsname iwhen idur & ip1* ip2* ip3* ip4* ip5* ip6* ip7* ip8* ip9* ip10* ip11* ip12* ip13* ip14* ip15* ip16*] [Sinsname Swhen & kdur1* kp2* kp3* kp4* kp5* kp6* kp7* kp8* kp9* kp10* kp11* kp12* kp13* kp14* kp15* kp16*] [kinsname kwhen & kdur1* kp2* kp3* kp4* kp5* kp6* kp7* kp8* kp9* kp10* kp11* kp12* kp13* kp14* kp15* kp16*])}
  [insname when dur & [ p1* p2* p3* p4* p5* p6* p7* p8* p9* p10* p11* p12* p13* p14* p15* p16* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "nstance"
                      [insname when dur p1* p2* p3* p4* p5* p6* p7* p8* p9* p10* p11* p12* p13* p14* p15* p16*]
                      *global*)]
    (new out-types ast)))

(s/fdef nstance
  :args (s/alt
         :kkkkkkkkkkkkkkkkkk (s/cat :insname valid-kr? :when valid-kr? :dur1* (s/? valid-kr?*) :p2* (s/? valid-kr?*) :p3* (s/? valid-kr?*) :p4* (s/? valid-kr?*) :p5* (s/? valid-kr?*) :p6* (s/? valid-kr?*) :p7* (s/? valid-kr?*) :p8* (s/? valid-kr?*) :p9* (s/? valid-kr?*) :p10* (s/? valid-kr?*) :p11* (s/? valid-kr?*) :p12* (s/? valid-kr?*) :p13* (s/? valid-kr?*) :p14* (s/? valid-kr?*) :p15* (s/? valid-kr?*) :p16* (s/? valid-kr?*) )
         :SSkkkkkkkkkkkkkkkk (s/cat :insname valid-S? :when valid-S? :dur1* (s/? valid-kr?*) :p2* (s/? valid-kr?*) :p3* (s/? valid-kr?*) :p4* (s/? valid-kr?*) :p5* (s/? valid-kr?*) :p6* (s/? valid-kr?*) :p7* (s/? valid-kr?*) :p8* (s/? valid-kr?*) :p9* (s/? valid-kr?*) :p10* (s/? valid-kr?*) :p11* (s/? valid-kr?*) :p12* (s/? valid-kr?*) :p13* (s/? valid-kr?*) :p14* (s/? valid-kr?*) :p15* (s/? valid-kr?*) :p16* (s/? valid-kr?*) )
         :iiiiiiiiiiiiiiiiiii (s/cat :insname valid-i? :when valid-i? :dur valid-i? :p1* (s/? valid-i?*) :p2* (s/? valid-i?*) :p3* (s/? valid-i?*) :p4* (s/? valid-i?*) :p5* (s/? valid-i?*) :p6* (s/? valid-i?*) :p7* (s/? valid-i?*) :p8* (s/? valid-i?*) :p9* (s/? valid-i?*) :p10* (s/? valid-i?*) :p11* (s/? valid-i?*) :p12* (s/? valid-i?*) :p13* (s/? valid-i?*) :p14* (s/? valid-i?*) :p15* (s/? valid-i?*) :p16* (s/? valid-i?*) )
         :Siiiiiiiiiiiiiiiiii (s/cat :insname valid-S? :when valid-i? :dur valid-i? :p1* (s/? valid-i?*) :p2* (s/? valid-i?*) :p3* (s/? valid-i?*) :p4* (s/? valid-i?*) :p5* (s/? valid-i?*) :p6* (s/? valid-i?*) :p7* (s/? valid-i?*) :p8* (s/? valid-i?*) :p9* (s/? valid-i?*) :p10* (s/? valid-i?*) :p11* (s/? valid-i?*) :p12* (s/? valid-i?*) :p13* (s/? valid-i?*) :p14* (s/? valid-i?*) :p15* (s/? valid-i?*) :p16* (s/? valid-i?*) )
         ))
(stest/instrument `nstance)

(defn nstance:i
  {:arglists '([Sinsname iwhen idur & ip1* ip2* ip3* ip4* ip5* ip6* ip7* ip8* ip9* ip10* ip11* ip12* ip13* ip14* ip15* ip16*] [iinsname iwhen idur & ip1* ip2* ip3* ip4* ip5* ip6* ip7* ip8* ip9* ip10* ip11* ip12* ip13* ip14* ip15* ip16*])}
  [insname when dur & [ p1* p2* p3* p4* p5* p6* p7* p8* p9* p10* p11* p12* p13* p14* p15* p16* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "nstance"
                      [insname when dur p1* p2* p3* p4* p5* p6* p7* p8* p9* p10* p11* p12* p13* p14* p15* p16*]
                      *global*)]
    (new out-types ast)))

(s/fdef nstance:i
  :args (s/alt
         :iiiiiiiiiiiiiiiiiii (s/cat :insname valid-i? :when valid-i? :dur valid-i? :p1* (s/? valid-i?*) :p2* (s/? valid-i?*) :p3* (s/? valid-i?*) :p4* (s/? valid-i?*) :p5* (s/? valid-i?*) :p6* (s/? valid-i?*) :p7* (s/? valid-i?*) :p8* (s/? valid-i?*) :p9* (s/? valid-i?*) :p10* (s/? valid-i?*) :p11* (s/? valid-i?*) :p12* (s/? valid-i?*) :p13* (s/? valid-i?*) :p14* (s/? valid-i?*) :p15* (s/? valid-i?*) :p16* (s/? valid-i?*) )
         :Siiiiiiiiiiiiiiiiii (s/cat :insname valid-S? :when valid-i? :dur valid-i? :p1* (s/? valid-i?*) :p2* (s/? valid-i?*) :p3* (s/? valid-i?*) :p4* (s/? valid-i?*) :p5* (s/? valid-i?*) :p6* (s/? valid-i?*) :p7* (s/? valid-i?*) :p8* (s/? valid-i?*) :p9* (s/? valid-i?*) :p10* (s/? valid-i?*) :p11* (s/? valid-i?*) :p12* (s/? valid-i?*) :p13* (s/? valid-i?*) :p14* (s/? valid-i?*) :p15* (s/? valid-i?*) :p16* (s/? valid-i?*) )
         ))
(stest/instrument `nstance:i)

(defn nstance:k
  {:arglists '([Sinsname Swhen & kdur1* kp2* kp3* kp4* kp5* kp6* kp7* kp8* kp9* kp10* kp11* kp12* kp13* kp14* kp15* kp16*] [kinsname kwhen & kdur1* kp2* kp3* kp4* kp5* kp6* kp7* kp8* kp9* kp10* kp11* kp12* kp13* kp14* kp15* kp16*])}
  [insname when & [ dur1* p2* p3* p4* p5* p6* p7* p8* p9* p10* p11* p12* p13* p14* p15* p16* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "nstance"
                      [insname when dur1* p2* p3* p4* p5* p6* p7* p8* p9* p10* p11* p12* p13* p14* p15* p16*]
                      *global*)]
    (new out-types ast)))

(s/fdef nstance:k
  :args (s/alt
         :kkkkkkkkkkkkkkkkkk (s/cat :insname valid-kr? :when valid-kr? :dur1* (s/? valid-kr?*) :p2* (s/? valid-kr?*) :p3* (s/? valid-kr?*) :p4* (s/? valid-kr?*) :p5* (s/? valid-kr?*) :p6* (s/? valid-kr?*) :p7* (s/? valid-kr?*) :p8* (s/? valid-kr?*) :p9* (s/? valid-kr?*) :p10* (s/? valid-kr?*) :p11* (s/? valid-kr?*) :p12* (s/? valid-kr?*) :p13* (s/? valid-kr?*) :p14* (s/? valid-kr?*) :p15* (s/? valid-kr?*) :p16* (s/? valid-kr?*) )
         :SSkkkkkkkkkkkkkkkk (s/cat :insname valid-S? :when valid-S? :dur1* (s/? valid-kr?*) :p2* (s/? valid-kr?*) :p3* (s/? valid-kr?*) :p4* (s/? valid-kr?*) :p5* (s/? valid-kr?*) :p6* (s/? valid-kr?*) :p7* (s/? valid-kr?*) :p8* (s/? valid-kr?*) :p9* (s/? valid-kr?*) :p10* (s/? valid-kr?*) :p11* (s/? valid-kr?*) :p12* (s/? valid-kr?*) :p13* (s/? valid-kr?*) :p14* (s/? valid-kr?*) :p15* (s/? valid-kr?*) :p16* (s/? valid-kr?*) )
         ))
(stest/instrument `nstance:k)

(defn tablegpw
  {:arglists '([ktable])}
  [table]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "tablegpw"
                      [table]
                      *global*)]
    (new out-types ast)))

(s/fdef tablegpw
  :args (s/cat :table valid-kr? ))
(stest/instrument `tablegpw)

(defn ampmidid
  {:arglists '([ivelocity idecibels & idecibels*] [kvelocity idecibels & idecibels*])}
  [velocity decibels & [ decibels* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "ampmidid"
                      [velocity decibels decibels*]
                      *global*)]
    (new out-types ast)))

(s/fdef ampmidid
  :args (s/alt
         :kii (s/cat :velocity valid-kr? :decibels valid-i? :decibels* (s/? valid-i?*) )
         :iii (s/cat :velocity valid-i? :decibels valid-i? :decibels* (s/? valid-i?*) )
         ))
(stest/instrument `ampmidid)

(defn ampmidid:i
  {:arglists '([ivelocity idecibels & idecibels*])}
  [velocity decibels & [ decibels* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "ampmidid"
                      [velocity decibels decibels*]
                      *global*)]
    (new out-types ast)))

(s/fdef ampmidid:i
  :args (s/cat :velocity valid-i? :decibels valid-i? :decibels* (s/? valid-i?*) ))
(stest/instrument `ampmidid:i)

(defn ampmidid:k
  {:arglists '([kvelocity idecibels & idecibels*])}
  [velocity decibels & [ decibels* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "ampmidid"
                      [velocity decibels decibels*]
                      *global*)]
    (new out-types ast)))

(s/fdef ampmidid:k
  :args (s/cat :velocity valid-kr? :decibels valid-i? :decibels* (s/? valid-i?*) ))
(stest/instrument `ampmidid:k)

(defn tan
  {:arglists '([aarg1] [iarg1] [iarg1Arr] [karg1] [karg1Arr])}
  [arg1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "tan"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef tan
  :args (s/alt
         :kArr (s/cat :arg1 valid-kArr? )
         :k (s/cat :arg1 valid-kr? )
         :iArr (s/cat :arg1 valid-iArr? )
         :i (s/cat :arg1 valid-i? )
         :a (s/cat :arg1 valid-ar? )
         ))
(stest/instrument `tan)

(defn tan:a
  {:arglists '([aarg1])}
  [arg1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "tan"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef tan:a
  :args (s/cat :arg1 valid-ar? ))
(stest/instrument `tan:a)

(defn tan:i
  {:arglists '([iarg1])}
  [arg1]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "tan"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef tan:i
  :args (s/cat :arg1 valid-i? ))
(stest/instrument `tan:i)

(defn tan:iArr
  {:arglists '([iarg1Arr])}
  [arg1]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "tan"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef tan:iArr
  :args (s/cat :arg1 valid-iArr? ))
(stest/instrument `tan:iArr)

(defn tan:k
  {:arglists '([karg1])}
  [arg1]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "tan"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef tan:k
  :args (s/cat :arg1 valid-kr? ))
(stest/instrument `tan:k)

(defn tan:kArr
  {:arglists '([karg1Arr])}
  [arg1]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "tan"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef tan:kArr
  :args (s/cat :arg1 valid-kArr? ))
(stest/instrument `tan:kArr)

(defn denorm
  {:arglists '([& aarg1* aarg2* aarg3* aarg4* aarg5* aarg6* aarg7* aarg8* aarg9* aarg10* aarg11* aarg12* aarg13* aarg14* aarg15* aarg16* aarg17* aarg18* aarg19* aarg20* aarg21* aarg22* aarg23* aarg24* aarg25* aarg26* aarg27* aarg28* aarg29* aarg30* aarg31* aarg32*])}
  [& [ arg1* arg2* arg3* arg4* arg5* arg6* arg7* arg8* arg9* arg10* arg11* arg12* arg13* arg14* arg15* arg16* arg17* arg18* arg19* arg20* arg21* arg22* arg23* arg24* arg25* arg26* arg27* arg28* arg29* arg30* arg31* arg32* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "denorm"
                      [arg1* arg2* arg3* arg4* arg5* arg6* arg7* arg8* arg9* arg10* arg11* arg12* arg13* arg14* arg15* arg16* arg17* arg18* arg19* arg20* arg21* arg22* arg23* arg24* arg25* arg26* arg27* arg28* arg29* arg30* arg31* arg32*]
                      *global*)]
    (new out-types ast)))

(s/fdef denorm
  :args (s/cat :arg1* (s/? valid-ar?*) :arg2* (s/? valid-ar?*) :arg3* (s/? valid-ar?*) :arg4* (s/? valid-ar?*) :arg5* (s/? valid-ar?*) :arg6* (s/? valid-ar?*) :arg7* (s/? valid-ar?*) :arg8* (s/? valid-ar?*) :arg9* (s/? valid-ar?*) :arg10* (s/? valid-ar?*) :arg11* (s/? valid-ar?*) :arg12* (s/? valid-ar?*) :arg13* (s/? valid-ar?*) :arg14* (s/? valid-ar?*) :arg15* (s/? valid-ar?*) :arg16* (s/? valid-ar?*) :arg17* (s/? valid-ar?*) :arg18* (s/? valid-ar?*) :arg19* (s/? valid-ar?*) :arg20* (s/? valid-ar?*) :arg21* (s/? valid-ar?*) :arg22* (s/? valid-ar?*) :arg23* (s/? valid-ar?*) :arg24* (s/? valid-ar?*) :arg25* (s/? valid-ar?*) :arg26* (s/? valid-ar?*) :arg27* (s/? valid-ar?*) :arg28* (s/? valid-ar?*) :arg29* (s/? valid-ar?*) :arg30* (s/? valid-ar?*) :arg31* (s/? valid-ar?*) :arg32* (s/? valid-ar?*) ))
(stest/instrument `denorm)

(defn cos
  {:arglists '([aarg1] [iarg1] [iarg1Arr] [karg1] [karg1Arr])}
  [arg1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "cos"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef cos
  :args (s/alt
         :kArr (s/cat :arg1 valid-kArr? )
         :k (s/cat :arg1 valid-kr? )
         :iArr (s/cat :arg1 valid-iArr? )
         :i (s/cat :arg1 valid-i? )
         :a (s/cat :arg1 valid-ar? )
         ))
(stest/instrument `cos)

(defn cos:a
  {:arglists '([aarg1])}
  [arg1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "cos"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef cos:a
  :args (s/cat :arg1 valid-ar? ))
(stest/instrument `cos:a)

(defn cos:i
  {:arglists '([iarg1])}
  [arg1]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "cos"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef cos:i
  :args (s/cat :arg1 valid-i? ))
(stest/instrument `cos:i)

(defn cos:iArr
  {:arglists '([iarg1Arr])}
  [arg1]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "cos"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef cos:iArr
  :args (s/cat :arg1 valid-iArr? ))
(stest/instrument `cos:iArr)

(defn cos:k
  {:arglists '([karg1])}
  [arg1]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "cos"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef cos:k
  :args (s/cat :arg1 valid-kr? ))
(stest/instrument `cos:k)

(defn cos:kArr
  {:arglists '([karg1Arr])}
  [arg1]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "cos"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef cos:kArr
  :args (s/cat :arg1 valid-kArr? ))
(stest/instrument `cos:kArr)

(defn outo
  {:arglists '([& asig1* asig2* asig3* asig4* asig5* asig6* asig7* asig8* asig9* asig10* asig11* asig12* asig13* asig14* asig15* asig16* asig17* asig18* asig19* asig20* asig21* asig22* asig23* asig24* asig25* asig26* asig27* asig28* asig29* asig30* asig31* asig32*])}
  [& [ sig1* sig2* sig3* sig4* sig5* sig6* sig7* sig8* sig9* sig10* sig11* sig12* sig13* sig14* sig15* sig16* sig17* sig18* sig19* sig20* sig21* sig22* sig23* sig24* sig25* sig26* sig27* sig28* sig29* sig30* sig31* sig32* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outo"
                      [sig1* sig2* sig3* sig4* sig5* sig6* sig7* sig8* sig9* sig10* sig11* sig12* sig13* sig14* sig15* sig16* sig17* sig18* sig19* sig20* sig21* sig22* sig23* sig24* sig25* sig26* sig27* sig28* sig29* sig30* sig31* sig32*]
                      *global*)]
    (new out-types ast)))

(s/fdef outo
  :args (s/cat :sig1* (s/? valid-ar?*) :sig2* (s/? valid-ar?*) :sig3* (s/? valid-ar?*) :sig4* (s/? valid-ar?*) :sig5* (s/? valid-ar?*) :sig6* (s/? valid-ar?*) :sig7* (s/? valid-ar?*) :sig8* (s/? valid-ar?*) :sig9* (s/? valid-ar?*) :sig10* (s/? valid-ar?*) :sig11* (s/? valid-ar?*) :sig12* (s/? valid-ar?*) :sig13* (s/? valid-ar?*) :sig14* (s/? valid-ar?*) :sig15* (s/? valid-ar?*) :sig16* (s/? valid-ar?*) :sig17* (s/? valid-ar?*) :sig18* (s/? valid-ar?*) :sig19* (s/? valid-ar?*) :sig20* (s/? valid-ar?*) :sig21* (s/? valid-ar?*) :sig22* (s/? valid-ar?*) :sig23* (s/? valid-ar?*) :sig24* (s/? valid-ar?*) :sig25* (s/? valid-ar?*) :sig26* (s/? valid-ar?*) :sig27* (s/? valid-ar?*) :sig28* (s/? valid-ar?*) :sig29* (s/? valid-ar?*) :sig30* (s/? valid-ar?*) :sig31* (s/? valid-ar?*) :sig32* (s/? valid-ar?*) ))
(stest/instrument `outo)

(defn dumpk4
  {:arglists '([ksig1 ksig2 ksig3 ksig4 Sfilname iformat iprd] [ksig1 ksig2 ksig3 ksig4 ifilname iformat iprd])}
  [sig1 sig2 sig3 sig4 filname format prd]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "dumpk4"
                      [sig1 sig2 sig3 sig4 filname format prd]
                      *global*)]
    (new out-types ast)))

(s/fdef dumpk4
  :args (s/alt
         :kkkkiii (s/cat :sig1 valid-kr? :sig2 valid-kr? :sig3 valid-kr? :sig4 valid-kr? :filname valid-i? :format valid-i? :prd valid-i? )
         :kkkkSii (s/cat :sig1 valid-kr? :sig2 valid-kr? :sig3 valid-kr? :sig4 valid-kr? :filname valid-S? :format valid-i? :prd valid-i? )
         ))
(stest/instrument `dumpk4)

(defn midifilestatus
  {:arglists '()}
  []
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "midifilestatus"
                      []
                      *global*)]
    (new out-types ast)))


(defn syncphasor
  {:arglists '([xcps asyncin & iphase*])}
  [cps syncin & [ phase* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "syncphasor"
                      [cps syncin phase*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef syncphasor
  :args (s/cat :cps valid-x? :syncin valid-ar? :phase* (s/? valid-i?*) ))
(stest/instrument `syncphasor)

(defn vtabwk
  {:arglists '([kindex itable & kinarg1* kinarg2* kinarg3* kinargN4* kinargN5* kinargN6* kinargN7* kinargN8* kinargN9* kinargN10* kinargN11* kinargN12* kinargN13* kinargN14* kinargN15* kinargN16*])}
  [index table & [ inarg1* inarg2* inarg3* inargN4* inargN5* inargN6* inargN7* inargN8* inargN9* inargN10* inargN11* inargN12* inargN13* inargN14* inargN15* inargN16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vtabwk"
                      [index table inarg1* inarg2* inarg3* inargN4* inargN5* inargN6* inargN7* inargN8* inargN9* inargN10* inargN11* inargN12* inargN13* inargN14* inargN15* inargN16*]
                      *global*)]
    (new out-types ast)))

(s/fdef vtabwk
  :args (s/cat :index valid-kr? :table valid-i? :inarg1* (s/? valid-kr?*) :inarg2* (s/? valid-kr?*) :inarg3* (s/? valid-kr?*) :inargN4* (s/? valid-kr?*) :inargN5* (s/? valid-kr?*) :inargN6* (s/? valid-kr?*) :inargN7* (s/? valid-kr?*) :inargN8* (s/? valid-kr?*) :inargN9* (s/? valid-kr?*) :inargN10* (s/? valid-kr?*) :inargN11* (s/? valid-kr?*) :inargN12* (s/? valid-kr?*) :inargN13* (s/? valid-kr?*) :inargN14* (s/? valid-kr?*) :inargN15* (s/? valid-kr?*) :inargN16* (s/? valid-kr?*) ))
(stest/instrument `vtabwk)

(defn midic21
  {:arglists '([ictlno1 ictlno2 ictlno3 imin imax & itable*] [ictlno1 ictlno2 ictlno3 kmin kmax & itable*])}
  [ctlno1 ctlno2 ctlno3 min max & [ table* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "midic21"
                      [ctlno1 ctlno2 ctlno3 min max table*]
                      *global*)]
    (new out-types ast)))

(s/fdef midic21
  :args (s/alt
         :iiikki (s/cat :ctlno1 valid-i? :ctlno2 valid-i? :ctlno3 valid-i? :min valid-kr? :max valid-kr? :table* (s/? valid-i?*) )
         :iiiiii (s/cat :ctlno1 valid-i? :ctlno2 valid-i? :ctlno3 valid-i? :min valid-i? :max valid-i? :table* (s/? valid-i?*) )
         ))
(stest/instrument `midic21)

(defn midic21:i
  {:arglists '([ictlno1 ictlno2 ictlno3 imin imax & itable*])}
  [ctlno1 ctlno2 ctlno3 min max & [ table* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "midic21"
                      [ctlno1 ctlno2 ctlno3 min max table*]
                      *global*)]
    (new out-types ast)))

(s/fdef midic21:i
  :args (s/cat :ctlno1 valid-i? :ctlno2 valid-i? :ctlno3 valid-i? :min valid-i? :max valid-i? :table* (s/? valid-i?*) ))
(stest/instrument `midic21:i)

(defn midic21:k
  {:arglists '([ictlno1 ictlno2 ictlno3 kmin kmax & itable*])}
  [ctlno1 ctlno2 ctlno3 min max & [ table* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "midic21"
                      [ctlno1 ctlno2 ctlno3 min max table*]
                      *global*)]
    (new out-types ast)))

(s/fdef midic21:k
  :args (s/cat :ctlno1 valid-i? :ctlno2 valid-i? :ctlno3 valid-i? :min valid-kr? :max valid-kr? :table* (s/? valid-i?*) ))
(stest/instrument `midic21:k)

(defn mandel
  {:arglists '([ktrig kx ky kmaxIter])}
  [trig x y maxIter]
  (let [out-types-quoted '[ControlSignal ControlSignal]
        out-types [ControlSignal ControlSignal]
        ast (ast-node out-types-quoted
                      "mandel"
                      [trig x y maxIter]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef mandel
  :args (s/cat :trig valid-kr? :x valid-kr? :y valid-kr? :maxIter valid-kr? ))
(stest/instrument `mandel)

(defn filebit
  {:arglists '([Sfilcod & iallowraw*] [ifilcod & iallowraw*])}
  [filcod & [ allowraw* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "filebit"
                      [filcod allowraw*]
                      *global*)]
    (new out-types ast)))

(s/fdef filebit
  :args (s/alt
         :ii (s/cat :filcod valid-i? :allowraw* (s/? valid-i?*) )
         :Si (s/cat :filcod valid-S? :allowraw* (s/? valid-i?*) )
         ))
(stest/instrument `filebit)

(defn chn_k
  {:arglists '([Sname imode & itype* idflt* imin* ima* ix* iy* iwidth* iheight* xattribute1* xattribute2* xattribute3* xattribute4* xattribute5* xattribute6* xattribute7* xattribute8* xattribute9* xattribute10* xattribute11* xattribute12* xattribute13* xattribute14* xattribute15* xattribute16*])}
  [name mode & [ type* dflt* min* ma* x* y* width* height* attribute1* attribute2* attribute3* attribute4* attribute5* attribute6* attribute7* attribute8* attribute9* attribute10* attribute11* attribute12* attribute13* attribute14* attribute15* attribute16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "chn_k"
                      [name mode type* dflt* min* ma* x* y* width* height* attribute1* attribute2* attribute3* attribute4* attribute5* attribute6* attribute7* attribute8* attribute9* attribute10* attribute11* attribute12* attribute13* attribute14* attribute15* attribute16*]
                      *global*)]
    (new out-types ast)))

(s/fdef chn_k
  :args (s/cat :name valid-S? :mode valid-i? :type* (s/? valid-i?*) :dflt* (s/? valid-i?*) :min* (s/? valid-i?*) :ma* (s/? valid-i?*) :x* (s/? valid-i?*) :y* (s/? valid-i?*) :width* (s/? valid-i?*) :height* (s/? valid-i?*) :attribute1* (s/? valid-x?*) :attribute2* (s/? valid-x?*) :attribute3* (s/? valid-x?*) :attribute4* (s/? valid-x?*) :attribute5* (s/? valid-x?*) :attribute6* (s/? valid-x?*) :attribute7* (s/? valid-x?*) :attribute8* (s/? valid-x?*) :attribute9* (s/? valid-x?*) :attribute10* (s/? valid-x?*) :attribute11* (s/? valid-x?*) :attribute12* (s/? valid-x?*) :attribute13* (s/? valid-x?*) :attribute14* (s/? valid-x?*) :attribute15* (s/? valid-x?*) :attribute16* (s/? valid-x?*) ))
(stest/instrument `chn_k)

(defn powershape
  {:arglists '([ain kShapeAmount & ifullscale*])}
  [in ShapeAmount & [ fullscale* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "powershape"
                      [in ShapeAmount fullscale*]
                      *global*)]
    (new out-types ast)))

(s/fdef powershape
  :args (s/cat :in valid-ar? :ShapeAmount valid-kr? :fullscale* (s/? valid-i?*) ))
(stest/instrument `powershape)

(defn vtabwi
  {:arglists '([iindex itable & inarg1* inarg2* inarg3* inargN4* inargN5* inargN6* inargN7* inargN8* inargN9* inargN10* inargN11* inargN12* inargN13* inargN14* inargN15* inargN16*])}
  [index table & [ narg1* narg2* narg3* nargN4* nargN5* nargN6* nargN7* nargN8* nargN9* nargN10* nargN11* nargN12* nargN13* nargN14* nargN15* nargN16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vtabwi"
                      [index table narg1* narg2* narg3* nargN4* nargN5* nargN6* nargN7* nargN8* nargN9* nargN10* nargN11* nargN12* nargN13* nargN14* nargN15* nargN16*]
                      *global*)]
    (new out-types ast)))

(s/fdef vtabwi
  :args (s/cat :index valid-i? :table valid-i? :narg1* (s/? valid-i?*) :narg2* (s/? valid-i?*) :narg3* (s/? valid-i?*) :nargN4* (s/? valid-i?*) :nargN5* (s/? valid-i?*) :nargN6* (s/? valid-i?*) :nargN7* (s/? valid-i?*) :nargN8* (s/? valid-i?*) :nargN9* (s/? valid-i?*) :nargN10* (s/? valid-i?*) :nargN11* (s/? valid-i?*) :nargN12* (s/? valid-i?*) :nargN13* (s/? valid-i?*) :nargN14* (s/? valid-i?*) :nargN15* (s/? valid-i?*) :nargN16* (s/? valid-i?*) ))
(stest/instrument `vtabwi)

(defn mirror
  {:arglists '([asig klow khigh] [isig ilow ihigh] [ksig klow khigh])}
  [sig low high]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "mirror"
                      [sig low high]
                      *global*)]
    (new out-types ast)))

(s/fdef mirror
  :args (s/alt
         :kkk (s/cat :sig valid-kr? :low valid-kr? :high valid-kr? )
         :iii (s/cat :sig valid-i? :low valid-i? :high valid-i? )
         :akk (s/cat :sig valid-ar? :low valid-kr? :high valid-kr? )
         ))
(stest/instrument `mirror)

(defn mirror:a
  {:arglists '([asig klow khigh])}
  [sig low high]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "mirror"
                      [sig low high]
                      *global*)]
    (new out-types ast)))

(s/fdef mirror:a
  :args (s/cat :sig valid-ar? :low valid-kr? :high valid-kr? ))
(stest/instrument `mirror:a)

(defn mirror:i
  {:arglists '([isig ilow ihigh])}
  [sig low high]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "mirror"
                      [sig low high]
                      *global*)]
    (new out-types ast)))

(s/fdef mirror:i
  :args (s/cat :sig valid-i? :low valid-i? :high valid-i? ))
(stest/instrument `mirror:i)

(defn mirror:k
  {:arglists '([ksig klow khigh])}
  [sig low high]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "mirror"
                      [sig low high]
                      *global*)]
    (new out-types ast)))

(s/fdef mirror:k
  :args (s/cat :sig valid-kr? :low valid-kr? :high valid-kr? ))
(stest/instrument `mirror:k)

(defn line
  {:arglists '([ia idur ib] [ia idur ib])}
  [a dur b]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "line"
                      [a dur b]
                      *global*)]
    (new out-types ast)))

(s/fdef line
  :args (s/alt
         :iii (s/cat :a valid-i? :dur valid-i? :b valid-i? )
         ))
(stest/instrument `line)

(defn line:a
  {:arglists '([ia idur ib])}
  [a dur b]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "line"
                      [a dur b]
                      *global*)]
    (new out-types ast)))

(s/fdef line:a
  :args (s/cat :a valid-i? :dur valid-i? :b valid-i? ))
(stest/instrument `line:a)

(defn line:k
  {:arglists '([ia idur ib])}
  [a dur b]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "line"
                      [a dur b]
                      *global*)]
    (new out-types ast)))

(s/fdef line:k
  :args (s/cat :a valid-i? :dur valid-i? :b valid-i? ))
(stest/instrument `line:k)

(defn bamboo
  {:arglists '([kamp idettack & inum* idamp* imaxshake* ifreq* ifreq1* ifreq1*])}
  [amp dettack & [ num* damp* maxshake* freq* freq1* freq1* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "bamboo"
                      [amp dettack num* damp* maxshake* freq* freq1* freq1*]
                      *global*)]
    (new out-types ast)))

(s/fdef bamboo
  :args (s/cat :amp valid-kr? :dettack valid-i? :num* (s/? valid-i?*) :damp* (s/? valid-i?*) :maxshake* (s/? valid-i?*) :freq* (s/? valid-i?*) :freq1* (s/? valid-i?*) :freq1* (s/? valid-i?*) ))
(stest/instrument `bamboo)

(defn out
  {:arglists '([aarrayArr] [aarrayArr] [& aarray1* aarray2* aarray3* aarray4* aarray5* aarray6* aarray7* aarray8* aarray9* aarray10* aarray11* aarray12* aarray13* aarray14* aarray15* aarray16* aarray17* aarray18* aarray19* aarray20* aarray21* aarray22* aarray23* aarray24* aarray25* aarray26* aarray27* aarray28* aarray29* aarray30* aarray31* aarray32*])}
  [array]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "out"
                      [array]
                      *global*)]
    (new out-types ast)))

(s/fdef out
  :args (s/alt
         :aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa (s/cat :array1* (s/? valid-ar?*) :array2* (s/? valid-ar?*) :array3* (s/? valid-ar?*) :array4* (s/? valid-ar?*) :array5* (s/? valid-ar?*) :array6* (s/? valid-ar?*) :array7* (s/? valid-ar?*) :array8* (s/? valid-ar?*) :array9* (s/? valid-ar?*) :array10* (s/? valid-ar?*) :array11* (s/? valid-ar?*) :array12* (s/? valid-ar?*) :array13* (s/? valid-ar?*) :array14* (s/? valid-ar?*) :array15* (s/? valid-ar?*) :array16* (s/? valid-ar?*) :array17* (s/? valid-ar?*) :array18* (s/? valid-ar?*) :array19* (s/? valid-ar?*) :array20* (s/? valid-ar?*) :array21* (s/? valid-ar?*) :array22* (s/? valid-ar?*) :array23* (s/? valid-ar?*) :array24* (s/? valid-ar?*) :array25* (s/? valid-ar?*) :array26* (s/? valid-ar?*) :array27* (s/? valid-ar?*) :array28* (s/? valid-ar?*) :array29* (s/? valid-ar?*) :array30* (s/? valid-ar?*) :array31* (s/? valid-ar?*) :array32* (s/? valid-ar?*) )
         :aArr (s/cat :array valid-aArr? )
         ))
(stest/instrument `out)

(defn ihold
  {:arglists '()}
  []
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "ihold"
                      []
                      *global*)]
    (new out-types ast)))


(defn minabs
  {:arglists '([ain1 & ain1* ain2* ain3* ain4* ain5* ain6* ain7* ain8* ain9* ain10* ain11* ain12* ain13* ain14* ain15* ain16* ain17* ain18* ain19* ain20* ain21* ain22* ain23* ain24* ain25* ain26* ain27* ain28* ain29* ain30* ain31* ain32*] [kin1 & kin1* kin2* kin3* kin4* kin5* kin6* kin7* kin8* kin9* kin10* kin11* kin12* kin13* kin14* kin15* kin16*])}
  [in1 & [ in1* in2* in3* in4* in5* in6* in7* in8* in9* in10* in11* in12* in13* in14* in15* in16* in17* in18* in19* in20* in21* in22* in23* in24* in25* in26* in27* in28* in29* in30* in31* in32* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "minabs"
                      [in1 in1* in2* in3* in4* in5* in6* in7* in8* in9* in10* in11* in12* in13* in14* in15* in16* in17* in18* in19* in20* in21* in22* in23* in24* in25* in26* in27* in28* in29* in30* in31* in32*]
                      *global*)]
    (new out-types ast)))

(s/fdef minabs
  :args (s/alt
         :kkkkkkkkkkkkkkkkk (s/cat :in1 valid-kr? :in1* (s/? valid-kr?*) :in2* (s/? valid-kr?*) :in3* (s/? valid-kr?*) :in4* (s/? valid-kr?*) :in5* (s/? valid-kr?*) :in6* (s/? valid-kr?*) :in7* (s/? valid-kr?*) :in8* (s/? valid-kr?*) :in9* (s/? valid-kr?*) :in10* (s/? valid-kr?*) :in11* (s/? valid-kr?*) :in12* (s/? valid-kr?*) :in13* (s/? valid-kr?*) :in14* (s/? valid-kr?*) :in15* (s/? valid-kr?*) :in16* (s/? valid-kr?*) )
         :aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa (s/cat :in1 valid-ar? :in1* (s/? valid-ar?*) :in2* (s/? valid-ar?*) :in3* (s/? valid-ar?*) :in4* (s/? valid-ar?*) :in5* (s/? valid-ar?*) :in6* (s/? valid-ar?*) :in7* (s/? valid-ar?*) :in8* (s/? valid-ar?*) :in9* (s/? valid-ar?*) :in10* (s/? valid-ar?*) :in11* (s/? valid-ar?*) :in12* (s/? valid-ar?*) :in13* (s/? valid-ar?*) :in14* (s/? valid-ar?*) :in15* (s/? valid-ar?*) :in16* (s/? valid-ar?*) :in17* (s/? valid-ar?*) :in18* (s/? valid-ar?*) :in19* (s/? valid-ar?*) :in20* (s/? valid-ar?*) :in21* (s/? valid-ar?*) :in22* (s/? valid-ar?*) :in23* (s/? valid-ar?*) :in24* (s/? valid-ar?*) :in25* (s/? valid-ar?*) :in26* (s/? valid-ar?*) :in27* (s/? valid-ar?*) :in28* (s/? valid-ar?*) :in29* (s/? valid-ar?*) :in30* (s/? valid-ar?*) :in31* (s/? valid-ar?*) :in32* (s/? valid-ar?*) )
         ))
(stest/instrument `minabs)

(defn minabs:a
  {:arglists '([ain1 & ain1* ain2* ain3* ain4* ain5* ain6* ain7* ain8* ain9* ain10* ain11* ain12* ain13* ain14* ain15* ain16* ain17* ain18* ain19* ain20* ain21* ain22* ain23* ain24* ain25* ain26* ain27* ain28* ain29* ain30* ain31* ain32*])}
  [in1 & [ in1* in2* in3* in4* in5* in6* in7* in8* in9* in10* in11* in12* in13* in14* in15* in16* in17* in18* in19* in20* in21* in22* in23* in24* in25* in26* in27* in28* in29* in30* in31* in32* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "minabs"
                      [in1 in1* in2* in3* in4* in5* in6* in7* in8* in9* in10* in11* in12* in13* in14* in15* in16* in17* in18* in19* in20* in21* in22* in23* in24* in25* in26* in27* in28* in29* in30* in31* in32*]
                      *global*)]
    (new out-types ast)))

(s/fdef minabs:a
  :args (s/cat :in1 valid-ar? :in1* (s/? valid-ar?*) :in2* (s/? valid-ar?*) :in3* (s/? valid-ar?*) :in4* (s/? valid-ar?*) :in5* (s/? valid-ar?*) :in6* (s/? valid-ar?*) :in7* (s/? valid-ar?*) :in8* (s/? valid-ar?*) :in9* (s/? valid-ar?*) :in10* (s/? valid-ar?*) :in11* (s/? valid-ar?*) :in12* (s/? valid-ar?*) :in13* (s/? valid-ar?*) :in14* (s/? valid-ar?*) :in15* (s/? valid-ar?*) :in16* (s/? valid-ar?*) :in17* (s/? valid-ar?*) :in18* (s/? valid-ar?*) :in19* (s/? valid-ar?*) :in20* (s/? valid-ar?*) :in21* (s/? valid-ar?*) :in22* (s/? valid-ar?*) :in23* (s/? valid-ar?*) :in24* (s/? valid-ar?*) :in25* (s/? valid-ar?*) :in26* (s/? valid-ar?*) :in27* (s/? valid-ar?*) :in28* (s/? valid-ar?*) :in29* (s/? valid-ar?*) :in30* (s/? valid-ar?*) :in31* (s/? valid-ar?*) :in32* (s/? valid-ar?*) ))
(stest/instrument `minabs:a)

(defn minabs:k
  {:arglists '([kin1 & kin1* kin2* kin3* kin4* kin5* kin6* kin7* kin8* kin9* kin10* kin11* kin12* kin13* kin14* kin15* kin16*])}
  [in1 & [ in1* in2* in3* in4* in5* in6* in7* in8* in9* in10* in11* in12* in13* in14* in15* in16* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "minabs"
                      [in1 in1* in2* in3* in4* in5* in6* in7* in8* in9* in10* in11* in12* in13* in14* in15* in16*]
                      *global*)]
    (new out-types ast)))

(s/fdef minabs:k
  :args (s/cat :in1 valid-kr? :in1* (s/? valid-kr?*) :in2* (s/? valid-kr?*) :in3* (s/? valid-kr?*) :in4* (s/? valid-kr?*) :in5* (s/? valid-kr?*) :in6* (s/? valid-kr?*) :in7* (s/? valid-kr?*) :in8* (s/? valid-kr?*) :in9* (s/? valid-kr?*) :in10* (s/? valid-kr?*) :in11* (s/? valid-kr?*) :in12* (s/? valid-kr?*) :in13* (s/? valid-kr?*) :in14* (s/? valid-kr?*) :in15* (s/? valid-kr?*) :in16* (s/? valid-kr?*) ))
(stest/instrument `minabs:k)

(defn randomi
  {:arglists '([kmin kmax xcps & imode* ifirstval*] [kmin kmax kcps & imode* ifirstval*])}
  [min max cps & [ mode* firstval* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "randomi"
                      [min max cps mode* firstval*]
                      *global*)]
    (new out-types ast)))

(s/fdef randomi
  :args (s/alt
         :kkkii (s/cat :min valid-kr? :max valid-kr? :cps valid-kr? :mode* (s/? valid-i?*) :firstval* (s/? valid-i?*) )
         :kkxii (s/cat :min valid-kr? :max valid-kr? :cps valid-x? :mode* (s/? valid-i?*) :firstval* (s/? valid-i?*) )
         ))
(stest/instrument `randomi)

(defn randomi:a
  {:arglists '([kmin kmax xcps & imode* ifirstval*])}
  [min max cps & [ mode* firstval* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "randomi"
                      [min max cps mode* firstval*]
                      *global*)]
    (new out-types ast)))

(s/fdef randomi:a
  :args (s/cat :min valid-kr? :max valid-kr? :cps valid-x? :mode* (s/? valid-i?*) :firstval* (s/? valid-i?*) ))
(stest/instrument `randomi:a)

(defn randomi:k
  {:arglists '([kmin kmax kcps & imode* ifirstval*])}
  [min max cps & [ mode* firstval* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "randomi"
                      [min max cps mode* firstval*]
                      *global*)]
    (new out-types ast)))

(s/fdef randomi:k
  :args (s/cat :min valid-kr? :max valid-kr? :cps valid-kr? :mode* (s/? valid-i?*) :firstval* (s/? valid-i?*) ))
(stest/instrument `randomi:k)

(defn zar
  {:arglists '([kindex])}
  [index]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "zar"
                      [index]
                      *global*)]
    (new out-types ast)))

(s/fdef zar
  :args (s/cat :index valid-kr? ))
(stest/instrument `zar)

(defn outrg
  {:arglists '([kstart & aout1* aout2* aout3* aoutN4* aoutN5* aoutN6* aoutN7* aoutN8* aoutN9* aoutN10* aoutN11* aoutN12* aoutN13* aoutN14* aoutN15* aoutN16* aoutN17* aoutN18* aoutN19* aoutN20* aoutN21* aoutN22* aoutN23* aoutN24* aoutN25* aoutN26* aoutN27* aoutN28* aoutN29* aoutN30* aoutN31* aoutN32*])}
  [start & [ out1* out2* out3* outN4* outN5* outN6* outN7* outN8* outN9* outN10* outN11* outN12* outN13* outN14* outN15* outN16* outN17* outN18* outN19* outN20* outN21* outN22* outN23* outN24* outN25* outN26* outN27* outN28* outN29* outN30* outN31* outN32* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outrg"
                      [start out1* out2* out3* outN4* outN5* outN6* outN7* outN8* outN9* outN10* outN11* outN12* outN13* outN14* outN15* outN16* outN17* outN18* outN19* outN20* outN21* outN22* outN23* outN24* outN25* outN26* outN27* outN28* outN29* outN30* outN31* outN32*]
                      *global*)]
    (new out-types ast)))

(s/fdef outrg
  :args (s/cat :start valid-kr? :out1* (s/? valid-ar?*) :out2* (s/? valid-ar?*) :out3* (s/? valid-ar?*) :outN4* (s/? valid-ar?*) :outN5* (s/? valid-ar?*) :outN6* (s/? valid-ar?*) :outN7* (s/? valid-ar?*) :outN8* (s/? valid-ar?*) :outN9* (s/? valid-ar?*) :outN10* (s/? valid-ar?*) :outN11* (s/? valid-ar?*) :outN12* (s/? valid-ar?*) :outN13* (s/? valid-ar?*) :outN14* (s/? valid-ar?*) :outN15* (s/? valid-ar?*) :outN16* (s/? valid-ar?*) :outN17* (s/? valid-ar?*) :outN18* (s/? valid-ar?*) :outN19* (s/? valid-ar?*) :outN20* (s/? valid-ar?*) :outN21* (s/? valid-ar?*) :outN22* (s/? valid-ar?*) :outN23* (s/? valid-ar?*) :outN24* (s/? valid-ar?*) :outN25* (s/? valid-ar?*) :outN26* (s/? valid-ar?*) :outN27* (s/? valid-ar?*) :outN28* (s/? valid-ar?*) :outN29* (s/? valid-ar?*) :outN30* (s/? valid-ar?*) :outN31* (s/? valid-ar?*) :outN32* (s/? valid-ar?*) ))
(stest/instrument `outrg)

(defn partikkelget
  {:arglists '([kparameterindex iopcode_id])}
  [parameterindex opcode_id]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "partikkelget"
                      [parameterindex opcode_id]
                      *global*)]
    (new out-types ast)))

(s/fdef partikkelget
  :args (s/cat :parameterindex valid-kr? :opcode_id valid-i? ))
(stest/instrument `partikkelget)

(defn chn_a
  {:arglists '([Sname imode])}
  [name mode]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "chn_a"
                      [name mode]
                      *global*)]
    (new out-types ast)))

(s/fdef chn_a
  :args (s/cat :name valid-S? :mode valid-i? ))
(stest/instrument `chn_a)

(defn sandpaper
  {:arglists '([iamp idettack & inum* idamp* imaxshake*])}
  [amp dettack & [ num* damp* maxshake* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "sandpaper"
                      [amp dettack num* damp* maxshake*]
                      *global*)]
    (new out-types ast)))

(s/fdef sandpaper
  :args (s/cat :amp valid-i? :dettack valid-i? :num* (s/? valid-i?*) :damp* (s/? valid-i?*) :maxshake* (s/? valid-i?*) ))
(stest/instrument `sandpaper)

(defn outq4
  {:arglists '([asig])}
  [sig]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outq4"
                      [sig]
                      *global*)]
    (new out-types ast)))

(s/fdef outq4
  :args (s/cat :sig valid-ar? ))
(stest/instrument `outq4)

(defn pvspitch
  {:arglists '([fsig kthresh])}
  [sig thresh]
  (let [out-types-quoted '[ControlSignal ControlSignal]
        out-types [ControlSignal ControlSignal]
        ast (ast-node out-types-quoted
                      "pvspitch"
                      [sig thresh]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef pvspitch
  :args (s/cat :sig valid-f? :thresh valid-kr? ))
(stest/instrument `pvspitch)

(defn zarg
  {:arglists '([kindex kgain])}
  [index gain]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "zarg"
                      [index gain]
                      *global*)]
    (new out-types ast)))

(s/fdef zarg
  :args (s/cat :index valid-kr? :gain valid-kr? ))
(stest/instrument `zarg)

(defn cpsmidi
  {:arglists '()}
  []
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "cpsmidi"
                      []
                      *global*)]
    (new out-types ast)))


(defn gendy
  {:arglists '([kamp kampdist kdurdist kadpar kddpar kminfreq kmaxfreq kampscl kdurscl & initcps* knum*] [kamp kampdist kdurdist kadpar kddpar kminfreq kmaxfreq kampscl kdurscl & initcps* knum*])}
  [amp ampdist durdist adpar ddpar minfreq maxfreq ampscl durscl & [ nitcps* num* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "gendy"
                      [amp ampdist durdist adpar ddpar minfreq maxfreq ampscl durscl nitcps* num*]
                      *global*)]
    (new out-types ast)))

(s/fdef gendy
  :args (s/alt
         :kkkkkkkkkik (s/cat :amp valid-kr? :ampdist valid-kr? :durdist valid-kr? :adpar valid-kr? :ddpar valid-kr? :minfreq valid-kr? :maxfreq valid-kr? :ampscl valid-kr? :durscl valid-kr? :nitcps* (s/? valid-i?*) :num* (s/? valid-kr?*) )
         ))
(stest/instrument `gendy)

(defn gendy:a
  {:arglists '([kamp kampdist kdurdist kadpar kddpar kminfreq kmaxfreq kampscl kdurscl & initcps* knum*])}
  [amp ampdist durdist adpar ddpar minfreq maxfreq ampscl durscl & [ nitcps* num* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "gendy"
                      [amp ampdist durdist adpar ddpar minfreq maxfreq ampscl durscl nitcps* num*]
                      *global*)]
    (new out-types ast)))

(s/fdef gendy:a
  :args (s/cat :amp valid-kr? :ampdist valid-kr? :durdist valid-kr? :adpar valid-kr? :ddpar valid-kr? :minfreq valid-kr? :maxfreq valid-kr? :ampscl valid-kr? :durscl valid-kr? :nitcps* (s/? valid-i?*) :num* (s/? valid-kr?*) ))
(stest/instrument `gendy:a)

(defn gendy:k
  {:arglists '([kamp kampdist kdurdist kadpar kddpar kminfreq kmaxfreq kampscl kdurscl & initcps* knum*])}
  [amp ampdist durdist adpar ddpar minfreq maxfreq ampscl durscl & [ nitcps* num* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "gendy"
                      [amp ampdist durdist adpar ddpar minfreq maxfreq ampscl durscl nitcps* num*]
                      *global*)]
    (new out-types ast)))

(s/fdef gendy:k
  :args (s/cat :amp valid-kr? :ampdist valid-kr? :durdist valid-kr? :adpar valid-kr? :ddpar valid-kr? :minfreq valid-kr? :maxfreq valid-kr? :ampscl valid-kr? :durscl valid-kr? :nitcps* (s/? valid-i?*) :num* (s/? valid-kr?*) ))
(stest/instrument `gendy:k)

(defn xscans
  {:arglists '([kamp kfreq ifntraj id & iorder*])}
  [amp freq fntraj d & [ order* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "xscans"
                      [amp freq fntraj d order*]
                      *global*)]
    (new out-types ast)))

(s/fdef xscans
  :args (s/cat :amp valid-kr? :freq valid-kr? :fntraj valid-i? :d valid-i? :order* (s/? valid-i?*) ))
(stest/instrument `xscans)

(defn hrtfmove2
  {:arglists '([asrc kAz kElev Sfilel Sfiler & ioverlap* iradius* isr*])}
  [src Az Elev filel filer & [ overlap* radius* sr* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "hrtfmove2"
                      [src Az Elev filel filer overlap* radius* sr*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef hrtfmove2
  :args (s/cat :src valid-ar? :Az valid-kr? :Elev valid-kr? :filel valid-S? :filer valid-S? :overlap* (s/? valid-i?*) :radius* (s/? valid-i?*) :sr* (s/? valid-i?*) ))
(stest/instrument `hrtfmove2)

(defn dust2
  {:arglists '([kamp kdensity] [kamp kdensity])}
  [amp density]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "dust2"
                      [amp density]
                      *global*)]
    (new out-types ast)))

(s/fdef dust2
  :args (s/alt
         :kk (s/cat :amp valid-kr? :density valid-kr? )
         ))
(stest/instrument `dust2)

(defn dust2:a
  {:arglists '([kamp kdensity])}
  [amp density]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "dust2"
                      [amp density]
                      *global*)]
    (new out-types ast)))

(s/fdef dust2:a
  :args (s/cat :amp valid-kr? :density valid-kr? ))
(stest/instrument `dust2:a)

(defn dust2:k
  {:arglists '([kamp kdensity])}
  [amp density]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "dust2"
                      [amp density]
                      *global*)]
    (new out-types ast)))

(s/fdef dust2:k
  :args (s/cat :amp valid-kr? :density valid-kr? ))
(stest/instrument `dust2:k)

(defn cpstmid
  {:arglists '([itable])}
  [table]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "cpstmid"
                      [table]
                      *global*)]
    (new out-types ast)))

(s/fdef cpstmid
  :args (s/cat :table valid-i? ))
(stest/instrument `cpstmid)

(defn evalstr
  {:arglists '([Scode] [Scode ktrig])}
  [code]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "evalstr"
                      [code]
                      *global*)]
    (new out-types ast)))

(s/fdef evalstr
  :args (s/alt
         :Sk (s/cat :code valid-S? :trig valid-kr? )
         :S (s/cat :code valid-S? )
         ))
(stest/instrument `evalstr)

(defn evalstr:i
  {:arglists '([Scode])}
  [code]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "evalstr"
                      [code]
                      *global*)]
    (new out-types ast)))

(s/fdef evalstr:i
  :args (s/cat :code valid-S? ))
(stest/instrument `evalstr:i)

(defn evalstr:k
  {:arglists '([Scode ktrig])}
  [code trig]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "evalstr"
                      [code trig]
                      *global*)]
    (new out-types ast)))

(s/fdef evalstr:k
  :args (s/cat :code valid-S? :trig valid-kr? ))
(stest/instrument `evalstr:k)

(defn midichannelaftertouch
  {:arglists '([xchannelaftertouch & ilow* ihigh*])}
  [channelaftertouch & [ low* high* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "midichannelaftertouch"
                      [channelaftertouch low* high*]
                      *global*)]
    (new out-types ast)))

(s/fdef midichannelaftertouch
  :args (s/cat :channelaftertouch valid-x? :low* (s/? valid-i?*) :high* (s/? valid-i?*) ))
(stest/instrument `midichannelaftertouch)

(defn filesr
  {:arglists '([Sfilcod & iallowraw*] [ifilcod & iallowraw*])}
  [filcod & [ allowraw* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "filesr"
                      [filcod allowraw*]
                      *global*)]
    (new out-types ast)))

(s/fdef filesr
  :args (s/alt
         :ii (s/cat :filcod valid-i? :allowraw* (s/? valid-i?*) )
         :Si (s/cat :filcod valid-S? :allowraw* (s/? valid-i?*) )
         ))
(stest/instrument `filesr)

(defn dispfft
  {:arglists '([xsig iprd iwsiz & iwtyp* idbout* iwtflg* imin* imax*])}
  [sig prd wsiz & [ wtyp* dbout* wtflg* min* max* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "dispfft"
                      [sig prd wsiz wtyp* dbout* wtflg* min* max*]
                      *global*)]
    (new out-types ast)))

(s/fdef dispfft
  :args (s/cat :sig valid-x? :prd valid-i? :wsiz valid-i? :wtyp* (s/? valid-i?*) :dbout* (s/? valid-i?*) :wtflg* (s/? valid-i?*) :min* (s/? valid-i?*) :max* (s/? valid-i?*) ))
(stest/instrument `dispfft)

(defn chnmix
  {:arglists '([aval Sname])}
  [val name]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "chnmix"
                      [val name]
                      *global*)]
    (new out-types ast)))

(s/fdef chnmix
  :args (s/cat :val valid-ar? :name valid-S? ))
(stest/instrument `chnmix)

(defn delay
  {:arglists '([asig idlt & iskip*])}
  [sig dlt & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "delay"
                      [sig dlt skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef delay
  :args (s/cat :sig valid-ar? :dlt valid-i? :skip* (s/? valid-i?*) ))
(stest/instrument `delay)

(defn zdf_ladder
  {:arglists '([ain xcenter-frequency xQ & istor*])}
  [in center-frequency Q & [ stor* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "zdf_ladder"
                      [in center-frequency Q stor*]
                      *global*)]
    (new out-types ast)))

(s/fdef zdf_ladder
  :args (s/cat :in valid-ar? :center-frequency valid-x? :Q valid-x? :stor* (s/? valid-i?*) ))
(stest/instrument `zdf_ladder)

(defn expcurve
  {:arglists '([kindex ksteepness])}
  [index steepness]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "expcurve"
                      [index steepness]
                      *global*)]
    (new out-types ast)))

(s/fdef expcurve
  :args (s/cat :index valid-kr? :steepness valid-kr? ))
(stest/instrument `expcurve)

(defn squinewave
  {:arglists '([acps aClip aSkew xsyncin & iMinSweep* iphase*])}
  [cps Clip Skew syncin & [ MinSweep* phase* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "squinewave"
                      [cps Clip Skew syncin MinSweep* phase*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef squinewave
  :args (s/cat :cps valid-ar? :Clip valid-ar? :Skew valid-ar? :syncin valid-x? :MinSweep* (s/? valid-i?*) :phase* (s/? valid-i?*) ))
(stest/instrument `squinewave)

(defn OSCraw
  {:arglists '([iport])}
  [port]
  (let [out-types-quoted '[StringArray ControlSignal]
        out-types [StringArray ControlSignal]
        ast (ast-node out-types-quoted
                      "OSCraw"
                      [port]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef OSCraw
  :args (s/cat :port valid-i? ))
(stest/instrument `OSCraw)

(defn taninv
  {:arglists '([aradian] [iradian] [iradianArr] [kradian] [kradianArr])}
  [radian]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "taninv"
                      [radian]
                      *global*)]
    (new out-types ast)))

(s/fdef taninv
  :args (s/alt
         :kArr (s/cat :radian valid-kArr? )
         :k (s/cat :radian valid-kr? )
         :iArr (s/cat :radian valid-iArr? )
         :i (s/cat :radian valid-i? )
         :a (s/cat :radian valid-ar? )
         ))
(stest/instrument `taninv)

(defn taninv:a
  {:arglists '([aradian])}
  [radian]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "taninv"
                      [radian]
                      *global*)]
    (new out-types ast)))

(s/fdef taninv:a
  :args (s/cat :radian valid-ar? ))
(stest/instrument `taninv:a)

(defn taninv:i
  {:arglists '([iradian])}
  [radian]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "taninv"
                      [radian]
                      *global*)]
    (new out-types ast)))

(s/fdef taninv:i
  :args (s/cat :radian valid-i? ))
(stest/instrument `taninv:i)

(defn taninv:iArr
  {:arglists '([iradianArr])}
  [radian]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "taninv"
                      [radian]
                      *global*)]
    (new out-types ast)))

(s/fdef taninv:iArr
  :args (s/cat :radian valid-iArr? ))
(stest/instrument `taninv:iArr)

(defn taninv:k
  {:arglists '([kradian])}
  [radian]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "taninv"
                      [radian]
                      *global*)]
    (new out-types ast)))

(s/fdef taninv:k
  :args (s/cat :radian valid-kr? ))
(stest/instrument `taninv:k)

(defn taninv:kArr
  {:arglists '([kradianArr])}
  [radian]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "taninv"
                      [radian]
                      *global*)]
    (new out-types ast)))

(s/fdef taninv:kArr
  :args (s/cat :radian valid-kArr? ))
(stest/instrument `taninv:kArr)

(defn mclock
  {:arglists '([ifreq])}
  [freq]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "mclock"
                      [freq]
                      *global*)]
    (new out-types ast)))

(s/fdef mclock
  :args (s/cat :freq valid-i? ))
(stest/instrument `mclock)

(defn ziwm
  {:arglists '([isig iindex & imix*])}
  [sig index & [ mix* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "ziwm"
                      [sig index mix*]
                      *global*)]
    (new out-types ast)))

(s/fdef ziwm
  :args (s/cat :sig valid-i? :index valid-i? :mix* (s/? valid-i?*) ))
(stest/instrument `ziwm)

(defn partikkelset
  {:arglists '([kparameterindex kmaskindex iopcode_id])}
  [parameterindex maskindex opcode_id]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "partikkelset"
                      [parameterindex maskindex opcode_id]
                      *global*)]
    (new out-types ast)))

(s/fdef partikkelset
  :args (s/cat :parameterindex valid-kr? :maskindex valid-kr? :opcode_id valid-i? ))
(stest/instrument `partikkelset)

(defn i
  {:arglists '([ikarray] [kkarray] [kkarrayArr & ikarray1* ikarray2* ikarray3* ikarray4* ikarray5* ikarray6* ikarray7* ikarray8* ikarray9* ikarray10* ikarray11* ikarray12* ikarray13* ikarray14* ikarray15* ikarray16*] [kkarrayArr & kkarray1* kkarray2* kkarray3* kkarray4* kkarray5* kkarray6* kkarray7* kkarray8* kkarray9* kkarray10* kkarray11* kkarray12* kkarray13* kkarray14* kkarray15* kkarray16*])}
  [karray]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "i"
                      [karray]
                      *global*)]
    (new out-types ast)))

(s/fdef i
  :args (s/alt
         :kArrkkkkkkkkkkkkkkkk (s/cat :karray valid-kArr? :karray1* (s/? valid-kr?*) :karray2* (s/? valid-kr?*) :karray3* (s/? valid-kr?*) :karray4* (s/? valid-kr?*) :karray5* (s/? valid-kr?*) :karray6* (s/? valid-kr?*) :karray7* (s/? valid-kr?*) :karray8* (s/? valid-kr?*) :karray9* (s/? valid-kr?*) :karray10* (s/? valid-kr?*) :karray11* (s/? valid-kr?*) :karray12* (s/? valid-kr?*) :karray13* (s/? valid-kr?*) :karray14* (s/? valid-kr?*) :karray15* (s/? valid-kr?*) :karray16* (s/? valid-kr?*) )
         :kArriiiiiiiiiiiiiiii (s/cat :karray valid-kArr? :karray1* (s/? valid-i?*) :karray2* (s/? valid-i?*) :karray3* (s/? valid-i?*) :karray4* (s/? valid-i?*) :karray5* (s/? valid-i?*) :karray6* (s/? valid-i?*) :karray7* (s/? valid-i?*) :karray8* (s/? valid-i?*) :karray9* (s/? valid-i?*) :karray10* (s/? valid-i?*) :karray11* (s/? valid-i?*) :karray12* (s/? valid-i?*) :karray13* (s/? valid-i?*) :karray14* (s/? valid-i?*) :karray15* (s/? valid-i?*) :karray16* (s/? valid-i?*) )
         :k (s/cat :karray valid-kr? )
         :i (s/cat :karray valid-i? )
         ))
(stest/instrument `i)

(defn hilbert
  {:arglists '([asig])}
  [sig]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "hilbert"
                      [sig]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef hilbert
  :args (s/cat :sig valid-ar? ))
(stest/instrument `hilbert)

(defn spsend
  {:arglists '()}
  []
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "spsend"
                      []
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))


(defn sfpreset
  {:arglists '([iprog ibank ifilhandle ipreindex])}
  [prog bank filhandle preindex]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "sfpreset"
                      [prog bank filhandle preindex]
                      *global*)]
    (new out-types ast)))

(s/fdef sfpreset
  :args (s/cat :prog valid-i? :bank valid-i? :filhandle valid-i? :preindex valid-i? ))
(stest/instrument `sfpreset)

(defn tableseg
  {:arglists '([ifn1 idur2 & ifn1* idur2* ifn3* ifn4* ifn5* ifn6* ifn7* ifn8* ifn9* ifn10* ifn11* ifn12* ifn13* ifn14* ifn15* ifn16*])}
  [fn1 dur2 & [ fn1* dur2* fn3* fn4* fn5* fn6* fn7* fn8* fn9* fn10* fn11* fn12* fn13* fn14* fn15* fn16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "tableseg"
                      [fn1 dur2 fn1* dur2* fn3* fn4* fn5* fn6* fn7* fn8* fn9* fn10* fn11* fn12* fn13* fn14* fn15* fn16*]
                      *global*)]
    (new out-types ast)))

(s/fdef tableseg
  :args (s/cat :fn1 valid-i? :dur2 valid-i? :fn1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :fn3* (s/? valid-i?*) :fn4* (s/? valid-i?*) :fn5* (s/? valid-i?*) :fn6* (s/? valid-i?*) :fn7* (s/? valid-i?*) :fn8* (s/? valid-i?*) :fn9* (s/? valid-i?*) :fn10* (s/? valid-i?*) :fn11* (s/? valid-i?*) :fn12* (s/? valid-i?*) :fn13* (s/? valid-i?*) :fn14* (s/? valid-i?*) :fn15* (s/? valid-i?*) :fn16* (s/? valid-i?*) ))
(stest/instrument `tableseg)

(defn timedseq
  {:arglists '([ktimpnt itable & kp1* kp2* kp3* kpN4* kpN5* kpN6* kpN7* kpN8* kpN9* kpN10* kpN11* kpN12* kpN13* kpN14* kpN15* kpN16*])}
  [timpnt table & [ p1* p2* p3* pN4* pN5* pN6* pN7* pN8* pN9* pN10* pN11* pN12* pN13* pN14* pN15* pN16* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "timedseq"
                      [timpnt table p1* p2* p3* pN4* pN5* pN6* pN7* pN8* pN9* pN10* pN11* pN12* pN13* pN14* pN15* pN16*]
                      *global*)]
    (new out-types ast)))

(s/fdef timedseq
  :args (s/cat :timpnt valid-kr? :table valid-i? :p1* (s/? valid-kr?*) :p2* (s/? valid-kr?*) :p3* (s/? valid-kr?*) :pN4* (s/? valid-kr?*) :pN5* (s/? valid-kr?*) :pN6* (s/? valid-kr?*) :pN7* (s/? valid-kr?*) :pN8* (s/? valid-kr?*) :pN9* (s/? valid-kr?*) :pN10* (s/? valid-kr?*) :pN11* (s/? valid-kr?*) :pN12* (s/? valid-kr?*) :pN13* (s/? valid-kr?*) :pN14* (s/? valid-kr?*) :pN15* (s/? valid-kr?*) :pN16* (s/? valid-kr?*) ))
(stest/instrument `timedseq)

(defn pvsdemix
  {:arglists '([fleft fright kpos kwidth ipoints])}
  [left right pos width points]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvsdemix"
                      [left right pos width points]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsdemix
  :args (s/cat :left valid-f? :right valid-f? :pos valid-kr? :width valid-kr? :points valid-i? ))
(stest/instrument `pvsdemix)

(defn ptablew
  {:arglists '([asig aindex itable & ixmode* ixoff* iwgmode*] [ksig kindex itable & ixmode* ixoff* iwgmode*])}
  [sig index table & [ xmode* xoff* wgmode* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "ptablew"
                      [sig index table xmode* xoff* wgmode*]
                      *global*)]
    (new out-types ast)))

(s/fdef ptablew
  :args (s/alt
         :kkiiii (s/cat :sig valid-kr? :index valid-kr? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wgmode* (s/? valid-i?*) )
         :aaiiii (s/cat :sig valid-ar? :index valid-ar? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wgmode* (s/? valid-i?*) )
         ))
(stest/instrument `ptablew)

(defn pset
  {:arglists '([& icon1* icon2* icon3* icon4* icon5* icon6* icon7* icon8* icon9* icon10* icon11* icon12* icon13* icon14* icon15* icon16*])}
  [& [ con1* con2* con3* con4* con5* con6* con7* con8* con9* con10* con11* con12* con13* con14* con15* con16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "pset"
                      [con1* con2* con3* con4* con5* con6* con7* con8* con9* con10* con11* con12* con13* con14* con15* con16*]
                      *global*)]
    (new out-types ast)))

(s/fdef pset
  :args (s/cat :con1* (s/? valid-i?*) :con2* (s/? valid-i?*) :con3* (s/? valid-i?*) :con4* (s/? valid-i?*) :con5* (s/? valid-i?*) :con6* (s/? valid-i?*) :con7* (s/? valid-i?*) :con8* (s/? valid-i?*) :con9* (s/? valid-i?*) :con10* (s/? valid-i?*) :con11* (s/? valid-i?*) :con12* (s/? valid-i?*) :con13* (s/? valid-i?*) :con14* (s/? valid-i?*) :con15* (s/? valid-i?*) :con16* (s/? valid-i?*) ))
(stest/instrument `pset)

(defn downsamp
  {:arglists '([asig & iwlen*])}
  [sig & [ wlen* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "downsamp"
                      [sig wlen*]
                      *global*)]
    (new out-types ast)))

(s/fdef downsamp
  :args (s/cat :sig valid-ar? :wlen* (s/? valid-i?*) ))
(stest/instrument `downsamp)

(defn atonex
  {:arglists '([asig ahp & inumlayer* iskip*] [asig khp & inumlayer* iskip*])}
  [sig hp & [ numlayer* skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "atonex"
                      [sig hp numlayer* skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef atonex
  :args (s/alt
         :akii (s/cat :sig valid-ar? :hp valid-kr? :numlayer* (s/? valid-i?*) :skip* (s/? valid-i?*) )
         :aaii (s/cat :sig valid-ar? :hp valid-ar? :numlayer* (s/? valid-i?*) :skip* (s/? valid-i?*) )
         ))
(stest/instrument `atonex)

(defn sinsyn
  {:arglists '([fin kscal kmaxtracks itable & itable*])}
  [in scal maxtracks table & [ table* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "sinsyn"
                      [in scal maxtracks table table*]
                      *global*)]
    (new out-types ast)))

(s/fdef sinsyn
  :args (s/cat :in valid-f? :scal valid-kr? :maxtracks valid-kr? :table valid-i? :table* (s/? valid-i?*) ))
(stest/instrument `sinsyn)

(defn fmvoice
  {:arglists '([kamp kfreq kvowel ktilt kvibamt kvibrate & ifn1* ifn1* ifn1* ifn1* ivibfn*])}
  [amp freq vowel tilt vibamt vibrate & [ fn1* fn1* fn1* fn1* vibfn* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "fmvoice"
                      [amp freq vowel tilt vibamt vibrate fn1* fn1* fn1* fn1* vibfn*]
                      *global*)]
    (new out-types ast)))

(s/fdef fmvoice
  :args (s/cat :amp valid-kr? :freq valid-kr? :vowel valid-kr? :tilt valid-kr? :vibamt valid-kr? :vibrate valid-kr? :fn1* (s/? valid-i?*) :fn1* (s/? valid-i?*) :fn1* (s/? valid-i?*) :fn1* (s/? valid-i?*) :vibfn* (s/? valid-i?*) ))
(stest/instrument `fmvoice)

(defn atonek
  {:arglists '([ksig khp & iskip*])}
  [sig hp & [ skip* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "atonek"
                      [sig hp skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef atonek
  :args (s/cat :sig valid-kr? :hp valid-kr? :skip* (s/? valid-i?*) ))
(stest/instrument `atonek)

(defn endin
  {:arglists '()}
  []
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "endin"
                      []
                      *global*)]
    (new out-types ast)))


(defn pvsbandp
  {:arglists '([fsigin xlowcut xlowfull xhighfull xhighcut & ktype*])}
  [sigin lowcut lowfull highfull highcut & [ type* ]]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvsbandp"
                      [sigin lowcut lowfull highfull highcut type*]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsbandp
  :args (s/cat :sigin valid-f? :lowcut valid-x? :lowfull valid-x? :highfull valid-x? :highcut valid-x? :type* (s/? valid-kr?*) ))
(stest/instrument `pvsbandp)

(defn writescratch
  {:arglists '([ival & index*])}
  [val & [ ndex* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "writescratch"
                      [val ndex*]
                      *global*)]
    (new out-types ast)))

(s/fdef writescratch
  :args (s/cat :val valid-i? :ndex* (s/? valid-i?*) ))
(stest/instrument `writescratch)

(defn liveconv
  {:arglists '([ain ift iplen kupdate kclear])}
  [in ft plen update clear]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "liveconv"
                      [in ft plen update clear]
                      *global*)]
    (new out-types ast)))

(s/fdef liveconv
  :args (s/cat :in valid-ar? :ft valid-i? :plen valid-i? :update valid-kr? :clear valid-kr? ))
(stest/instrument `liveconv)

(defn pvsbin
  {:arglists '([fsig kbin])}
  [sig bin]
  (let [out-types-quoted '[ControlSignal ControlSignal]
        out-types [ControlSignal ControlSignal]
        ast (ast-node out-types-quoted
                      "pvsbin"
                      [sig bin]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef pvsbin
  :args (s/cat :sig valid-f? :bin valid-kr? ))
(stest/instrument `pvsbin)

(defn tableicopy
  {:arglists '([idft isft])}
  [dft sft]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "tableicopy"
                      [dft sft]
                      *global*)]
    (new out-types ast)))

(s/fdef tableicopy
  :args (s/cat :dft valid-i? :sft valid-i? ))
(stest/instrument `tableicopy)

(defn wguide2
  {:arglists '([asig xfreq2 xfreq3 kcutoff4 kcutoff5 kfeedback6 kfeedback7])}
  [sig freq2 freq3 cutoff4 cutoff5 feedback6 feedback7]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "wguide2"
                      [sig freq2 freq3 cutoff4 cutoff5 feedback6 feedback7]
                      *global*)]
    (new out-types ast)))

(s/fdef wguide2
  :args (s/cat :sig valid-ar? :freq2 valid-x? :freq3 valid-x? :cutoff4 valid-kr? :cutoff5 valid-kr? :feedback6 valid-kr? :feedback7 valid-kr? ))
(stest/instrument `wguide2)

(defn delayw
  {:arglists '([asig])}
  [sig]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "delayw"
                      [sig]
                      *global*)]
    (new out-types ast)))

(s/fdef delayw
  :args (s/cat :sig valid-ar? ))
(stest/instrument `delayw)

(defn cabasa
  {:arglists '([iamp idettack & inum* idamp* imaxshake*])}
  [amp dettack & [ num* damp* maxshake* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "cabasa"
                      [amp dettack num* damp* maxshake*]
                      *global*)]
    (new out-types ast)))

(s/fdef cabasa
  :args (s/cat :amp valid-i? :dettack valid-i? :num* (s/? valid-i?*) :damp* (s/? valid-i?*) :maxshake* (s/? valid-i?*) ))
(stest/instrument `cabasa)

(defn strsubk
  {:arglists '([Ssrc kstart kend])}
  [src start end]
  (let [out-types-quoted 'String
        out-types String
        ast (ast-node out-types-quoted
                      "strsubk"
                      [src start end]
                      *global*)]
    (new out-types ast)))

(s/fdef strsubk
  :args (s/cat :src valid-S? :start valid-kr? :end valid-kr? ))
(stest/instrument `strsubk)

(defn linsegr
  {:arglists '([ia idur2 & ib1* idur2* ic3* irel4* iz5* iz6* iz7* iz8* iz9* iz10* iz11* iz12* iz13* iz14* iz15* iz16*] [ia idur2 & ib1* idur2* ic3* irel4* iz5* iz6* iz7* iz8* iz9* iz10* iz11* iz12* iz13* iz14* iz15* iz16*])}
  [a dur2 & [ b1* dur2* c3* rel4* z5* z6* z7* z8* z9* z10* z11* z12* z13* z14* z15* z16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "linsegr"
                      [a dur2 b1* dur2* c3* rel4* z5* z6* z7* z8* z9* z10* z11* z12* z13* z14* z15* z16*]
                      *global*)]
    (new out-types ast)))

(s/fdef linsegr
  :args (s/alt
         :iiiiiiiiiiiiiiiiii (s/cat :a valid-i? :dur2 valid-i? :b1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :c3* (s/? valid-i?*) :rel4* (s/? valid-i?*) :z5* (s/? valid-i?*) :z6* (s/? valid-i?*) :z7* (s/? valid-i?*) :z8* (s/? valid-i?*) :z9* (s/? valid-i?*) :z10* (s/? valid-i?*) :z11* (s/? valid-i?*) :z12* (s/? valid-i?*) :z13* (s/? valid-i?*) :z14* (s/? valid-i?*) :z15* (s/? valid-i?*) :z16* (s/? valid-i?*) )
         ))
(stest/instrument `linsegr)

(defn linsegr:a
  {:arglists '([ia idur2 & ib1* idur2* ic3* irel4* iz5* iz6* iz7* iz8* iz9* iz10* iz11* iz12* iz13* iz14* iz15* iz16*])}
  [a dur2 & [ b1* dur2* c3* rel4* z5* z6* z7* z8* z9* z10* z11* z12* z13* z14* z15* z16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "linsegr"
                      [a dur2 b1* dur2* c3* rel4* z5* z6* z7* z8* z9* z10* z11* z12* z13* z14* z15* z16*]
                      *global*)]
    (new out-types ast)))

(s/fdef linsegr:a
  :args (s/cat :a valid-i? :dur2 valid-i? :b1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :c3* (s/? valid-i?*) :rel4* (s/? valid-i?*) :z5* (s/? valid-i?*) :z6* (s/? valid-i?*) :z7* (s/? valid-i?*) :z8* (s/? valid-i?*) :z9* (s/? valid-i?*) :z10* (s/? valid-i?*) :z11* (s/? valid-i?*) :z12* (s/? valid-i?*) :z13* (s/? valid-i?*) :z14* (s/? valid-i?*) :z15* (s/? valid-i?*) :z16* (s/? valid-i?*) ))
(stest/instrument `linsegr:a)

(defn linsegr:k
  {:arglists '([ia idur2 & ib1* idur2* ic3* irel4* iz5* iz6* iz7* iz8* iz9* iz10* iz11* iz12* iz13* iz14* iz15* iz16*])}
  [a dur2 & [ b1* dur2* c3* rel4* z5* z6* z7* z8* z9* z10* z11* z12* z13* z14* z15* z16* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "linsegr"
                      [a dur2 b1* dur2* c3* rel4* z5* z6* z7* z8* z9* z10* z11* z12* z13* z14* z15* z16*]
                      *global*)]
    (new out-types ast)))

(s/fdef linsegr:k
  :args (s/cat :a valid-i? :dur2 valid-i? :b1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :c3* (s/? valid-i?*) :rel4* (s/? valid-i?*) :z5* (s/? valid-i?*) :z6* (s/? valid-i?*) :z7* (s/? valid-i?*) :z8* (s/? valid-i?*) :z9* (s/? valid-i?*) :z10* (s/? valid-i?*) :z11* (s/? valid-i?*) :z12* (s/? valid-i?*) :z13* (s/? valid-i?*) :z14* (s/? valid-i?*) :z15* (s/? valid-i?*) :z16* (s/? valid-i?*) ))
(stest/instrument `linsegr:k)

(defn moscil
  {:arglists '([kchn knum kvel kdur kpause])}
  [chn num vel dur pause]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "moscil"
                      [chn num vel dur pause]
                      *global*)]
    (new out-types ast)))

(s/fdef moscil
  :args (s/cat :chn valid-kr? :num valid-kr? :vel valid-kr? :dur valid-kr? :pause valid-kr? ))
(stest/instrument `moscil)

(defn chano
  {:arglists '([aval kchan] [kval kchan])}
  [val chan]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "chano"
                      [val chan]
                      *global*)]
    (new out-types ast)))

(s/fdef chano
  :args (s/alt
         :kk (s/cat :val valid-kr? :chan valid-kr? )
         :ak (s/cat :val valid-ar? :chan valid-kr? )
         ))
(stest/instrument `chano)

(defn moogvcf
  {:arglists '([asig xcutoff-frequency xresonance & iscale* iskip*])}
  [sig cutoff-frequency resonance & [ scale* skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "moogvcf"
                      [sig cutoff-frequency resonance scale* skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef moogvcf
  :args (s/cat :sig valid-ar? :cutoff-frequency valid-x? :resonance valid-x? :scale* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `moogvcf)

(defn svfilter
  {:arglists '([asig xcenter-frequency xq & iscale* iskip*])}
  [sig center-frequency q & [ scale* skip* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "svfilter"
                      [sig center-frequency q scale* skip*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef svfilter
  :args (s/cat :sig valid-ar? :center-frequency valid-x? :q valid-x? :scale* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `svfilter)

(defn ftsamplebank
  {:arglists '([SDirectory iFirstTableNumber iTrigger iSkipTime iFormat] [SDirectory kFirstTableNumber kTrigger kSkipTime kFormat kChannel])}
  [Directory FirstTableNumber Trigger SkipTime Format]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "ftsamplebank"
                      [Directory FirstTableNumber Trigger SkipTime Format]
                      *global*)]
    (new out-types ast)))

(s/fdef ftsamplebank
  :args (s/alt
         :Skkkkk (s/cat :Directory valid-S? :FirstTableNumber valid-kr? :Trigger valid-kr? :SkipTime valid-kr? :Format valid-kr? :Channel valid-kr? )
         :Siiii (s/cat :Directory valid-S? :FirstTableNumber valid-i? :Trigger valid-i? :SkipTime valid-i? :Format valid-i? )
         ))
(stest/instrument `ftsamplebank)

(defn ftsamplebank:i
  {:arglists '([SDirectory iFirstTableNumber iTrigger iSkipTime iFormat])}
  [Directory FirstTableNumber Trigger SkipTime Format]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "ftsamplebank"
                      [Directory FirstTableNumber Trigger SkipTime Format]
                      *global*)]
    (new out-types ast)))

(s/fdef ftsamplebank:i
  :args (s/cat :Directory valid-S? :FirstTableNumber valid-i? :Trigger valid-i? :SkipTime valid-i? :Format valid-i? ))
(stest/instrument `ftsamplebank:i)

(defn ftsamplebank:k
  {:arglists '([SDirectory kFirstTableNumber kTrigger kSkipTime kFormat kChannel])}
  [Directory FirstTableNumber Trigger SkipTime Format Channel]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "ftsamplebank"
                      [Directory FirstTableNumber Trigger SkipTime Format Channel]
                      *global*)]
    (new out-types ast)))

(s/fdef ftsamplebank:k
  :args (s/cat :Directory valid-S? :FirstTableNumber valid-kr? :Trigger valid-kr? :SkipTime valid-kr? :Format valid-kr? :Channel valid-kr? ))
(stest/instrument `ftsamplebank:k)

(defn eqfil
  {:arglists '([ain kcenter-frequency kbandwidth kgain & istor*])}
  [in center-frequency bandwidth gain & [ stor* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "eqfil"
                      [in center-frequency bandwidth gain stor*]
                      *global*)]
    (new out-types ast)))

(s/fdef eqfil
  :args (s/cat :in valid-ar? :center-frequency valid-kr? :bandwidth valid-kr? :gain valid-kr? :stor* (s/? valid-i?*) ))
(stest/instrument `eqfil)

(defn nchnls_hw
  {:arglists '()}
  []
  (let [out-types-quoted '[Variable Variable]
        out-types [Variable Variable]
        ast (ast-node out-types-quoted
                      "nchnls_hw"
                      []
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))


(defn readk
  {:arglists '([Sfilname iformat iprd] [ifilname iformat iprd])}
  [filname format prd]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "readk"
                      [filname format prd]
                      *global*)]
    (new out-types ast)))

(s/fdef readk
  :args (s/alt
         :iii (s/cat :filname valid-i? :format valid-i? :prd valid-i? )
         :Sii (s/cat :filname valid-S? :format valid-i? :prd valid-i? )
         ))
(stest/instrument `readk)

(defn dripwater
  {:arglists '([kamp idettack & inum* idamp* imaxshake* ifreq* ifreq1* ifreq1*])}
  [amp dettack & [ num* damp* maxshake* freq* freq1* freq1* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "dripwater"
                      [amp dettack num* damp* maxshake* freq* freq1* freq1*]
                      *global*)]
    (new out-types ast)))

(s/fdef dripwater
  :args (s/cat :amp valid-kr? :dettack valid-i? :num* (s/? valid-i?*) :damp* (s/? valid-i?*) :maxshake* (s/? valid-i?*) :freq* (s/? valid-i?*) :freq1* (s/? valid-i?*) :freq1* (s/? valid-i?*) ))
(stest/instrument `dripwater)

(defn midic14
  {:arglists '([ictlno1 ictlno2 imin imax & itable*] [ictlno1 ictlno2 kmin kmax & itable*])}
  [ctlno1 ctlno2 min max & [ table* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "midic14"
                      [ctlno1 ctlno2 min max table*]
                      *global*)]
    (new out-types ast)))

(s/fdef midic14
  :args (s/alt
         :iikki (s/cat :ctlno1 valid-i? :ctlno2 valid-i? :min valid-kr? :max valid-kr? :table* (s/? valid-i?*) )
         :iiiii (s/cat :ctlno1 valid-i? :ctlno2 valid-i? :min valid-i? :max valid-i? :table* (s/? valid-i?*) )
         ))
(stest/instrument `midic14)

(defn midic14:i
  {:arglists '([ictlno1 ictlno2 imin imax & itable*])}
  [ctlno1 ctlno2 min max & [ table* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "midic14"
                      [ctlno1 ctlno2 min max table*]
                      *global*)]
    (new out-types ast)))

(s/fdef midic14:i
  :args (s/cat :ctlno1 valid-i? :ctlno2 valid-i? :min valid-i? :max valid-i? :table* (s/? valid-i?*) ))
(stest/instrument `midic14:i)

(defn midic14:k
  {:arglists '([ictlno1 ictlno2 kmin kmax & itable*])}
  [ctlno1 ctlno2 min max & [ table* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "midic14"
                      [ctlno1 ctlno2 min max table*]
                      *global*)]
    (new out-types ast)))

(s/fdef midic14:k
  :args (s/cat :ctlno1 valid-i? :ctlno2 valid-i? :min valid-kr? :max valid-kr? :table* (s/? valid-i?*) ))
(stest/instrument `midic14:k)

(defn granule
  {:arglists '([xamp ivoice iratio imode ithd itable ipshift igskip igskip_os ilength kgap igap_os kgsize igsize_os iatt idec iseed & ipitch1* ipitch1* ipitch1* ipitch1* ifnenv*])}
  [amp voice ratio mode thd table pshift gskip gskip_os length gap gap_os gsize gsize_os att dec seed & [ pitch1* pitch1* pitch1* pitch1* fnenv* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "granule"
                      [amp voice ratio mode thd table pshift gskip gskip_os length gap gap_os gsize gsize_os att dec seed pitch1* pitch1* pitch1* pitch1* fnenv*]
                      *global*)]
    (new out-types ast)))

(s/fdef granule
  :args (s/cat :amp valid-x? :voice valid-i? :ratio valid-i? :mode valid-i? :thd valid-i? :table valid-i? :pshift valid-i? :gskip valid-i? :gskip_os valid-i? :length valid-i? :gap valid-kr? :gap_os valid-i? :gsize valid-kr? :gsize_os valid-i? :att valid-i? :dec valid-i? :seed valid-i? :pitch1* (s/? valid-i?*) :pitch1* (s/? valid-i?*) :pitch1* (s/? valid-i?*) :pitch1* (s/? valid-i?*) :fnenv* (s/? valid-i?*) ))
(stest/instrument `granule)

(defn linsegb
  {:arglists '([ia itim2 & ib1* itim2* ic3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*] [ia itim2 & ib1* itim2* ic3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a tim2 & [ b1* tim2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "linsegb"
                      [a tim2 b1* tim2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef linsegb
  :args (s/alt
         :iiiiiiiiiiiiiiiiii (s/cat :a valid-i? :tim2 valid-i? :b1* (s/? valid-i?*) :tim2* (s/? valid-i?*) :c3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) )
         ))
(stest/instrument `linsegb)

(defn linsegb:a
  {:arglists '([ia itim2 & ib1* itim2* ic3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a tim2 & [ b1* tim2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "linsegb"
                      [a tim2 b1* tim2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef linsegb:a
  :args (s/cat :a valid-i? :tim2 valid-i? :b1* (s/? valid-i?*) :tim2* (s/? valid-i?*) :c3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) ))
(stest/instrument `linsegb:a)

(defn linsegb:k
  {:arglists '([ia itim2 & ib1* itim2* ic3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a tim2 & [ b1* tim2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "linsegb"
                      [a tim2 b1* tim2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef linsegb:k
  :args (s/cat :a valid-i? :tim2 valid-i? :b1* (s/? valid-i?*) :tim2* (s/? valid-i?*) :c3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) ))
(stest/instrument `linsegb:k)

(defn strrindexk
  {:arglists '([Sarg1 Sarg2])}
  [arg1 arg2]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "strrindexk"
                      [arg1 arg2]
                      *global*)]
    (new out-types ast)))

(s/fdef strrindexk
  :args (s/cat :arg1 valid-S? :arg2 valid-S? ))
(stest/instrument `strrindexk)

(defn compilecsd
  {:arglists '([Sfilename])}
  [filename]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "compilecsd"
                      [filename]
                      *global*)]
    (new out-types ast)))

(s/fdef compilecsd
  :args (s/cat :filename valid-S? ))
(stest/instrument `compilecsd)

(defn exprandi
  {:arglists '([klambda xamp xcps] [klambda xamp xcps] [klambda xamp xcps])}
  [lambda amp cps]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "exprandi"
                      [lambda amp cps]
                      *global*)]
    (new out-types ast)))

(s/fdef exprandi
  :args (s/alt
         :kxx (s/cat :lambda valid-kr? :amp valid-x? :cps valid-x? )
         ))
(stest/instrument `exprandi)

(defn exprandi:a
  {:arglists '([klambda xamp xcps])}
  [lambda amp cps]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "exprandi"
                      [lambda amp cps]
                      *global*)]
    (new out-types ast)))

(s/fdef exprandi:a
  :args (s/cat :lambda valid-kr? :amp valid-x? :cps valid-x? ))
(stest/instrument `exprandi:a)

(defn exprandi:i
  {:arglists '([klambda xamp xcps])}
  [lambda amp cps]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "exprandi"
                      [lambda amp cps]
                      *global*)]
    (new out-types ast)))

(s/fdef exprandi:i
  :args (s/cat :lambda valid-kr? :amp valid-x? :cps valid-x? ))
(stest/instrument `exprandi:i)

(defn exprandi:k
  {:arglists '([klambda xamp xcps])}
  [lambda amp cps]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "exprandi"
                      [lambda amp cps]
                      *global*)]
    (new out-types ast)))

(s/fdef exprandi:k
  :args (s/cat :lambda valid-kr? :amp valid-x? :cps valid-x? ))
(stest/instrument `exprandi:k)

(defn pvsout
  {:arglists '([fsig kchan])}
  [sig chan]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "pvsout"
                      [sig chan]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsout
  :args (s/cat :sig valid-f? :chan valid-kr? ))
(stest/instrument `pvsout)

(defn filenchnls
  {:arglists '([Sfilcod & iallowraw*] [ifilcod & iallowraw*])}
  [filcod & [ allowraw* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "filenchnls"
                      [filcod allowraw*]
                      *global*)]
    (new out-types ast)))

(s/fdef filenchnls
  :args (s/alt
         :ii (s/cat :filcod valid-i? :allowraw* (s/? valid-i?*) )
         :Si (s/cat :filcod valid-S? :allowraw* (s/? valid-i?*) )
         ))
(stest/instrument `filenchnls)

(defn outch
  {:arglists '([& karg1* aarg2* karg3* aarg4* karg5* aarg6* karg7* aarg8* karg9* aarg10* karg11* aarg12* karg13* aarg14* karg15* aarg16*])}
  [& [ arg1* arg2* arg3* arg4* arg5* arg6* arg7* arg8* arg9* arg10* arg11* arg12* arg13* arg14* arg15* arg16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outch"
                      [arg1* arg2* arg3* arg4* arg5* arg6* arg7* arg8* arg9* arg10* arg11* arg12* arg13* arg14* arg15* arg16*]
                      *global*)]
    (new out-types ast)))

(s/fdef outch
  :args (s/cat :arg1* (s/? valid-kr?*) :arg2* (s/? valid-ar?*) :arg3* (s/? valid-kr?*) :arg4* (s/? valid-ar?*) :arg5* (s/? valid-kr?*) :arg6* (s/? valid-ar?*) :arg7* (s/? valid-kr?*) :arg8* (s/? valid-ar?*) :arg9* (s/? valid-kr?*) :arg10* (s/? valid-ar?*) :arg11* (s/? valid-kr?*) :arg12* (s/? valid-ar?*) :arg13* (s/? valid-kr?*) :arg14* (s/? valid-ar?*) :arg15* (s/? valid-kr?*) :arg16* (s/? valid-ar?*) ))
(stest/instrument `outch)

(defn init:SArr
  {:arglists '([& isize1* ival2* ival3* ival4* ival5* ival6* ival7* ival8* ival9* ival10* ival11* ival12* ival13* ival14* ival15* ival16*])}
  [& [ size1* val2* val3* val4* val5* val6* val7* val8* val9* val10* val11* val12* val13* val14* val15* val16* ]]
  (let [out-types-quoted 'StringArray
        out-types StringArray
        ast (ast-node out-types-quoted
                      "init"
                      [size1* val2* val3* val4* val5* val6* val7* val8* val9* val10* val11* val12* val13* val14* val15* val16*]
                      *global*)]
    (new out-types ast)))

(s/fdef init:SArr
  :args (s/cat :size1* (s/? valid-i?*) :val2* (s/? valid-i?*) :val3* (s/? valid-i?*) :val4* (s/? valid-i?*) :val5* (s/? valid-i?*) :val6* (s/? valid-i?*) :val7* (s/? valid-i?*) :val8* (s/? valid-i?*) :val9* (s/? valid-i?*) :val10* (s/? valid-i?*) :val11* (s/? valid-i?*) :val12* (s/? valid-i?*) :val13* (s/? valid-i?*) :val14* (s/? valid-i?*) :val15* (s/? valid-i?*) :val16* (s/? valid-i?*) ))
(stest/instrument `init:SArr)

(defn init:iArr
  {:arglists '([& isize1* ival2* ival3* ival4* ival5* ival6* ival7* ival8* ival9* ival10* ival11* ival12* ival13* ival14* ival15* ival16*])}
  [& [ size1* val2* val3* val4* val5* val6* val7* val8* val9* val10* val11* val12* val13* val14* val15* val16* ]]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "init"
                      [size1* val2* val3* val4* val5* val6* val7* val8* val9* val10* val11* val12* val13* val14* val15* val16*]
                      *global*)]
    (new out-types ast)))

(s/fdef init:iArr
  :args (s/cat :size1* (s/? valid-i?*) :val2* (s/? valid-i?*) :val3* (s/? valid-i?*) :val4* (s/? valid-i?*) :val5* (s/? valid-i?*) :val6* (s/? valid-i?*) :val7* (s/? valid-i?*) :val8* (s/? valid-i?*) :val9* (s/? valid-i?*) :val10* (s/? valid-i?*) :val11* (s/? valid-i?*) :val12* (s/? valid-i?*) :val13* (s/? valid-i?*) :val14* (s/? valid-i?*) :val15* (s/? valid-i?*) :val16* (s/? valid-i?*) ))
(stest/instrument `init:iArr)

(defn init:f
  {:arglists '([fsize])}
  [size]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "init"
                      [size]
                      *global*)]
    (new out-types ast)))

(s/fdef init:f
  :args (s/cat :size valid-f? ))
(stest/instrument `init:f)

(defn init:a
  {:arglists '([asize])}
  [size]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "init"
                      [size]
                      *global*)]
    (new out-types ast)))

(s/fdef init:a
  :args (s/cat :size valid-ar? ))
(stest/instrument `init:a)

(defn init:S
  {:arglists '([Ssize])}
  [size]
  (let [out-types-quoted 'String
        out-types String
        ast (ast-node out-types-quoted
                      "init"
                      [size]
                      *global*)]
    (new out-types ast)))

(s/fdef init:S
  :args (s/cat :size valid-S? ))
(stest/instrument `init:S)

(defn init
  {:arglists '([& isize1* ival2* ival3* ival4* ival5* ival6* ival7* ival8* ival9* ival10* ival11* ival12* ival13* ival14* ival15* ival16*] [& isize1* ival2* ival3* ival4* ival5* ival6* ival7* ival8* ival9* ival10* ival11* ival12* ival13* ival14* ival15* ival16*] [& isize1* ival2* ival3* ival4* ival5* ival6* ival7* ival8* ival9* ival10* ival11* ival12* ival13* ival14* ival15* ival16*] [isize] [Ssize] [fsize] [asize] [ksize])}
  [& [ size1* val2* val3* val4* val5* val6* val7* val8* val9* val10* val11* val12* val13* val14* val15* val16* ]]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "init"
                      [size1* val2* val3* val4* val5* val6* val7* val8* val9* val10* val11* val12* val13* val14* val15* val16*]
                      *global*)]
    (new out-types ast)))

(s/fdef init
  :args (s/alt
         :k (s/cat :size valid-kr? )
         :a (s/cat :size valid-ar? )
         :f (s/cat :size valid-f? )
         :S (s/cat :size valid-S? )
         :i (s/cat :size valid-i? )
         :iiiiiiiiiiiiiiii (s/cat :size1* (s/? valid-i?*) :val2* (s/? valid-i?*) :val3* (s/? valid-i?*) :val4* (s/? valid-i?*) :val5* (s/? valid-i?*) :val6* (s/? valid-i?*) :val7* (s/? valid-i?*) :val8* (s/? valid-i?*) :val9* (s/? valid-i?*) :val10* (s/? valid-i?*) :val11* (s/? valid-i?*) :val12* (s/? valid-i?*) :val13* (s/? valid-i?*) :val14* (s/? valid-i?*) :val15* (s/? valid-i?*) :val16* (s/? valid-i?*) )
         ))
(stest/instrument `init)

(defn init:i
  {:arglists '([isize])}
  [size]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "init"
                      [size]
                      *global*)]
    (new out-types ast)))

(s/fdef init:i
  :args (s/cat :size valid-i? ))
(stest/instrument `init:i)

(defn init:k
  {:arglists '([ksize])}
  [size]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "init"
                      [size]
                      *global*)]
    (new out-types ast)))

(s/fdef init:k
  :args (s/cat :size valid-kr? ))
(stest/instrument `init:k)

(defn init:aArr
  {:arglists '([& isize1* ival2* ival3* ival4* ival5* ival6* ival7* ival8* ival9* ival10* ival11* ival12* ival13* ival14* ival15* ival16*])}
  [& [ size1* val2* val3* val4* val5* val6* val7* val8* val9* val10* val11* val12* val13* val14* val15* val16* ]]
  (let [out-types-quoted 'AudioArray
        out-types AudioArray
        ast (ast-node out-types-quoted
                      "init"
                      [size1* val2* val3* val4* val5* val6* val7* val8* val9* val10* val11* val12* val13* val14* val15* val16*]
                      *global*)]
    (new out-types ast)))

(s/fdef init:aArr
  :args (s/cat :size1* (s/? valid-i?*) :val2* (s/? valid-i?*) :val3* (s/? valid-i?*) :val4* (s/? valid-i?*) :val5* (s/? valid-i?*) :val6* (s/? valid-i?*) :val7* (s/? valid-i?*) :val8* (s/? valid-i?*) :val9* (s/? valid-i?*) :val10* (s/? valid-i?*) :val11* (s/? valid-i?*) :val12* (s/? valid-i?*) :val13* (s/? valid-i?*) :val14* (s/? valid-i?*) :val15* (s/? valid-i?*) :val16* (s/? valid-i?*) ))
(stest/instrument `init:aArr)

(defn pvsmix
  {:arglists '([fsigin1 fsigin2])}
  [sigin1 sigin2]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvsmix"
                      [sigin1 sigin2]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsmix
  :args (s/cat :sigin1 valid-f? :sigin2 valid-f? ))
(stest/instrument `pvsmix)

(defn logcurve
  {:arglists '([kindex ksteepness])}
  [index steepness]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "logcurve"
                      [index steepness]
                      *global*)]
    (new out-types ast)))

(s/fdef logcurve
  :args (s/cat :index valid-kr? :steepness valid-kr? ))
(stest/instrument `logcurve)

(defn in32
  {:arglists '()}
  []
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "in32"
                      []
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))


(defn cauchy
  {:arglists '([kalpha] [kalpha] [kalpha])}
  [alpha]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "cauchy"
                      [alpha]
                      *global*)]
    (new out-types ast)))

(s/fdef cauchy
  :args (s/alt
         :k (s/cat :alpha valid-kr? )
         ))
(stest/instrument `cauchy)

(defn cauchy:a
  {:arglists '([kalpha])}
  [alpha]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "cauchy"
                      [alpha]
                      *global*)]
    (new out-types ast)))

(s/fdef cauchy:a
  :args (s/cat :alpha valid-kr? ))
(stest/instrument `cauchy:a)

(defn cauchy:i
  {:arglists '([kalpha])}
  [alpha]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "cauchy"
                      [alpha]
                      *global*)]
    (new out-types ast)))

(s/fdef cauchy:i
  :args (s/cat :alpha valid-kr? ))
(stest/instrument `cauchy:i)

(defn cauchy:k
  {:arglists '([kalpha])}
  [alpha]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "cauchy"
                      [alpha]
                      *global*)]
    (new out-types ast)))

(s/fdef cauchy:k
  :args (s/cat :alpha valid-kr? ))
(stest/instrument `cauchy:k)

(defn vexpv
  {:arglists '([ifn1 ifn2 kelements & kdstoffset* ksrcoffset* kverbose*])}
  [fn1 fn2 elements & [ dstoffset* srcoffset* verbose* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vexpv"
                      [fn1 fn2 elements dstoffset* srcoffset* verbose*]
                      *global*)]
    (new out-types ast)))

(s/fdef vexpv
  :args (s/cat :fn1 valid-i? :fn2 valid-i? :elements valid-kr? :dstoffset* (s/? valid-kr?*) :srcoffset* (s/? valid-kr?*) :verbose* (s/? valid-kr?*) ))
(stest/instrument `vexpv)

(defn midiout_i
  {:arglists '([istatus ichan idata3 idata4])}
  [status chan data3 data4]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "midiout_i"
                      [status chan data3 data4]
                      *global*)]
    (new out-types ast)))

(s/fdef midiout_i
  :args (s/cat :status valid-i? :chan valid-i? :data3 valid-i? :data4 valid-i? ))
(stest/instrument `midiout_i)

(defn fractalnoise
  {:arglists '([kamp kbeta])}
  [amp beta]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "fractalnoise"
                      [amp beta]
                      *global*)]
    (new out-types ast)))

(s/fdef fractalnoise
  :args (s/cat :amp valid-kr? :beta valid-kr? ))
(stest/instrument `fractalnoise)

(defn strtodk
  {:arglists '([Sindex])}
  [index]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "strtodk"
                      [index]
                      *global*)]
    (new out-types ast)))

(s/fdef strtodk
  :args (s/cat :index valid-S? ))
(stest/instrument `strtodk)

(defn harmon2
  {:arglists '([asig koct kfrq3 kfrq4 icpsmode ilowest & ipolarity*])}
  [sig oct frq3 frq4 cpsmode lowest & [ polarity* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "harmon2"
                      [sig oct frq3 frq4 cpsmode lowest polarity*]
                      *global*)]
    (new out-types ast)))

(s/fdef harmon2
  :args (s/cat :sig valid-ar? :oct valid-kr? :frq3 valid-kr? :frq4 valid-kr? :cpsmode valid-i? :lowest valid-i? :polarity* (s/? valid-i?*) ))
(stest/instrument `harmon2)

(defn zawm
  {:arglists '([asig kindex & imix*])}
  [sig index & [ mix* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "zawm"
                      [sig index mix*]
                      *global*)]
    (new out-types ast)))

(s/fdef zawm
  :args (s/cat :sig valid-ar? :index valid-kr? :mix* (s/? valid-i?*) ))
(stest/instrument `zawm)

(defn mp3scal
  {:arglists '([Sfile ktimescal kpitch kamp & iskip* ifftsize* idecim* klock* klock*])}
  [file timescal pitch amp & [ skip* fftsize* decim* lock* lock* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal ControlSignal]
        out-types [AudioSignal AudioSignal ControlSignal]
        ast (ast-node out-types-quoted
                      "mp3scal"
                      [file timescal pitch amp skip* fftsize* decim* lock* lock*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef mp3scal
  :args (s/cat :file valid-S? :timescal valid-kr? :pitch valid-kr? :amp valid-kr? :skip* (s/? valid-i?*) :fftsize* (s/? valid-i?*) :decim* (s/? valid-i?*) :lock* (s/? valid-kr?*) :lock* (s/? valid-kr?*) ))
(stest/instrument `mp3scal)

(defn outc
  {:arglists '([& asig1* asig2* asig3* asig4* asig5* asig6* asig7* asig8* asig9* asig10* asig11* asig12* asig13* asig14* asig15* asig16* asig17* asig18* asig19* asig20* asig21* asig22* asig23* asig24* asig25* asig26* asig27* asig28* asig29* asig30* asig31* asig32*])}
  [& [ sig1* sig2* sig3* sig4* sig5* sig6* sig7* sig8* sig9* sig10* sig11* sig12* sig13* sig14* sig15* sig16* sig17* sig18* sig19* sig20* sig21* sig22* sig23* sig24* sig25* sig26* sig27* sig28* sig29* sig30* sig31* sig32* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outc"
                      [sig1* sig2* sig3* sig4* sig5* sig6* sig7* sig8* sig9* sig10* sig11* sig12* sig13* sig14* sig15* sig16* sig17* sig18* sig19* sig20* sig21* sig22* sig23* sig24* sig25* sig26* sig27* sig28* sig29* sig30* sig31* sig32*]
                      *global*)]
    (new out-types ast)))

(s/fdef outc
  :args (s/cat :sig1* (s/? valid-ar?*) :sig2* (s/? valid-ar?*) :sig3* (s/? valid-ar?*) :sig4* (s/? valid-ar?*) :sig5* (s/? valid-ar?*) :sig6* (s/? valid-ar?*) :sig7* (s/? valid-ar?*) :sig8* (s/? valid-ar?*) :sig9* (s/? valid-ar?*) :sig10* (s/? valid-ar?*) :sig11* (s/? valid-ar?*) :sig12* (s/? valid-ar?*) :sig13* (s/? valid-ar?*) :sig14* (s/? valid-ar?*) :sig15* (s/? valid-ar?*) :sig16* (s/? valid-ar?*) :sig17* (s/? valid-ar?*) :sig18* (s/? valid-ar?*) :sig19* (s/? valid-ar?*) :sig20* (s/? valid-ar?*) :sig21* (s/? valid-ar?*) :sig22* (s/? valid-ar?*) :sig23* (s/? valid-ar?*) :sig24* (s/? valid-ar?*) :sig25* (s/? valid-ar?*) :sig26* (s/? valid-ar?*) :sig27* (s/? valid-ar?*) :sig28* (s/? valid-ar?*) :sig29* (s/? valid-ar?*) :sig30* (s/? valid-ar?*) :sig31* (s/? valid-ar?*) :sig32* (s/? valid-ar?*) ))
(stest/instrument `outc)

(defn polyaft
  {:arglists '([inote & ilow* ihigh*] [inote & ilow* ihigh*])}
  [note & [ low* high* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "polyaft"
                      [note low* high*]
                      *global*)]
    (new out-types ast)))

(s/fdef polyaft
  :args (s/alt
         :iii (s/cat :note valid-i? :low* (s/? valid-i?*) :high* (s/? valid-i?*) )
         ))
(stest/instrument `polyaft)

(defn polyaft:i
  {:arglists '([inote & ilow* ihigh*])}
  [note & [ low* high* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "polyaft"
                      [note low* high*]
                      *global*)]
    (new out-types ast)))

(s/fdef polyaft:i
  :args (s/cat :note valid-i? :low* (s/? valid-i?*) :high* (s/? valid-i?*) ))
(stest/instrument `polyaft:i)

(defn polyaft:k
  {:arglists '([inote & ilow* ihigh*])}
  [note & [ low* high* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "polyaft"
                      [note low* high*]
                      *global*)]
    (new out-types ast)))

(s/fdef polyaft:k
  :args (s/cat :note valid-i? :low* (s/? valid-i?*) :high* (s/? valid-i?*) ))
(stest/instrument `polyaft:k)

(defn outq1
  {:arglists '([asig])}
  [sig]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outq1"
                      [sig]
                      *global*)]
    (new out-types ast)))

(s/fdef outq1
  :args (s/cat :sig valid-ar? ))
(stest/instrument `outq1)

(defn vincr
  {:arglists '([accum aincr])}
  [ccum incr]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vincr"
                      [ccum incr]
                      *global*)]
    (new out-types ast)))

(s/fdef vincr
  :args (s/cat :ccum valid-ar? :incr valid-ar? ))
(stest/instrument `vincr)

(defn dct
  {:arglists '([iinArr] [kinArr])}
  [in]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "dct"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef dct
  :args (s/alt
         :kArr (s/cat :in valid-kArr? )
         :iArr (s/cat :in valid-iArr? )
         ))
(stest/instrument `dct)

(defn dct:iArr
  {:arglists '([iinArr])}
  [in]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "dct"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef dct:iArr
  :args (s/cat :in valid-iArr? ))
(stest/instrument `dct:iArr)

(defn dct:kArr
  {:arglists '([kinArr])}
  [in]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "dct"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef dct:kArr
  :args (s/cat :in valid-kArr? ))
(stest/instrument `dct:kArr)

(defn bpf
  {:arglists '([kx kx2 ky3 kx4 kxn kyn kyn] [kx kx2 ky3 kx4 kxn kyn kyn kyn kyn] [kx kx2 ky3 kx4 kxn kyn kyn kyn kyn kyn kyn])}
  [x x2 y3 x4 xn yn yn]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "bpf"
                      [x x2 y3 x4 xn yn yn]
                      *global*)]
    (new out-types ast)))

(s/fdef bpf
  :args (s/alt
         :kkkkkkkkkkk (s/cat :x valid-kr? :x2 valid-kr? :y3 valid-kr? :x4 valid-kr? :xn valid-kr? :yn valid-kr? :yn valid-kr? :yn valid-kr? :yn valid-kr? :yn valid-kr? :yn valid-kr? )
         :kkkkkkkkk (s/cat :x valid-kr? :x2 valid-kr? :y3 valid-kr? :x4 valid-kr? :xn valid-kr? :yn valid-kr? :yn valid-kr? :yn valid-kr? :yn valid-kr? )
         :kkkkkkk (s/cat :x valid-kr? :x2 valid-kr? :y3 valid-kr? :x4 valid-kr? :xn valid-kr? :yn valid-kr? :yn valid-kr? )
         ))
(stest/instrument `bpf)

(defn trlowest
  {:arglists '([fin1 kscal])}
  [in1 scal]
  (let [out-types-quoted '[FrequencySignal ControlSignal ControlSignal]
        out-types [FrequencySignal ControlSignal ControlSignal]
        ast (ast-node out-types-quoted
                      "trlowest"
                      [in1 scal]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef trlowest
  :args (s/cat :in1 valid-f? :scal valid-kr? ))
(stest/instrument `trlowest)

(defn tablew
  {:arglists '([asig aindex itable & ixmode* ixoff* iwgmode*] [isig iindex itable & ixmode* ixoff* iwgmode*] [ksig kindex itable & ixmode* ixoff* iwgmode*])}
  [sig index table & [ xmode* xoff* wgmode* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "tablew"
                      [sig index table xmode* xoff* wgmode*]
                      *global*)]
    (new out-types ast)))

(s/fdef tablew
  :args (s/alt
         :kkiiii (s/cat :sig valid-kr? :index valid-kr? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wgmode* (s/? valid-i?*) )
         :iiiiii (s/cat :sig valid-i? :index valid-i? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wgmode* (s/? valid-i?*) )
         :aaiiii (s/cat :sig valid-ar? :index valid-ar? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wgmode* (s/? valid-i?*) )
         ))
(stest/instrument `tablew)

(defn changed
  {:arglists '([Svar1])}
  [var1]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "changed"
                      [var1]
                      *global*)]
    (new out-types ast)))

(s/fdef changed
  :args (s/cat :var1 valid-S? ))
(stest/instrument `changed)

(defn nestedap
  {:arglists '([asig imode imaxdel idel4 igain5 & idel1* igain1* idel1* igain1* istor*])}
  [sig mode maxdel del4 gain5 & [ del1* gain1* del1* gain1* stor* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "nestedap"
                      [sig mode maxdel del4 gain5 del1* gain1* del1* gain1* stor*]
                      *global*)]
    (new out-types ast)))

(s/fdef nestedap
  :args (s/cat :sig valid-ar? :mode valid-i? :maxdel valid-i? :del4 valid-i? :gain5 valid-i? :del1* (s/? valid-i?*) :gain1* (s/? valid-i?*) :del1* (s/? valid-i?*) :gain1* (s/? valid-i?*) :stor* (s/? valid-i?*) ))
(stest/instrument `nestedap)

(defn strcmpk
  {:arglists '([Sarg1 Sarg2])}
  [arg1 arg2]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "strcmpk"
                      [arg1 arg2]
                      *global*)]
    (new out-types ast)))

(s/fdef strcmpk
  :args (s/cat :arg1 valid-S? :arg2 valid-S? ))
(stest/instrument `strcmpk)

(defn expsega
  {:arglists '([ia idur2 & ib1* idur2* ic3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a dur2 & [ b1* dur2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "expsega"
                      [a dur2 b1* dur2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef expsega
  :args (s/cat :a valid-i? :dur2 valid-i? :b1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :c3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) ))
(stest/instrument `expsega)

(defn vtabi
  {:arglists '([iindex itable & iout1* iout2* iout3* ioutN4* ioutN5* ioutN6* ioutN7* ioutN8* ioutN9* ioutN10* ioutN11* ioutN12* ioutN13* ioutN14* ioutN15* ioutN16*])}
  [index table & [ out1* out2* out3* outN4* outN5* outN6* outN7* outN8* outN9* outN10* outN11* outN12* outN13* outN14* outN15* outN16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vtabi"
                      [index table out1* out2* out3* outN4* outN5* outN6* outN7* outN8* outN9* outN10* outN11* outN12* outN13* outN14* outN15* outN16*]
                      *global*)]
    (new out-types ast)))

(s/fdef vtabi
  :args (s/cat :index valid-i? :table valid-i? :out1* (s/? valid-i?*) :out2* (s/? valid-i?*) :out3* (s/? valid-i?*) :outN4* (s/? valid-i?*) :outN5* (s/? valid-i?*) :outN6* (s/? valid-i?*) :outN7* (s/? valid-i?*) :outN8* (s/? valid-i?*) :outN9* (s/? valid-i?*) :outN10* (s/? valid-i?*) :outN11* (s/? valid-i?*) :outN12* (s/? valid-i?*) :outN13* (s/? valid-i?*) :outN14* (s/? valid-i?*) :outN15* (s/? valid-i?*) :outN16* (s/? valid-i?*) ))
(stest/instrument `vtabi)

(defn unirand
  {:arglists '([krange] [krange] [krange])}
  [range]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "unirand"
                      [range]
                      *global*)]
    (new out-types ast)))

(s/fdef unirand
  :args (s/alt
         :k (s/cat :range valid-kr? )
         ))
(stest/instrument `unirand)

(defn unirand:a
  {:arglists '([krange])}
  [range]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "unirand"
                      [range]
                      *global*)]
    (new out-types ast)))

(s/fdef unirand:a
  :args (s/cat :range valid-kr? ))
(stest/instrument `unirand:a)

(defn unirand:i
  {:arglists '([krange])}
  [range]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "unirand"
                      [range]
                      *global*)]
    (new out-types ast)))

(s/fdef unirand:i
  :args (s/cat :range valid-kr? ))
(stest/instrument `unirand:i)

(defn unirand:k
  {:arglists '([krange])}
  [range]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "unirand"
                      [range]
                      *global*)]
    (new out-types ast)))

(s/fdef unirand:k
  :args (s/cat :range valid-kr? ))
(stest/instrument `unirand:k)

(defn mvclpf4
  {:arglists '([ain acenter-frequency aresonance & istor*] [ain acenter-frequency kresonance & istor*] [ain kcenter-frequency aresonance & istor*] [ain kcenter-frequency kresonance & istor*])}
  [in center-frequency resonance & [ stor* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "mvclpf4"
                      [in center-frequency resonance stor*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef mvclpf4
  :args (s/alt
         :akki (s/cat :in valid-ar? :center-frequency valid-kr? :resonance valid-kr? :stor* (s/? valid-i?*) )
         :akai (s/cat :in valid-ar? :center-frequency valid-kr? :resonance valid-ar? :stor* (s/? valid-i?*) )
         :aaki (s/cat :in valid-ar? :center-frequency valid-ar? :resonance valid-kr? :stor* (s/? valid-i?*) )
         :aaai (s/cat :in valid-ar? :center-frequency valid-ar? :resonance valid-ar? :stor* (s/? valid-i?*) )
         ))
(stest/instrument `mvclpf4)

(defn pchtom
  {:arglists '([ipch] [kpch])}
  [pch]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "pchtom"
                      [pch]
                      *global*)]
    (new out-types ast)))

(s/fdef pchtom
  :args (s/alt
         :k (s/cat :pch valid-kr? )
         :i (s/cat :pch valid-i? )
         ))
(stest/instrument `pchtom)

(defn pchtom:i
  {:arglists '([ipch])}
  [pch]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "pchtom"
                      [pch]
                      *global*)]
    (new out-types ast)))

(s/fdef pchtom:i
  :args (s/cat :pch valid-i? ))
(stest/instrument `pchtom:i)

(defn pchtom:k
  {:arglists '([kpch])}
  [pch]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "pchtom"
                      [pch]
                      *global*)]
    (new out-types ast)))

(s/fdef pchtom:k
  :args (s/cat :pch valid-kr? ))
(stest/instrument `pchtom:k)

(defn r2c
  {:arglists '([iinArr] [kinArr])}
  [in]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "r2c"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef r2c
  :args (s/alt
         :kArr (s/cat :in valid-kArr? )
         :iArr (s/cat :in valid-iArr? )
         ))
(stest/instrument `r2c)

(defn r2c:iArr
  {:arglists '([iinArr])}
  [in]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "r2c"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef r2c:iArr
  :args (s/cat :in valid-iArr? ))
(stest/instrument `r2c:iArr)

(defn r2c:kArr
  {:arglists '([kinArr])}
  [in]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "r2c"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef r2c:kArr
  :args (s/cat :in valid-kArr? ))
(stest/instrument `r2c:kArr)

(defn gainslider
  {:arglists '([kindex])}
  [index]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "gainslider"
                      [index]
                      *global*)]
    (new out-types ast)))

(s/fdef gainslider
  :args (s/cat :index valid-kr? ))
(stest/instrument `gainslider)

(defn moogladder2
  {:arglists '([ain acenter-frequency aresonance & istor*] [ain acenter-frequency kresonance & istor*] [ain kcenter-frequency aresonance & istor*] [ain kcenter-frequency kresonance & istor*])}
  [in center-frequency resonance & [ stor* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "moogladder2"
                      [in center-frequency resonance stor*]
                      *global*)]
    (new out-types ast)))

(s/fdef moogladder2
  :args (s/alt
         :akki (s/cat :in valid-ar? :center-frequency valid-kr? :resonance valid-kr? :stor* (s/? valid-i?*) )
         :akai (s/cat :in valid-ar? :center-frequency valid-kr? :resonance valid-ar? :stor* (s/? valid-i?*) )
         :aaki (s/cat :in valid-ar? :center-frequency valid-ar? :resonance valid-kr? :stor* (s/? valid-i?*) )
         :aaai (s/cat :in valid-ar? :center-frequency valid-ar? :resonance valid-ar? :stor* (s/? valid-i?*) )
         ))
(stest/instrument `moogladder2)

(defn lpshold
  {:arglists '([kfreq ktrig iphase & ktime1* kvalue2* kvalue3* ktime4* kvalue5* ktime6* ktime7* ktime8* ktime9* ktime10* ktime11* ktime12* ktime13* ktime14* ktime15* ktime16*])}
  [freq trig phase & [ time1* value2* value3* time4* value5* time6* time7* time8* time9* time10* time11* time12* time13* time14* time15* time16* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "lpshold"
                      [freq trig phase time1* value2* value3* time4* value5* time6* time7* time8* time9* time10* time11* time12* time13* time14* time15* time16*]
                      *global*)]
    (new out-types ast)))

(s/fdef lpshold
  :args (s/cat :freq valid-kr? :trig valid-kr? :phase valid-i? :time1* (s/? valid-kr?*) :value2* (s/? valid-kr?*) :value3* (s/? valid-kr?*) :time4* (s/? valid-kr?*) :value5* (s/? valid-kr?*) :time6* (s/? valid-kr?*) :time7* (s/? valid-kr?*) :time8* (s/? valid-kr?*) :time9* (s/? valid-kr?*) :time10* (s/? valid-kr?*) :time11* (s/? valid-kr?*) :time12* (s/? valid-kr?*) :time13* (s/? valid-kr?*) :time14* (s/? valid-kr?*) :time15* (s/? valid-kr?*) :time16* (s/? valid-kr?*) ))
(stest/instrument `lpshold)

(defn printks2
  {:arglists '([Sstring kval])}
  [string val]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "printks2"
                      [string val]
                      *global*)]
    (new out-types ast)))

(s/fdef printks2
  :args (s/cat :string valid-S? :val valid-kr? ))
(stest/instrument `printks2)

(defn MixerSetLevel_i
  {:arglists '([isend ibuss igain])}
  [send buss gain]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "MixerSetLevel_i"
                      [send buss gain]
                      *global*)]
    (new out-types ast)))

(s/fdef MixerSetLevel_i
  :args (s/cat :send valid-i? :buss valid-i? :gain valid-i? ))
(stest/instrument `MixerSetLevel_i)

(defn K35_lpf
  {:arglists '([ain xcenter-frequency xQ & knlp* ksaturation* istor*])}
  [in center-frequency Q & [ nlp* saturation* stor* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "K35_lpf"
                      [in center-frequency Q nlp* saturation* stor*]
                      *global*)]
    (new out-types ast)))

(s/fdef K35_lpf
  :args (s/cat :in valid-ar? :center-frequency valid-x? :Q valid-x? :nlp* (s/? valid-kr?*) :saturation* (s/? valid-kr?*) :stor* (s/? valid-i?*) ))
(stest/instrument `K35_lpf)

(defn tablecopy
  {:arglists '([kdft ksft])}
  [dft sft]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "tablecopy"
                      [dft sft]
                      *global*)]
    (new out-types ast)))

(s/fdef tablecopy
  :args (s/cat :dft valid-kr? :sft valid-kr? ))
(stest/instrument `tablecopy)

(defn adsynt
  {:arglists '([kamp kcps iwfn ifreqfn iampfn icnt & iphase*])}
  [amp cps wfn freqfn ampfn cnt & [ phase* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "adsynt"
                      [amp cps wfn freqfn ampfn cnt phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef adsynt
  :args (s/cat :amp valid-kr? :cps valid-kr? :wfn valid-i? :freqfn valid-i? :ampfn valid-i? :cnt valid-i? :phase* (s/? valid-i?*) ))
(stest/instrument `adsynt)

(defn print
  {:arglists '([& iarg1* iarg2* iarg3* iarg4* iarg5* iarg6* iarg7* iarg8* iarg9* iarg10* iarg11* iarg12* iarg13* iarg14* iarg15* iarg16*])}
  [& [ arg1* arg2* arg3* arg4* arg5* arg6* arg7* arg8* arg9* arg10* arg11* arg12* arg13* arg14* arg15* arg16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "print"
                      [arg1* arg2* arg3* arg4* arg5* arg6* arg7* arg8* arg9* arg10* arg11* arg12* arg13* arg14* arg15* arg16*]
                      *global*)]
    (new out-types ast)))

(s/fdef print
  :args (s/cat :arg1* (s/? valid-i?*) :arg2* (s/? valid-i?*) :arg3* (s/? valid-i?*) :arg4* (s/? valid-i?*) :arg5* (s/? valid-i?*) :arg6* (s/? valid-i?*) :arg7* (s/? valid-i?*) :arg8* (s/? valid-i?*) :arg9* (s/? valid-i?*) :arg10* (s/? valid-i?*) :arg11* (s/? valid-i?*) :arg12* (s/? valid-i?*) :arg13* (s/? valid-i?*) :arg14* (s/? valid-i?*) :arg15* (s/? valid-i?*) :arg16* (s/? valid-i?*) ))
(stest/instrument `print)

(defn spdist
  {:arglists '([itable ktime kx ky])}
  [table time x y]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "spdist"
                      [table time x y]
                      *global*)]
    (new out-types ast)))

(s/fdef spdist
  :args (s/cat :table valid-i? :time valid-kr? :x valid-kr? :y valid-kr? ))
(stest/instrument `spdist)

(defn cpsxpch
  {:arglists '([ipch iequal irepeat ibase])}
  [pch equal repeat base]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "cpsxpch"
                      [pch equal repeat base]
                      *global*)]
    (new out-types ast)))

(s/fdef cpsxpch
  :args (s/cat :pch valid-i? :equal valid-i? :repeat valid-i? :base valid-i? ))
(stest/instrument `cpsxpch)

(defn date
  {:arglists '( )}
  []
  (let [out-types-quoted '[Variable ]
        out-types [Variable ]
        ast (ast-node out-types-quoted
                      "date"
                      []
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))


(defn display
  {:arglists '([xsig iprd & inprds* iwtflg*])}
  [sig prd & [ nprds* wtflg* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "display"
                      [sig prd nprds* wtflg*]
                      *global*)]
    (new out-types ast)))

(s/fdef display
  :args (s/cat :sig valid-x? :prd valid-i? :nprds* (s/? valid-i?*) :wtflg* (s/? valid-i?*) ))
(stest/instrument `display)

(defn osciln
  {:arglists '([kamp ifrq itable itimes])}
  [amp frq table times]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "osciln"
                      [amp frq table times]
                      *global*)]
    (new out-types ast)))

(s/fdef osciln
  :args (s/cat :amp valid-kr? :frq valid-i? :table valid-i? :times valid-i? ))
(stest/instrument `osciln)

(defn oscili
  {:arglists '([aamp acps itableArr & iphase*] [aamp acps & itable* iphase*] [aamp kcps itableArr & iphase*] [aamp kcps & itable* iphase*] [kamp acps itableArr & iphase*] [kamp acps & itable* iphase*] [kamp kcps itableArr & iphase*] [kamp kcps & itable* iphase*] [kamp kcps itableArr & iphase*] [kamp kcps & itable* iphase*])}
  [amp cps table & [ phase* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "oscili"
                      [amp cps table phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef oscili
  :args (s/alt
         :kkii (s/cat :amp valid-kr? :cps valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :kkiArri (s/cat :amp valid-kr? :cps valid-kr? :table valid-iArr? :phase* (s/? valid-i?*) )
         :kaii (s/cat :amp valid-kr? :cps valid-ar? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :kaiArri (s/cat :amp valid-kr? :cps valid-ar? :table valid-iArr? :phase* (s/? valid-i?*) )
         :akii (s/cat :amp valid-ar? :cps valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :akiArri (s/cat :amp valid-ar? :cps valid-kr? :table valid-iArr? :phase* (s/? valid-i?*) )
         :aaii (s/cat :amp valid-ar? :cps valid-ar? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :aaiArri (s/cat :amp valid-ar? :cps valid-ar? :table valid-iArr? :phase* (s/? valid-i?*) )
         ))
(stest/instrument `oscili)

(defn oscili:a
  {:arglists '([aamp acps itableArr & iphase*] [aamp acps & itable* iphase*] [aamp kcps itableArr & iphase*] [aamp kcps & itable* iphase*] [kamp acps itableArr & iphase*] [kamp acps & itable* iphase*] [kamp kcps itableArr & iphase*] [kamp kcps & itable* iphase*])}
  [amp cps table & [ phase* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "oscili"
                      [amp cps table phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef oscili:a
  :args (s/alt
         :kkii (s/cat :amp valid-kr? :cps valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :kkiArri (s/cat :amp valid-kr? :cps valid-kr? :table valid-iArr? :phase* (s/? valid-i?*) )
         :kaii (s/cat :amp valid-kr? :cps valid-ar? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :kaiArri (s/cat :amp valid-kr? :cps valid-ar? :table valid-iArr? :phase* (s/? valid-i?*) )
         :akii (s/cat :amp valid-ar? :cps valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :akiArri (s/cat :amp valid-ar? :cps valid-kr? :table valid-iArr? :phase* (s/? valid-i?*) )
         :aaii (s/cat :amp valid-ar? :cps valid-ar? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :aaiArri (s/cat :amp valid-ar? :cps valid-ar? :table valid-iArr? :phase* (s/? valid-i?*) )
         ))
(stest/instrument `oscili:a)

(defn oscili:k
  {:arglists '([kamp kcps itableArr & iphase*] [kamp kcps & itable* iphase*])}
  [amp cps table & [ phase* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "oscili"
                      [amp cps table phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef oscili:k
  :args (s/alt
         :kkii (s/cat :amp valid-kr? :cps valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :kkiArri (s/cat :amp valid-kr? :cps valid-kr? :table valid-iArr? :phase* (s/? valid-i?*) )
         ))
(stest/instrument `oscili:k)

(defn strset
  {:arglists '([iarg Sstring])}
  [arg string]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "strset"
                      [arg string]
                      *global*)]
    (new out-types ast)))

(s/fdef strset
  :args (s/cat :arg valid-i? :string valid-S? ))
(stest/instrument `strset)

(defn splitrig
  {:arglists '([ktrig kindex imaxtics itable & kout1* kout2* koutN3* koutN4* koutN5* koutN6* koutN7* koutN8* koutN9* koutN10* koutN11* koutN12* koutN13* koutN14* koutN15* koutN16*])}
  [trig index maxtics table & [ out1* out2* outN3* outN4* outN5* outN6* outN7* outN8* outN9* outN10* outN11* outN12* outN13* outN14* outN15* outN16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "splitrig"
                      [trig index maxtics table out1* out2* outN3* outN4* outN5* outN6* outN7* outN8* outN9* outN10* outN11* outN12* outN13* outN14* outN15* outN16*]
                      *global*)]
    (new out-types ast)))

(s/fdef splitrig
  :args (s/cat :trig valid-kr? :index valid-kr? :maxtics valid-i? :table valid-i? :out1* (s/? valid-kr?*) :out2* (s/? valid-kr?*) :outN3* (s/? valid-kr?*) :outN4* (s/? valid-kr?*) :outN5* (s/? valid-kr?*) :outN6* (s/? valid-kr?*) :outN7* (s/? valid-kr?*) :outN8* (s/? valid-kr?*) :outN9* (s/? valid-kr?*) :outN10* (s/? valid-kr?*) :outN11* (s/? valid-kr?*) :outN12* (s/? valid-kr?*) :outN13* (s/? valid-kr?*) :outN14* (s/? valid-kr?*) :outN15* (s/? valid-kr?*) :outN16* (s/? valid-kr?*) ))
(stest/instrument `splitrig)

(defn outvalue
  {:arglists '([Schannel-name Sstring] [Schannel-name istring] [Schannel-name kstring] [ichannel-name Sstring] [ichannel-name istring] [ichannel-name kstring])}
  [channel-name string]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outvalue"
                      [channel-name string]
                      *global*)]
    (new out-types ast)))

(s/fdef outvalue
  :args (s/alt
         :ik (s/cat :channel-name valid-i? :string valid-kr? )
         :ii (s/cat :channel-name valid-i? :string valid-i? )
         :iS (s/cat :channel-name valid-i? :string valid-S? )
         :Sk (s/cat :channel-name valid-S? :string valid-kr? )
         :Si (s/cat :channel-name valid-S? :string valid-i? )
         :SS (s/cat :channel-name valid-S? :string valid-S? )
         ))
(stest/instrument `outvalue)

(defn deltapxw
  {:arglists '([ain adel iwsize & iwsize*])}
  [in del wsize & [ wsize* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "deltapxw"
                      [in del wsize wsize*]
                      *global*)]
    (new out-types ast)))

(s/fdef deltapxw
  :args (s/cat :in valid-ar? :del valid-ar? :wsize valid-i? :wsize* (s/? valid-i?*) ))
(stest/instrument `deltapxw)

(defn vdelay3
  {:arglists '([asig xdel imaxdel & iskip*])}
  [sig del maxdel & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "vdelay3"
                      [sig del maxdel skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef vdelay3
  :args (s/cat :sig valid-ar? :del valid-x? :maxdel valid-i? :skip* (s/? valid-i?*) ))
(stest/instrument `vdelay3)

(defn voice
  {:arglists '([kamp kfreq kphoneme kform kvibf kvamp itable ivfn])}
  [amp freq phoneme form vibf vamp table vfn]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "voice"
                      [amp freq phoneme form vibf vamp table vfn]
                      *global*)]
    (new out-types ast)))

(s/fdef voice
  :args (s/cat :amp valid-kr? :freq valid-kr? :phoneme valid-kr? :form valid-kr? :vibf valid-kr? :vamp valid-kr? :table valid-i? :vfn valid-i? ))
(stest/instrument `voice)

(defn bexprnd
  {:arglists '([krange] [krange] [krange])}
  [range]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "bexprnd"
                      [range]
                      *global*)]
    (new out-types ast)))

(s/fdef bexprnd
  :args (s/alt
         :k (s/cat :range valid-kr? )
         ))
(stest/instrument `bexprnd)

(defn bexprnd:a
  {:arglists '([krange])}
  [range]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "bexprnd"
                      [range]
                      *global*)]
    (new out-types ast)))

(s/fdef bexprnd:a
  :args (s/cat :range valid-kr? ))
(stest/instrument `bexprnd:a)

(defn bexprnd:i
  {:arglists '([krange])}
  [range]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "bexprnd"
                      [range]
                      *global*)]
    (new out-types ast)))

(s/fdef bexprnd:i
  :args (s/cat :range valid-kr? ))
(stest/instrument `bexprnd:i)

(defn bexprnd:k
  {:arglists '([krange])}
  [range]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "bexprnd"
                      [range]
                      *global*)]
    (new out-types ast)))

(s/fdef bexprnd:k
  :args (s/cat :range valid-kr? ))
(stest/instrument `bexprnd:k)

(defn chnclear
  {:arglists '([Sname])}
  [name]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "chnclear"
                      [name]
                      *global*)]
    (new out-types ast)))

(s/fdef chnclear
  :args (s/cat :name valid-S? ))
(stest/instrument `chnclear)

(defn pvstanal
  {:arglists '([ktimescal kamp kpitch ktab & kdetect* kwrap* ioffset* ifftsize* ihop* kdbthresh*])}
  [timescal amp pitch tab & [ detect* wrap* offset* fftsize* hop* dbthresh* ]]
  (let [out-types-quoted '[               ]
        out-types [               ]
        ast (ast-node out-types-quoted
                      "pvstanal"
                      [timescal amp pitch tab detect* wrap* offset* fftsize* hop* dbthresh*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef pvstanal
  :args (s/cat :timescal valid-kr? :amp valid-kr? :pitch valid-kr? :tab valid-kr? :detect* (s/? valid-kr?*) :wrap* (s/? valid-kr?*) :offset* (s/? valid-i?*) :fftsize* (s/? valid-i?*) :hop* (s/? valid-i?*) :dbthresh* (s/? valid-kr?*) ))
(stest/instrument `pvstanal)

(defn readf
  {:arglists '([Sfilname] [ifilname])}
  [filname]
  (let [out-types-quoted '[String ControlSignal]
        out-types [String ControlSignal]
        ast (ast-node out-types-quoted
                      "readf"
                      [filname]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef readf
  :args (s/alt
         :i (s/cat :filname valid-i? )
         :S (s/cat :filname valid-S? )
         ))
(stest/instrument `readf)

(defn randomh
  {:arglists '([kmin kmax xcps & imode* ifirstval*] [kmin kmax kcps & imode* ifirstval*])}
  [min max cps & [ mode* firstval* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "randomh"
                      [min max cps mode* firstval*]
                      *global*)]
    (new out-types ast)))

(s/fdef randomh
  :args (s/alt
         :kkkii (s/cat :min valid-kr? :max valid-kr? :cps valid-kr? :mode* (s/? valid-i?*) :firstval* (s/? valid-i?*) )
         :kkxii (s/cat :min valid-kr? :max valid-kr? :cps valid-x? :mode* (s/? valid-i?*) :firstval* (s/? valid-i?*) )
         ))
(stest/instrument `randomh)

(defn randomh:a
  {:arglists '([kmin kmax xcps & imode* ifirstval*])}
  [min max cps & [ mode* firstval* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "randomh"
                      [min max cps mode* firstval*]
                      *global*)]
    (new out-types ast)))

(s/fdef randomh:a
  :args (s/cat :min valid-kr? :max valid-kr? :cps valid-x? :mode* (s/? valid-i?*) :firstval* (s/? valid-i?*) ))
(stest/instrument `randomh:a)

(defn randomh:k
  {:arglists '([kmin kmax kcps & imode* ifirstval*])}
  [min max cps & [ mode* firstval* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "randomh"
                      [min max cps mode* firstval*]
                      *global*)]
    (new out-types ast)))

(s/fdef randomh:k
  :args (s/cat :min valid-kr? :max valid-kr? :cps valid-kr? :mode* (s/? valid-i?*) :firstval* (s/? valid-i?*) ))
(stest/instrument `randomh:k)

(defn getcol
  {:arglists '([kinArr kcol])}
  [in col]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "getcol"
                      [in col]
                      *global*)]
    (new out-types ast)))

(s/fdef getcol
  :args (s/cat :in valid-kArr? :col valid-kr? ))
(stest/instrument `getcol)

(defn xtratim
  {:arglists '([iextradur])}
  [extradur]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "xtratim"
                      [extradur]
                      *global*)]
    (new out-types ast)))

(s/fdef xtratim
  :args (s/cat :extradur valid-i? ))
(stest/instrument `xtratim)

(defn outs1
  {:arglists '([asig])}
  [sig]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outs1"
                      [sig]
                      *global*)]
    (new out-types ast)))

(s/fdef outs1
  :args (s/cat :sig valid-ar? ))
(stest/instrument `outs1)

(defn tabsum
  {:arglists '([itable & kmin* kmax*])}
  [table & [ min* max* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "tabsum"
                      [table min* max*]
                      *global*)]
    (new out-types ast)))

(s/fdef tabsum
  :args (s/cat :table valid-i? :min* (s/? valid-kr?*) :max* (s/? valid-kr?*) ))
(stest/instrument `tabsum)

(defn vdivv
  {:arglists '([ifn1 ifn2 kelements & kdstoffset* ksrcoffset* kverbose*])}
  [fn1 fn2 elements & [ dstoffset* srcoffset* verbose* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vdivv"
                      [fn1 fn2 elements dstoffset* srcoffset* verbose*]
                      *global*)]
    (new out-types ast)))

(s/fdef vdivv
  :args (s/cat :fn1 valid-i? :fn2 valid-i? :elements valid-kr? :dstoffset* (s/? valid-kr?*) :srcoffset* (s/? valid-kr?*) :verbose* (s/? valid-kr?*) ))
(stest/instrument `vdivv)

(defn fin
  {:arglists '([Sfilename iskipframes iformat arrArr] [Sfilename iskipframes iformat & arr1* arr2* arr3* arr4* arr5* arr6* arr7* arr8* arr9* arr10* arr11* arr12* arr13* arr14* arr15* arr16* arr17* arr18* arr19* arr20* arr21* arr22* arr23* arr24* arr25* arr26* arr27* arr28* arr29* arr30* arr31* arr32*] [ifilename iskipframes iformat & arr1* arr2* arr3* arr4* arr5* arr6* arr7* arr8* arr9* arr10* arr11* arr12* arr13* arr14* arr15* arr16* arr17* arr18* arr19* arr20* arr21* arr22* arr23* arr24* arr25* arr26* arr27* arr28* arr29* arr30* arr31* arr32*])}
  [filename skipframes format rr]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "fin"
                      [filename skipframes format rr]
                      *global*)]
    (new out-types ast)))

(s/fdef fin
  :args (s/alt
         :iiiaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa (s/cat :filename valid-i? :skipframes valid-i? :format valid-i? :rr1* (s/? valid-ar?*) :rr2* (s/? valid-ar?*) :rr3* (s/? valid-ar?*) :rr4* (s/? valid-ar?*) :rr5* (s/? valid-ar?*) :rr6* (s/? valid-ar?*) :rr7* (s/? valid-ar?*) :rr8* (s/? valid-ar?*) :rr9* (s/? valid-ar?*) :rr10* (s/? valid-ar?*) :rr11* (s/? valid-ar?*) :rr12* (s/? valid-ar?*) :rr13* (s/? valid-ar?*) :rr14* (s/? valid-ar?*) :rr15* (s/? valid-ar?*) :rr16* (s/? valid-ar?*) :rr17* (s/? valid-ar?*) :rr18* (s/? valid-ar?*) :rr19* (s/? valid-ar?*) :rr20* (s/? valid-ar?*) :rr21* (s/? valid-ar?*) :rr22* (s/? valid-ar?*) :rr23* (s/? valid-ar?*) :rr24* (s/? valid-ar?*) :rr25* (s/? valid-ar?*) :rr26* (s/? valid-ar?*) :rr27* (s/? valid-ar?*) :rr28* (s/? valid-ar?*) :rr29* (s/? valid-ar?*) :rr30* (s/? valid-ar?*) :rr31* (s/? valid-ar?*) :rr32* (s/? valid-ar?*) )
         :Siiaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa (s/cat :filename valid-S? :skipframes valid-i? :format valid-i? :rr1* (s/? valid-ar?*) :rr2* (s/? valid-ar?*) :rr3* (s/? valid-ar?*) :rr4* (s/? valid-ar?*) :rr5* (s/? valid-ar?*) :rr6* (s/? valid-ar?*) :rr7* (s/? valid-ar?*) :rr8* (s/? valid-ar?*) :rr9* (s/? valid-ar?*) :rr10* (s/? valid-ar?*) :rr11* (s/? valid-ar?*) :rr12* (s/? valid-ar?*) :rr13* (s/? valid-ar?*) :rr14* (s/? valid-ar?*) :rr15* (s/? valid-ar?*) :rr16* (s/? valid-ar?*) :rr17* (s/? valid-ar?*) :rr18* (s/? valid-ar?*) :rr19* (s/? valid-ar?*) :rr20* (s/? valid-ar?*) :rr21* (s/? valid-ar?*) :rr22* (s/? valid-ar?*) :rr23* (s/? valid-ar?*) :rr24* (s/? valid-ar?*) :rr25* (s/? valid-ar?*) :rr26* (s/? valid-ar?*) :rr27* (s/? valid-ar?*) :rr28* (s/? valid-ar?*) :rr29* (s/? valid-ar?*) :rr30* (s/? valid-ar?*) :rr31* (s/? valid-ar?*) :rr32* (s/? valid-ar?*) )
         :SiiaArr (s/cat :filename valid-S? :skipframes valid-i? :format valid-i? :rr valid-aArr? )
         ))
(stest/instrument `fin)

(defn peak
  {:arglists '([asig] [ksig])}
  [sig]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "peak"
                      [sig]
                      *global*)]
    (new out-types ast)))

(s/fdef peak
  :args (s/alt
         :k (s/cat :sig valid-kr? )
         :a (s/cat :sig valid-ar? )
         ))
(stest/instrument `peak)

(defn pvscross
  {:arglists '([fsrc fdest kamp3 kamp4])}
  [src dest amp3 amp4]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvscross"
                      [src dest amp3 amp4]
                      *global*)]
    (new out-types ast)))

(s/fdef pvscross
  :args (s/cat :src valid-f? :dest valid-f? :amp3 valid-kr? :amp4 valid-kr? ))
(stest/instrument `pvscross)

(defn convolve
  {:arglists '([ain Sfilcod & ichannel*] [ain ifilcod & ichannel*])}
  [in filcod & [ channel* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "convolve"
                      [in filcod channel*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef convolve
  :args (s/alt
         :aii (s/cat :in valid-ar? :filcod valid-i? :channel* (s/? valid-i?*) )
         :aSi (s/cat :in valid-ar? :filcod valid-S? :channel* (s/? valid-i?*) )
         ))
(stest/instrument `convolve)

(defn ftload
  {:arglists '([Sfilename iflag & ifn1* ifn2* ifn3* ifn4* ifn5* ifn6* ifn7* ifn8* ifn9* ifn10* ifn11* ifn12* ifn13* ifn14* ifn15* ifn16*] [ifilename iflag & ifn1* ifn2* ifn3* ifn4* ifn5* ifn6* ifn7* ifn8* ifn9* ifn10* ifn11* ifn12* ifn13* ifn14* ifn15* ifn16*])}
  [filename flag & [ fn1* fn2* fn3* fn4* fn5* fn6* fn7* fn8* fn9* fn10* fn11* fn12* fn13* fn14* fn15* fn16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "ftload"
                      [filename flag fn1* fn2* fn3* fn4* fn5* fn6* fn7* fn8* fn9* fn10* fn11* fn12* fn13* fn14* fn15* fn16*]
                      *global*)]
    (new out-types ast)))

(s/fdef ftload
  :args (s/alt
         :iiiiiiiiiiiiiiiiii (s/cat :filename valid-i? :flag valid-i? :fn1* (s/? valid-i?*) :fn2* (s/? valid-i?*) :fn3* (s/? valid-i?*) :fn4* (s/? valid-i?*) :fn5* (s/? valid-i?*) :fn6* (s/? valid-i?*) :fn7* (s/? valid-i?*) :fn8* (s/? valid-i?*) :fn9* (s/? valid-i?*) :fn10* (s/? valid-i?*) :fn11* (s/? valid-i?*) :fn12* (s/? valid-i?*) :fn13* (s/? valid-i?*) :fn14* (s/? valid-i?*) :fn15* (s/? valid-i?*) :fn16* (s/? valid-i?*) )
         :Siiiiiiiiiiiiiiiii (s/cat :filename valid-S? :flag valid-i? :fn1* (s/? valid-i?*) :fn2* (s/? valid-i?*) :fn3* (s/? valid-i?*) :fn4* (s/? valid-i?*) :fn5* (s/? valid-i?*) :fn6* (s/? valid-i?*) :fn7* (s/? valid-i?*) :fn8* (s/? valid-i?*) :fn9* (s/? valid-i?*) :fn10* (s/? valid-i?*) :fn11* (s/? valid-i?*) :fn12* (s/? valid-i?*) :fn13* (s/? valid-i?*) :fn14* (s/? valid-i?*) :fn15* (s/? valid-i?*) :fn16* (s/? valid-i?*) )
         ))
(stest/instrument `ftload)

(defn vmirror
  {:arglists '([itable kmin kmax ielements])}
  [table min max elements]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vmirror"
                      [table min max elements]
                      *global*)]
    (new out-types ast)))

(s/fdef vmirror
  :args (s/cat :table valid-i? :min valid-kr? :max valid-kr? :elements valid-i? ))
(stest/instrument `vmirror)

(defn setctrl
  {:arglists '([inum Sval itype] [inum ival itype])}
  [num val type]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "setctrl"
                      [num val type]
                      *global*)]
    (new out-types ast)))

(s/fdef setctrl
  :args (s/alt
         :iii (s/cat :num valid-i? :val valid-i? :type valid-i? )
         :iSi (s/cat :num valid-i? :val valid-S? :type valid-i? )
         ))
(stest/instrument `setctrl)

(defn trandom
  {:arglists '([ktrig kmin kmax])}
  [trig min max]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "trandom"
                      [trig min max]
                      *global*)]
    (new out-types ast)))

(s/fdef trandom
  :args (s/cat :trig valid-kr? :min valid-kr? :max valid-kr? ))
(stest/instrument `trandom)

(defn aftouch
  {:arglists '([& imin* imax*])}
  [& [ min* max* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "aftouch"
                      [min* max*]
                      *global*)]
    (new out-types ast)))

(s/fdef aftouch
  :args (s/cat :min* (s/? valid-i?*) :max* (s/? valid-i?*) ))
(stest/instrument `aftouch)

(defn massign
  {:arglists '([ichnl Sinsname & ireset*] [ichnl iinsname & ireset*])}
  [chnl insname & [ reset* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "massign"
                      [chnl insname reset*]
                      *global*)]
    (new out-types ast)))

(s/fdef massign
  :args (s/alt
         :iii (s/cat :chnl valid-i? :insname valid-i? :reset* (s/? valid-i?*) )
         :iSi (s/cat :chnl valid-i? :insname valid-S? :reset* (s/? valid-i?*) )
         ))
(stest/instrument `massign)

(defn tableiw
  {:arglists '([isig iindex itable & ixmode* ixoff* iwgmode*])}
  [sig index table & [ xmode* xoff* wgmode* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "tableiw"
                      [sig index table xmode* xoff* wgmode*]
                      *global*)]
    (new out-types ast)))

(s/fdef tableiw
  :args (s/cat :sig valid-i? :index valid-i? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wgmode* (s/? valid-i?*) ))
(stest/instrument `tableiw)

(defn pinkish
  {:arglists '([xin & imethod* inumbands* iseed* iskip*])}
  [in & [ method* numbands* seed* skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "pinkish"
                      [in method* numbands* seed* skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef pinkish
  :args (s/cat :in valid-x? :method* (s/? valid-i?*) :numbands* (s/? valid-i?*) :seed* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `pinkish)

(defn linseg
  {:arglists '([ia idur2 & ib1* idur2* ic3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*] [ia idur2 & ib1* idur2* ic3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a dur2 & [ b1* dur2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "linseg"
                      [a dur2 b1* dur2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef linseg
  :args (s/alt
         :iiiiiiiiiiiiiiiiii (s/cat :a valid-i? :dur2 valid-i? :b1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :c3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) )
         ))
(stest/instrument `linseg)

(defn linseg:a
  {:arglists '([ia idur2 & ib1* idur2* ic3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a dur2 & [ b1* dur2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "linseg"
                      [a dur2 b1* dur2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef linseg:a
  :args (s/cat :a valid-i? :dur2 valid-i? :b1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :c3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) ))
(stest/instrument `linseg:a)

(defn linseg:k
  {:arglists '([ia idur2 & ib1* idur2* ic3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a dur2 & [ b1* dur2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "linseg"
                      [a dur2 b1* dur2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef linseg:k
  :args (s/cat :a valid-i? :dur2 valid-i? :b1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :c3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) ))
(stest/instrument `linseg:k)

(defn midinoteonkey
  {:arglists '([xkey xvelocity])}
  [key velocity]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "midinoteonkey"
                      [key velocity]
                      *global*)]
    (new out-types ast)))

(s/fdef midinoteonkey
  :args (s/cat :key valid-x? :velocity valid-x? ))
(stest/instrument `midinoteonkey)

(defn dumpk
  {:arglists '([ksig Sfilname iformat iprd] [ksig ifilname iformat iprd])}
  [sig filname format prd]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "dumpk"
                      [sig filname format prd]
                      *global*)]
    (new out-types ast)))

(s/fdef dumpk
  :args (s/alt
         :kiii (s/cat :sig valid-kr? :filname valid-i? :format valid-i? :prd valid-i? )
         :kSii (s/cat :sig valid-kr? :filname valid-S? :format valid-i? :prd valid-i? )
         ))
(stest/instrument `dumpk)

(defn mtof
  {:arglists '([imidi] [kmidi])}
  [midi]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "mtof"
                      [midi]
                      *global*)]
    (new out-types ast)))

(s/fdef mtof
  :args (s/alt
         :k (s/cat :midi valid-kr? )
         :i (s/cat :midi valid-i? )
         ))
(stest/instrument `mtof)

(defn mtof:i
  {:arglists '([imidi])}
  [midi]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "mtof"
                      [midi]
                      *global*)]
    (new out-types ast)))

(s/fdef mtof:i
  :args (s/cat :midi valid-i? ))
(stest/instrument `mtof:i)

(defn mtof:k
  {:arglists '([kmidi])}
  [midi]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "mtof"
                      [midi]
                      *global*)]
    (new out-types ast)))

(s/fdef mtof:k
  :args (s/cat :midi valid-kr? ))
(stest/instrument `mtof:k)

(defn octmidi
  {:arglists '()}
  []
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "octmidi"
                      []
                      *global*)]
    (new out-types ast)))


(defn tempoval
  {:arglists '()}
  []
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "tempoval"
                      []
                      *global*)]
    (new out-types ast)))


(defn midremot
  {:arglists '([Sdestination Ssource & instrnum1* instrnum2* instrnum3* instrnum4* instrnum5* instrnum6* instrnum7* instrnum8* instrnum9* instrnum10* instrnum11* instrnum12* instrnum13* instrnum14* instrnum15* instrnum16*])}
  [destination source & [ nstrnum1* nstrnum2* nstrnum3* nstrnum4* nstrnum5* nstrnum6* nstrnum7* nstrnum8* nstrnum9* nstrnum10* nstrnum11* nstrnum12* nstrnum13* nstrnum14* nstrnum15* nstrnum16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "midremot"
                      [destination source nstrnum1* nstrnum2* nstrnum3* nstrnum4* nstrnum5* nstrnum6* nstrnum7* nstrnum8* nstrnum9* nstrnum10* nstrnum11* nstrnum12* nstrnum13* nstrnum14* nstrnum15* nstrnum16*]
                      *global*)]
    (new out-types ast)))

(s/fdef midremot
  :args (s/cat :destination valid-S? :source valid-S? :nstrnum1* (s/? valid-i?*) :nstrnum2* (s/? valid-i?*) :nstrnum3* (s/? valid-i?*) :nstrnum4* (s/? valid-i?*) :nstrnum5* (s/? valid-i?*) :nstrnum6* (s/? valid-i?*) :nstrnum7* (s/? valid-i?*) :nstrnum8* (s/? valid-i?*) :nstrnum9* (s/? valid-i?*) :nstrnum10* (s/? valid-i?*) :nstrnum11* (s/? valid-i?*) :nstrnum12* (s/? valid-i?*) :nstrnum13* (s/? valid-i?*) :nstrnum14* (s/? valid-i?*) :nstrnum15* (s/? valid-i?*) :nstrnum16* (s/? valid-i?*) ))
(stest/instrument `midremot)

(defn madsr
  {:arglists '([iatt idec islev irel & idel* ireltim*] [iatt idec islev irel & idel* ireltim*])}
  [att dec slev rel & [ del* reltim* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "madsr"
                      [att dec slev rel del* reltim*]
                      *global*)]
    (new out-types ast)))

(s/fdef madsr
  :args (s/alt
         :iiiiii (s/cat :att valid-i? :dec valid-i? :slev valid-i? :rel valid-i? :del* (s/? valid-i?*) :reltim* (s/? valid-i?*) )
         ))
(stest/instrument `madsr)

(defn tempest
  {:arglists '([kin iprd imindur imemdur ihp ithresh ihtim ixfdbak istartempo itable & idisprd* itweek*])}
  [in prd mindur memdur hp thresh htim xfdbak startempo table & [ disprd* tweek* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "tempest"
                      [in prd mindur memdur hp thresh htim xfdbak startempo table disprd* tweek*]
                      *global*)]
    (new out-types ast)))

(s/fdef tempest
  :args (s/cat :in valid-kr? :prd valid-i? :mindur valid-i? :memdur valid-i? :hp valid-i? :thresh valid-i? :htim valid-i? :xfdbak valid-i? :startempo valid-i? :table valid-i? :disprd* (s/? valid-i?*) :tweek* (s/? valid-i?*) ))
(stest/instrument `tempest)

(defn lpsholdp
  {:arglists '([kphase & kvalue1* ktime2* kvalue3* ktime4* kvalue5* ktime6* ktime7* ktime8* ktime9* ktime10* ktime11* ktime12* ktime13* ktime14* ktime15* ktime16*])}
  [phase & [ value1* time2* value3* time4* value5* time6* time7* time8* time9* time10* time11* time12* time13* time14* time15* time16* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "lpsholdp"
                      [phase value1* time2* value3* time4* value5* time6* time7* time8* time9* time10* time11* time12* time13* time14* time15* time16*]
                      *global*)]
    (new out-types ast)))

(s/fdef lpsholdp
  :args (s/cat :phase valid-kr? :value1* (s/? valid-kr?*) :time2* (s/? valid-kr?*) :value3* (s/? valid-kr?*) :time4* (s/? valid-kr?*) :value5* (s/? valid-kr?*) :time6* (s/? valid-kr?*) :time7* (s/? valid-kr?*) :time8* (s/? valid-kr?*) :time9* (s/? valid-kr?*) :time10* (s/? valid-kr?*) :time11* (s/? valid-kr?*) :time12* (s/? valid-kr?*) :time13* (s/? valid-kr?*) :time14* (s/? valid-kr?*) :time15* (s/? valid-kr?*) :time16* (s/? valid-kr?*) ))
(stest/instrument `lpsholdp)

(defn follow
  {:arglists '([asig idt])}
  [sig dt]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "follow"
                      [sig dt]
                      *global*)]
    (new out-types ast)))

(s/fdef follow
  :args (s/cat :sig valid-ar? :dt valid-i? ))
(stest/instrument `follow)

(defn multitap
  {:arglists '([asig & itime1* igain2* itime3* igain4* igain5* igain6* igain7* igain8* igain9* igain10* igain11* igain12* igain13* igain14* igain15* igain16*])}
  [sig & [ time1* gain2* time3* gain4* gain5* gain6* gain7* gain8* gain9* gain10* gain11* gain12* gain13* gain14* gain15* gain16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "multitap"
                      [sig time1* gain2* time3* gain4* gain5* gain6* gain7* gain8* gain9* gain10* gain11* gain12* gain13* gain14* gain15* gain16*]
                      *global*)]
    (new out-types ast)))

(s/fdef multitap
  :args (s/cat :sig valid-ar? :time1* (s/? valid-i?*) :gain2* (s/? valid-i?*) :time3* (s/? valid-i?*) :gain4* (s/? valid-i?*) :gain5* (s/? valid-i?*) :gain6* (s/? valid-i?*) :gain7* (s/? valid-i?*) :gain8* (s/? valid-i?*) :gain9* (s/? valid-i?*) :gain10* (s/? valid-i?*) :gain11* (s/? valid-i?*) :gain12* (s/? valid-i?*) :gain13* (s/? valid-i?*) :gain14* (s/? valid-i?*) :gain15* (s/? valid-i?*) :gain16* (s/? valid-i?*) ))
(stest/instrument `multitap)

(defn pvsmaska
  {:arglists '([fsrc itable kdepth])}
  [src table depth]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvsmaska"
                      [src table depth]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsmaska
  :args (s/cat :src valid-f? :table valid-i? :depth valid-kr? ))
(stest/instrument `pvsmaska)

(defn trcross
  {:arglists '([fin1 fin2 ksearch & kdepth1* kmode2* kmode3* kmode4* kmode5* kmode6* kmode7* kmode8* kmode9* kmode10* kmode11* kmode12* kmode13* kmode14* kmode15* kmode16*])}
  [in1 in2 search & [ depth1* mode2* mode3* mode4* mode5* mode6* mode7* mode8* mode9* mode10* mode11* mode12* mode13* mode14* mode15* mode16* ]]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "trcross"
                      [in1 in2 search depth1* mode2* mode3* mode4* mode5* mode6* mode7* mode8* mode9* mode10* mode11* mode12* mode13* mode14* mode15* mode16*]
                      *global*)]
    (new out-types ast)))

(s/fdef trcross
  :args (s/cat :in1 valid-f? :in2 valid-f? :search valid-kr? :depth1* (s/? valid-kr?*) :mode2* (s/? valid-kr?*) :mode3* (s/? valid-kr?*) :mode4* (s/? valid-kr?*) :mode5* (s/? valid-kr?*) :mode6* (s/? valid-kr?*) :mode7* (s/? valid-kr?*) :mode8* (s/? valid-kr?*) :mode9* (s/? valid-kr?*) :mode10* (s/? valid-kr?*) :mode11* (s/? valid-kr?*) :mode12* (s/? valid-kr?*) :mode13* (s/? valid-kr?*) :mode14* (s/? valid-kr?*) :mode15* (s/? valid-kr?*) :mode16* (s/? valid-kr?*) ))
(stest/instrument `trcross)

(defn mvchpf
  {:arglists '([ain acenter-frequency & istor*] [ain kcenter-frequency & istor*])}
  [in center-frequency & [ stor* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "mvchpf"
                      [in center-frequency stor*]
                      *global*)]
    (new out-types ast)))

(s/fdef mvchpf
  :args (s/alt
         :aki (s/cat :in valid-ar? :center-frequency valid-kr? :stor* (s/? valid-i?*) )
         :aai (s/cat :in valid-ar? :center-frequency valid-ar? :stor* (s/? valid-i?*) )
         ))
(stest/instrument `mvchpf)

(defn butbp
  {:arglists '([asig xfreq xband & iskip*])}
  [sig freq band & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "butbp"
                      [sig freq band skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef butbp
  :args (s/cat :sig valid-ar? :freq valid-x? :band valid-x? :skip* (s/? valid-i?*) ))
(stest/instrument `butbp)

(defn strsub
  {:arglists '([Ssrc & istart* iend*])}
  [src & [ start* end* ]]
  (let [out-types-quoted 'String
        out-types String
        ast (ast-node out-types-quoted
                      "strsub"
                      [src start* end*]
                      *global*)]
    (new out-types ast)))

(s/fdef strsub
  :args (s/cat :src valid-S? :start* (s/? valid-i?*) :end* (s/? valid-i?*) ))
(stest/instrument `strsub)

(defn poscil
  {:arglists '([aamp acps & itable* iphase*] [aamp kcps & itable* iphase*] [kamp acps & itable* iphase*] [kamp kcps & itable* iphase*] [kamp kcps & itable* iphase*])}
  [amp cps & [ table* phase* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "poscil"
                      [amp cps table* phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef poscil
  :args (s/alt
         :kkii (s/cat :amp valid-kr? :cps valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :kaii (s/cat :amp valid-kr? :cps valid-ar? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :akii (s/cat :amp valid-ar? :cps valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :aaii (s/cat :amp valid-ar? :cps valid-ar? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         ))
(stest/instrument `poscil)

(defn poscil:a
  {:arglists '([aamp acps & itable* iphase*] [aamp kcps & itable* iphase*] [kamp acps & itable* iphase*] [kamp kcps & itable* iphase*])}
  [amp cps & [ table* phase* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "poscil"
                      [amp cps table* phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef poscil:a
  :args (s/alt
         :kkii (s/cat :amp valid-kr? :cps valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :kaii (s/cat :amp valid-kr? :cps valid-ar? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :akii (s/cat :amp valid-ar? :cps valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         :aaii (s/cat :amp valid-ar? :cps valid-ar? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) )
         ))
(stest/instrument `poscil:a)

(defn poscil:k
  {:arglists '([kamp kcps & itable* iphase*])}
  [amp cps & [ table* phase* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "poscil"
                      [amp cps table* phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef poscil:k
  :args (s/cat :amp valid-kr? :cps valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) ))
(stest/instrument `poscil:k)

(defn tablewa
  {:arglists '([ktable asig koff & ioff*])}
  [table sig off & [ off* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "tablewa"
                      [table sig off off*]
                      *global*)]
    (new out-types ast)))

(s/fdef tablewa
  :args (s/cat :table valid-kr? :sig valid-ar? :off valid-kr? :off* (s/? valid-i?*) ))
(stest/instrument `tablewa)

(defn fmbell
  {:arglists '([kamp kfreq kc3 kc4 kvdepth kvrate & ifn1* ifn1* ifn1* ifn1* ivfn* isus*])}
  [amp freq c3 c4 vdepth vrate & [ fn1* fn1* fn1* fn1* vfn* sus* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "fmbell"
                      [amp freq c3 c4 vdepth vrate fn1* fn1* fn1* fn1* vfn* sus*]
                      *global*)]
    (new out-types ast)))

(s/fdef fmbell
  :args (s/cat :amp valid-kr? :freq valid-kr? :c3 valid-kr? :c4 valid-kr? :vdepth valid-kr? :vrate valid-kr? :fn1* (s/? valid-i?*) :fn1* (s/? valid-i?*) :fn1* (s/? valid-i?*) :fn1* (s/? valid-i?*) :vfn* (s/? valid-i?*) :sus* (s/? valid-i?*) ))
(stest/instrument `fmbell)

(defn buthp
  {:arglists '([asig afreq & iskip*] [asig kfreq & iskip*])}
  [sig freq & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "buthp"
                      [sig freq skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef buthp
  :args (s/alt
         :aki (s/cat :sig valid-ar? :freq valid-kr? :skip* (s/? valid-i?*) )
         :aai (s/cat :sig valid-ar? :freq valid-ar? :skip* (s/? valid-i?*) )
         ))
(stest/instrument `buthp)

(defn nlfilt2
  {:arglists '([ain ka kb kd kC kL])}
  [in a b d C L]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "nlfilt2"
                      [in a b d C L]
                      *global*)]
    (new out-types ast)))

(s/fdef nlfilt2
  :args (s/cat :in valid-ar? :a valid-kr? :b valid-kr? :d valid-kr? :C valid-kr? :L valid-kr? ))
(stest/instrument `nlfilt2)

(defn dssiinit
  {:arglists '([ilibraryname iplugindex & iverbose*] [Slibraryname iplugindex & iverbose*])}
  [libraryname plugindex & [ verbose* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "dssiinit"
                      [libraryname plugindex verbose*]
                      *global*)]
    (new out-types ast)))

(s/fdef dssiinit
  :args (s/alt
         :Sii (s/cat :libraryname valid-S? :plugindex valid-i? :verbose* (s/? valid-i?*) )
         :iii (s/cat :libraryname valid-i? :plugindex valid-i? :verbose* (s/? valid-i?*) )
         ))
(stest/instrument `dssiinit)

(defn envlpxr
  {:arglists '([aamp irise idec itable iatss iatdec & ixmod* irind*] [kamp irise idec itable iatss iatdec & ixmod* irind*] [kamp irise idec itable iatss iatdec & ixmod* irind*])}
  [amp rise dec table atss atdec & [ xmod* rind* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "envlpxr"
                      [amp rise dec table atss atdec xmod* rind*]
                      *global*)]
    (new out-types ast)))

(s/fdef envlpxr
  :args (s/alt
         :kiiiiiii (s/cat :amp valid-kr? :rise valid-i? :dec valid-i? :table valid-i? :atss valid-i? :atdec valid-i? :xmod* (s/? valid-i?*) :rind* (s/? valid-i?*) )
         :aiiiiiii (s/cat :amp valid-ar? :rise valid-i? :dec valid-i? :table valid-i? :atss valid-i? :atdec valid-i? :xmod* (s/? valid-i?*) :rind* (s/? valid-i?*) )
         ))
(stest/instrument `envlpxr)

(defn envlpxr:a
  {:arglists '([aamp irise idec itable iatss iatdec & ixmod* irind*] [kamp irise idec itable iatss iatdec & ixmod* irind*])}
  [amp rise dec table atss atdec & [ xmod* rind* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "envlpxr"
                      [amp rise dec table atss atdec xmod* rind*]
                      *global*)]
    (new out-types ast)))

(s/fdef envlpxr:a
  :args (s/alt
         :kiiiiiii (s/cat :amp valid-kr? :rise valid-i? :dec valid-i? :table valid-i? :atss valid-i? :atdec valid-i? :xmod* (s/? valid-i?*) :rind* (s/? valid-i?*) )
         :aiiiiiii (s/cat :amp valid-ar? :rise valid-i? :dec valid-i? :table valid-i? :atss valid-i? :atdec valid-i? :xmod* (s/? valid-i?*) :rind* (s/? valid-i?*) )
         ))
(stest/instrument `envlpxr:a)

(defn envlpxr:k
  {:arglists '([kamp irise idec itable iatss iatdec & ixmod* irind*])}
  [amp rise dec table atss atdec & [ xmod* rind* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "envlpxr"
                      [amp rise dec table atss atdec xmod* rind*]
                      *global*)]
    (new out-types ast)))

(s/fdef envlpxr:k
  :args (s/cat :amp valid-kr? :rise valid-i? :dec valid-i? :table valid-i? :atss valid-i? :atdec valid-i? :xmod* (s/? valid-i?*) :rind* (s/? valid-i?*) ))
(stest/instrument `envlpxr:k)

(defn moog
  {:arglists '([kamp kfreq kfiltq kfiltrate kvibf kvamp iafn iwfn ivfn])}
  [amp freq filtq filtrate vibf vamp afn wfn vfn]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "moog"
                      [amp freq filtq filtrate vibf vamp afn wfn vfn]
                      *global*)]
    (new out-types ast)))

(s/fdef moog
  :args (s/cat :amp valid-kr? :freq valid-kr? :filtq valid-kr? :filtrate valid-kr? :vibf valid-kr? :vamp valid-kr? :afn valid-i? :wfn valid-i? :vfn valid-i? ))
(stest/instrument `moog)

(defn vrandh
  {:arglists '([itable krange kcps ielements & idstoffset* iseed* isize* ioffset*])}
  [table range cps elements & [ dstoffset* seed* size* offset* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vrandh"
                      [table range cps elements dstoffset* seed* size* offset*]
                      *global*)]
    (new out-types ast)))

(s/fdef vrandh
  :args (s/cat :table valid-i? :range valid-kr? :cps valid-kr? :elements valid-i? :dstoffset* (s/? valid-i?*) :seed* (s/? valid-i?*) :size* (s/? valid-i?*) :offset* (s/? valid-i?*) ))
(stest/instrument `vrandh)

(defn vdelayk
  {:arglists '([ksig kdel imaxdel & iskip* imode*])}
  [sig del maxdel & [ skip* mode* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "vdelayk"
                      [sig del maxdel skip* mode*]
                      *global*)]
    (new out-types ast)))

(s/fdef vdelayk
  :args (s/cat :sig valid-kr? :del valid-kr? :maxdel valid-i? :skip* (s/? valid-i?*) :mode* (s/? valid-i?*) ))
(stest/instrument `vdelayk)

(defn outs
  {:arglists '([& asig1* asig2* asig3* asig4* asig5* asig6* asig7* asig8* asig9* asig10* asig11* asig12* asig13* asig14* asig15* asig16* asig17* asig18* asig19* asig20* asig21* asig22* asig23* asig24* asig25* asig26* asig27* asig28* asig29* asig30* asig31* asig32*])}
  [& [ sig1* sig2* sig3* sig4* sig5* sig6* sig7* sig8* sig9* sig10* sig11* sig12* sig13* sig14* sig15* sig16* sig17* sig18* sig19* sig20* sig21* sig22* sig23* sig24* sig25* sig26* sig27* sig28* sig29* sig30* sig31* sig32* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outs"
                      [sig1* sig2* sig3* sig4* sig5* sig6* sig7* sig8* sig9* sig10* sig11* sig12* sig13* sig14* sig15* sig16* sig17* sig18* sig19* sig20* sig21* sig22* sig23* sig24* sig25* sig26* sig27* sig28* sig29* sig30* sig31* sig32*]
                      *global*)]
    (new out-types ast)))

(s/fdef outs
  :args (s/cat :sig1* (s/? valid-ar?*) :sig2* (s/? valid-ar?*) :sig3* (s/? valid-ar?*) :sig4* (s/? valid-ar?*) :sig5* (s/? valid-ar?*) :sig6* (s/? valid-ar?*) :sig7* (s/? valid-ar?*) :sig8* (s/? valid-ar?*) :sig9* (s/? valid-ar?*) :sig10* (s/? valid-ar?*) :sig11* (s/? valid-ar?*) :sig12* (s/? valid-ar?*) :sig13* (s/? valid-ar?*) :sig14* (s/? valid-ar?*) :sig15* (s/? valid-ar?*) :sig16* (s/? valid-ar?*) :sig17* (s/? valid-ar?*) :sig18* (s/? valid-ar?*) :sig19* (s/? valid-ar?*) :sig20* (s/? valid-ar?*) :sig21* (s/? valid-ar?*) :sig22* (s/? valid-ar?*) :sig23* (s/? valid-ar?*) :sig24* (s/? valid-ar?*) :sig25* (s/? valid-ar?*) :sig26* (s/? valid-ar?*) :sig27* (s/? valid-ar?*) :sig28* (s/? valid-ar?*) :sig29* (s/? valid-ar?*) :sig30* (s/? valid-ar?*) :sig31* (s/? valid-ar?*) :sig32* (s/? valid-ar?*) ))
(stest/instrument `outs)

(defn midinoteoff
  {:arglists '([xkey xvelocity])}
  [key velocity]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "midinoteoff"
                      [key velocity]
                      *global*)]
    (new out-types ast)))

(s/fdef midinoteoff
  :args (s/cat :key valid-x? :velocity valid-x? ))
(stest/instrument `midinoteoff)

(defn crossfm
  {:arglists '([xmi xfrq2 xfrq3 xndx4 kndx5 icps ifn7 & ifn1* iphs1*])}
  [mi frq2 frq3 ndx4 ndx5 cps fn7 & [ fn1* phs1* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "crossfm"
                      [mi frq2 frq3 ndx4 ndx5 cps fn7 fn1* phs1*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef crossfm
  :args (s/cat :mi valid-x? :frq2 valid-x? :frq3 valid-x? :ndx4 valid-x? :ndx5 valid-kr? :cps valid-i? :fn7 valid-i? :fn1* (s/? valid-i?*) :phs1* (s/? valid-i?*) ))
(stest/instrument `crossfm)

(defn strlower
  {:arglists '([Ssrc])}
  [src]
  (let [out-types-quoted 'String
        out-types String
        ast (ast-node out-types-quoted
                      "strlower"
                      [src]
                      *global*)]
    (new out-types ast)))

(s/fdef strlower
  :args (s/cat :src valid-S? ))
(stest/instrument `strlower)

(defn rspline
  {:arglists '([xrangeMin xrangeMax kcpsMin kcpsMax] [xrangeMin xrangeMax kcpsMin kcpsMax])}
  [rangeMin rangeMax cpsMin cpsMax]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "rspline"
                      [rangeMin rangeMax cpsMin cpsMax]
                      *global*)]
    (new out-types ast)))

(s/fdef rspline
  :args (s/alt
         :xxkk (s/cat :rangeMin valid-x? :rangeMax valid-x? :cpsMin valid-kr? :cpsMax valid-kr? )
         ))
(stest/instrument `rspline)

(defn rspline:a
  {:arglists '([xrangeMin xrangeMax kcpsMin kcpsMax])}
  [rangeMin rangeMax cpsMin cpsMax]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "rspline"
                      [rangeMin rangeMax cpsMin cpsMax]
                      *global*)]
    (new out-types ast)))

(s/fdef rspline:a
  :args (s/cat :rangeMin valid-x? :rangeMax valid-x? :cpsMin valid-kr? :cpsMax valid-kr? ))
(stest/instrument `rspline:a)

(defn rspline:k
  {:arglists '([xrangeMin xrangeMax kcpsMin kcpsMax])}
  [rangeMin rangeMax cpsMin cpsMax]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "rspline"
                      [rangeMin rangeMax cpsMin cpsMax]
                      *global*)]
    (new out-types ast)))

(s/fdef rspline:k
  :args (s/cat :rangeMin valid-x? :rangeMax valid-x? :cpsMin valid-kr? :cpsMax valid-kr? ))
(stest/instrument `rspline:k)

(defn vtablek
  {:arglists '([kindex ktable kinterp ixmode & kout1* kout2* kout3* koutN4* koutN5* koutN6* koutN7* koutN8* koutN9* koutN10* koutN11* koutN12* koutN13* koutN14* koutN15* koutN16*])}
  [index table interp xmode & [ out1* out2* out3* outN4* outN5* outN6* outN7* outN8* outN9* outN10* outN11* outN12* outN13* outN14* outN15* outN16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vtablek"
                      [index table interp xmode out1* out2* out3* outN4* outN5* outN6* outN7* outN8* outN9* outN10* outN11* outN12* outN13* outN14* outN15* outN16*]
                      *global*)]
    (new out-types ast)))

(s/fdef vtablek
  :args (s/cat :index valid-kr? :table valid-kr? :interp valid-kr? :xmode valid-i? :out1* (s/? valid-kr?*) :out2* (s/? valid-kr?*) :out3* (s/? valid-kr?*) :outN4* (s/? valid-kr?*) :outN5* (s/? valid-kr?*) :outN6* (s/? valid-kr?*) :outN7* (s/? valid-kr?*) :outN8* (s/? valid-kr?*) :outN9* (s/? valid-kr?*) :outN10* (s/? valid-kr?*) :outN11* (s/? valid-kr?*) :outN12* (s/? valid-kr?*) :outN13* (s/? valid-kr?*) :outN14* (s/? valid-kr?*) :outN15* (s/? valid-kr?*) :outN16* (s/? valid-kr?*) ))
(stest/instrument `vtablek)

(defn midiprogramchange
  {:arglists '([xprogram])}
  [program]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "midiprogramchange"
                      [program]
                      *global*)]
    (new out-types ast)))

(s/fdef midiprogramchange
  :args (s/cat :program valid-x? ))
(stest/instrument `midiprogramchange)

(defn partikkelsync
  {:arglists '([iopcode_id])}
  [opcode_id]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "partikkelsync"
                      [opcode_id]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef partikkelsync
  :args (s/cat :opcode_id valid-i? ))
(stest/instrument `partikkelsync)

(defn foscil
  {:arglists '([xamp kcps xcar xmod kindex & itable* iphase*])}
  [amp cps car mod index & [ table* phase* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "foscil"
                      [amp cps car mod index table* phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef foscil
  :args (s/cat :amp valid-x? :cps valid-kr? :car valid-x? :mod valid-x? :index valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) ))
(stest/instrument `foscil)

(defn transeg
  {:arglists '([ia idur itype & ib1* idur2* itype3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*] [ia idur itype & ib1* idur2* itype3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a dur type & [ b1* dur2* type3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "transeg"
                      [a dur type b1* dur2* type3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef transeg
  :args (s/alt
         :iiiiiiiiiiiiiiiiiii (s/cat :a valid-i? :dur valid-i? :type valid-i? :b1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :type3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) )
         ))
(stest/instrument `transeg)

(defn transeg:a
  {:arglists '([ia idur itype & ib1* idur2* itype3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a dur type & [ b1* dur2* type3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "transeg"
                      [a dur type b1* dur2* type3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef transeg:a
  :args (s/cat :a valid-i? :dur valid-i? :type valid-i? :b1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :type3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) ))
(stest/instrument `transeg:a)

(defn transeg:k
  {:arglists '([ia idur itype & ib1* idur2* itype3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a dur type & [ b1* dur2* type3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "transeg"
                      [a dur type b1* dur2* type3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef transeg:k
  :args (s/cat :a valid-i? :dur valid-i? :type valid-i? :b1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :type3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) ))
(stest/instrument `transeg:k)

(defn clear
  {:arglists '([& avar1* avar2* avar3* avar4* avar5* avar6* avar7* avar8* avar9* avar10* avar11* avar12* avar13* avar14* avar15* avar16* avar17* avar18* avar19* avar20* avar21* avar22* avar23* avar24* avar25* avar26* avar27* avar28* avar29* avar30* avar31* avar32*])}
  [& [ var1* var2* var3* var4* var5* var6* var7* var8* var9* var10* var11* var12* var13* var14* var15* var16* var17* var18* var19* var20* var21* var22* var23* var24* var25* var26* var27* var28* var29* var30* var31* var32* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "clear"
                      [var1* var2* var3* var4* var5* var6* var7* var8* var9* var10* var11* var12* var13* var14* var15* var16* var17* var18* var19* var20* var21* var22* var23* var24* var25* var26* var27* var28* var29* var30* var31* var32*]
                      *global*)]
    (new out-types ast)))

(s/fdef clear
  :args (s/cat :var1* (s/? valid-ar?*) :var2* (s/? valid-ar?*) :var3* (s/? valid-ar?*) :var4* (s/? valid-ar?*) :var5* (s/? valid-ar?*) :var6* (s/? valid-ar?*) :var7* (s/? valid-ar?*) :var8* (s/? valid-ar?*) :var9* (s/? valid-ar?*) :var10* (s/? valid-ar?*) :var11* (s/? valid-ar?*) :var12* (s/? valid-ar?*) :var13* (s/? valid-ar?*) :var14* (s/? valid-ar?*) :var15* (s/? valid-ar?*) :var16* (s/? valid-ar?*) :var17* (s/? valid-ar?*) :var18* (s/? valid-ar?*) :var19* (s/? valid-ar?*) :var20* (s/? valid-ar?*) :var21* (s/? valid-ar?*) :var22* (s/? valid-ar?*) :var23* (s/? valid-ar?*) :var24* (s/? valid-ar?*) :var25* (s/? valid-ar?*) :var26* (s/? valid-ar?*) :var27* (s/? valid-ar?*) :var28* (s/? valid-ar?*) :var29* (s/? valid-ar?*) :var30* (s/? valid-ar?*) :var31* (s/? valid-ar?*) :var32* (s/? valid-ar?*) ))
(stest/instrument `clear)

(defn locsend
  {:arglists '()}
  []
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "locsend"
                      []
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))


(defn pvsanal
  {:arglists '([ain ifftsize ioverlap iwinsize iwintype & iformat* iinit*])}
  [in fftsize overlap winsize wintype & [ format* init* ]]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvsanal"
                      [in fftsize overlap winsize wintype format* init*]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsanal
  :args (s/cat :in valid-ar? :fftsize valid-i? :overlap valid-i? :winsize valid-i? :wintype valid-i? :format* (s/? valid-i?*) :init* (s/? valid-i?*) ))
(stest/instrument `pvsanal)

(defn active
  {:arglists '([Sinsnum & iopt* inorel*] [iinsnum & iopt* inorel*] [Sinsnum & iopt* inorel*] [kinsnum & iopt* inorel*])}
  [insnum & [ opt* norel* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "active"
                      [insnum opt* norel*]
                      *global*)]
    (new out-types ast)))

(s/fdef active
  :args (s/alt
         :kii (s/cat :insnum valid-kr? :opt* (s/? valid-i?*) :norel* (s/? valid-i?*) )
         :iii (s/cat :insnum valid-i? :opt* (s/? valid-i?*) :norel* (s/? valid-i?*) )
         :Sii (s/cat :insnum valid-S? :opt* (s/? valid-i?*) :norel* (s/? valid-i?*) )
         ))
(stest/instrument `active)

(defn active:i
  {:arglists '([Sinsnum & iopt* inorel*] [iinsnum & iopt* inorel*])}
  [insnum & [ opt* norel* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "active"
                      [insnum opt* norel*]
                      *global*)]
    (new out-types ast)))

(s/fdef active:i
  :args (s/alt
         :iii (s/cat :insnum valid-i? :opt* (s/? valid-i?*) :norel* (s/? valid-i?*) )
         :Sii (s/cat :insnum valid-S? :opt* (s/? valid-i?*) :norel* (s/? valid-i?*) )
         ))
(stest/instrument `active:i)

(defn active:k
  {:arglists '([Sinsnum & iopt* inorel*] [kinsnum & iopt* inorel*])}
  [insnum & [ opt* norel* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "active"
                      [insnum opt* norel*]
                      *global*)]
    (new out-types ast)))

(s/fdef active:k
  :args (s/alt
         :kii (s/cat :insnum valid-kr? :opt* (s/? valid-i?*) :norel* (s/? valid-i?*) )
         :Sii (s/cat :insnum valid-S? :opt* (s/? valid-i?*) :norel* (s/? valid-i?*) )
         ))
(stest/instrument `active:k)

(defn scanhammer
  {:arglists '([isrc idst ipos imult])}
  [src dst pos mult]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "scanhammer"
                      [src dst pos mult]
                      *global*)]
    (new out-types ast)))

(s/fdef scanhammer
  :args (s/cat :src valid-i? :dst valid-i? :pos valid-i? :mult valid-i? ))
(stest/instrument `scanhammer)

(defn vexp_i
  {:arglists '([itable ival ielements & idstoffset*])}
  [table val elements & [ dstoffset* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vexp_i"
                      [table val elements dstoffset*]
                      *global*)]
    (new out-types ast)))

(s/fdef vexp_i
  :args (s/cat :table valid-i? :val valid-i? :elements valid-i? :dstoffset* (s/? valid-i?*) ))
(stest/instrument `vexp_i)

(defn urandom
  {:arglists '([& imin* imax*] [& imin* imax*] [& imin* imax*])}
  [& [ min* max* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "urandom"
                      [min* max*]
                      *global*)]
    (new out-types ast)))

(s/fdef urandom
  :args (s/alt
         :ii (s/cat :min* (s/? valid-i?*) :max* (s/? valid-i?*) )
         ))
(stest/instrument `urandom)

(defn urandom:a
  {:arglists '([& imin* imax*])}
  [& [ min* max* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "urandom"
                      [min* max*]
                      *global*)]
    (new out-types ast)))

(s/fdef urandom:a
  :args (s/cat :min* (s/? valid-i?*) :max* (s/? valid-i?*) ))
(stest/instrument `urandom:a)

(defn urandom:i
  {:arglists '([& imin* imax*])}
  [& [ min* max* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "urandom"
                      [min* max*]
                      *global*)]
    (new out-types ast)))

(s/fdef urandom:i
  :args (s/cat :min* (s/? valid-i?*) :max* (s/? valid-i?*) ))
(stest/instrument `urandom:i)

(defn urandom:k
  {:arglists '([& imin* imax*])}
  [& [ min* max* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "urandom"
                      [min* max*]
                      *global*)]
    (new out-types ast)))

(s/fdef urandom:k
  :args (s/cat :min* (s/? valid-i?*) :max* (s/? valid-i?*) ))
(stest/instrument `urandom:k)

(defn vlinseg
  {:arglists '([ifnout ielements & ifn1* idur2* ifn3* idur4* ifn5* ifn6* ifn7* ifn8* ifn9* ifn10* ifn11* ifn12* ifn13* ifn14* ifn15* ifn16*])}
  [fnout elements & [ fn1* dur2* fn3* dur4* fn5* fn6* fn7* fn8* fn9* fn10* fn11* fn12* fn13* fn14* fn15* fn16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vlinseg"
                      [fnout elements fn1* dur2* fn3* dur4* fn5* fn6* fn7* fn8* fn9* fn10* fn11* fn12* fn13* fn14* fn15* fn16*]
                      *global*)]
    (new out-types ast)))

(s/fdef vlinseg
  :args (s/cat :fnout valid-i? :elements valid-i? :fn1* (s/? valid-i?*) :dur2* (s/? valid-i?*) :fn3* (s/? valid-i?*) :dur4* (s/? valid-i?*) :fn5* (s/? valid-i?*) :fn6* (s/? valid-i?*) :fn7* (s/? valid-i?*) :fn8* (s/? valid-i?*) :fn9* (s/? valid-i?*) :fn10* (s/? valid-i?*) :fn11* (s/? valid-i?*) :fn12* (s/? valid-i?*) :fn13* (s/? valid-i?*) :fn14* (s/? valid-i?*) :fn15* (s/? valid-i?*) :fn16* (s/? valid-i?*) ))
(stest/instrument `vlinseg)

(defn pvsinfo
  {:arglists '([fsrc])}
  [src]
  (let [out-types-quoted '[Variable Variable Variable Variable]
        out-types [Variable Variable Variable Variable]
        ast (ast-node out-types-quoted
                      "pvsinfo"
                      [src]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef pvsinfo
  :args (s/cat :src valid-f? ))
(stest/instrument `pvsinfo)

(defn partikkel
  {:arglists '([xgrainfreq kdistribution idisttab async kenv2amt ienv2tab ienv_attack ienv_decay ksustain_amount ka_d_ratio kduration kamp igainmasks kwavfreq ksweepshape iwavfreqstarttab iwavfreqendtab awavfm ifmamptab kfmenv icosine ktraincps knumpartials kchroma ichannelmasks krandommask kwaveform27 kwaveform28 kwaveform29 kwaveform30 iwaveamptab asamplepos32 asamplepos33 asamplepos34 asamplepos35 kwavekey36 kwavekey37 kwavekey38 kwavekey39 imax_grains & iopcode_id* ipanlaws*])}
  [grainfreq distribution disttab sync env2amt env2tab env_attack env_decay sustain_amount a_d_ratio duration amp gainmasks wavfreq sweepshape wavfreqstarttab wavfreqendtab wavfm fmamptab fmenv cosine traincps numpartials chroma channelmasks randommask waveform27 waveform28 waveform29 waveform30 waveamptab samplepos32 samplepos33 samplepos34 samplepos35 wavekey36 wavekey37 wavekey38 wavekey39 max_grains & [ opcode_id* panlaws* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "partikkel"
                      [grainfreq distribution disttab sync env2amt env2tab env_attack env_decay sustain_amount a_d_ratio duration amp gainmasks wavfreq sweepshape wavfreqstarttab wavfreqendtab wavfm fmamptab fmenv cosine traincps numpartials chroma channelmasks randommask waveform27 waveform28 waveform29 waveform30 waveamptab samplepos32 samplepos33 samplepos34 samplepos35 wavekey36 wavekey37 wavekey38 wavekey39 max_grains opcode_id* panlaws*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef partikkel
  :args (s/cat :grainfreq valid-x? :distribution valid-kr? :disttab valid-i? :sync valid-ar? :env2amt valid-kr? :env2tab valid-i? :env_attack valid-i? :env_decay valid-i? :sustain_amount valid-kr? :a_d_ratio valid-kr? :duration valid-kr? :amp valid-kr? :gainmasks valid-i? :wavfreq valid-kr? :sweepshape valid-kr? :wavfreqstarttab valid-i? :wavfreqendtab valid-i? :wavfm valid-ar? :fmamptab valid-i? :fmenv valid-kr? :cosine valid-i? :traincps valid-kr? :numpartials valid-kr? :chroma valid-kr? :channelmasks valid-i? :randommask valid-kr? :waveform27 valid-kr? :waveform28 valid-kr? :waveform29 valid-kr? :waveform30 valid-kr? :waveamptab valid-i? :samplepos32 valid-ar? :samplepos33 valid-ar? :samplepos34 valid-ar? :samplepos35 valid-ar? :wavekey36 valid-kr? :wavekey37 valid-kr? :wavekey38 valid-kr? :wavekey39 valid-kr? :max_grains valid-i? :opcode_id* (s/? valid-i?*) :panlaws* (s/? valid-i?*) ))
(stest/instrument `partikkel)

(defn delayr
  {:arglists '([idlt & iskip*] [kdlt iskip & iskip*])}
  [dlt & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "delayr"
                      [dlt skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef delayr
  :args (s/alt
         :kii (s/cat :dlt valid-kr? :skip valid-i? :skip* (s/? valid-i?*) )
         :ii (s/cat :dlt valid-i? :skip* (s/? valid-i?*) )
         ))
(stest/instrument `delayr)

(defn delayr:a
  {:arglists '([idlt & iskip*])}
  [dlt & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "delayr"
                      [dlt skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef delayr:a
  :args (s/cat :dlt valid-i? :skip* (s/? valid-i?*) ))
(stest/instrument `delayr:a)

(defn delayr:k
  {:arglists '([kdlt iskip & iskip*])}
  [dlt skip & [ skip* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "delayr"
                      [dlt skip skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef delayr:k
  :args (s/cat :dlt valid-kr? :skip valid-i? :skip* (s/? valid-i?*) ))
(stest/instrument `delayr:k)

(defn ctrl14
  {:arglists '([ichan ictlno2 ictlno3 imin imax & itable*] [ichan ictlno2 ictlno3 kmin kmax & itable*])}
  [chan ctlno2 ctlno3 min max & [ table* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "ctrl14"
                      [chan ctlno2 ctlno3 min max table*]
                      *global*)]
    (new out-types ast)))

(s/fdef ctrl14
  :args (s/alt
         :iiikki (s/cat :chan valid-i? :ctlno2 valid-i? :ctlno3 valid-i? :min valid-kr? :max valid-kr? :table* (s/? valid-i?*) )
         :iiiiii (s/cat :chan valid-i? :ctlno2 valid-i? :ctlno3 valid-i? :min valid-i? :max valid-i? :table* (s/? valid-i?*) )
         ))
(stest/instrument `ctrl14)

(defn ctrl14:i
  {:arglists '([ichan ictlno2 ictlno3 imin imax & itable*])}
  [chan ctlno2 ctlno3 min max & [ table* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "ctrl14"
                      [chan ctlno2 ctlno3 min max table*]
                      *global*)]
    (new out-types ast)))

(s/fdef ctrl14:i
  :args (s/cat :chan valid-i? :ctlno2 valid-i? :ctlno3 valid-i? :min valid-i? :max valid-i? :table* (s/? valid-i?*) ))
(stest/instrument `ctrl14:i)

(defn ctrl14:k
  {:arglists '([ichan ictlno2 ictlno3 kmin kmax & itable*])}
  [chan ctlno2 ctlno3 min max & [ table* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "ctrl14"
                      [chan ctlno2 ctlno3 min max table*]
                      *global*)]
    (new out-types ast)))

(s/fdef ctrl14:k
  :args (s/cat :chan valid-i? :ctlno2 valid-i? :ctlno3 valid-i? :min valid-kr? :max valid-kr? :table* (s/? valid-i?*) ))
(stest/instrument `ctrl14:k)

(defn pvsfreeze
  {:arglists '([fsigin kfreeza kfreezf])}
  [sigin freeza freezf]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvsfreeze"
                      [sigin freeza freezf]
                      *global*)]
    (new out-types ast)))

(s/fdef pvsfreeze
  :args (s/cat :sigin valid-f? :freeza valid-kr? :freezf valid-kr? ))
(stest/instrument `pvsfreeze)

(defn sfilist
  {:arglists '([ifilhandle])}
  [filhandle]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "sfilist"
                      [filhandle]
                      *global*)]
    (new out-types ast)))

(s/fdef sfilist
  :args (s/cat :filhandle valid-i? ))
(stest/instrument `sfilist)

(defn metro
  {:arglists '([kfreq & initphase*])}
  [freq & [ nitphase* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "metro"
                      [freq nitphase*]
                      *global*)]
    (new out-types ast)))

(s/fdef metro
  :args (s/cat :freq valid-kr? :nitphase* (s/? valid-i?*) ))
(stest/instrument `metro)

(defn initc7
  {:arglists '([ichan ictlno ivalue])}
  [chan ctlno value]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "initc7"
                      [chan ctlno value]
                      *global*)]
    (new out-types ast)))

(s/fdef initc7
  :args (s/cat :chan valid-i? :ctlno valid-i? :value valid-i? ))
(stest/instrument `initc7)

(defn timek
  {:arglists '( )}
  []
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "timek"
                      []
                      *global*)]
    (new out-types ast)))


(defn timek:i
  {:arglists '()}
  []
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "timek"
                      []
                      *global*)]
    (new out-types ast)))


(defn timek:k
  {:arglists '()}
  []
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "timek"
                      []
                      *global*)]
    (new out-types ast)))


(defn vdelayx
  {:arglists '([ain adl imd iws & ist*])}
  [in dl md ws & [ st* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "vdelayx"
                      [in dl md ws st*]
                      *global*)]
    (new out-types ast)))

(s/fdef vdelayx
  :args (s/cat :in valid-ar? :dl valid-ar? :md valid-i? :ws valid-i? :st* (s/? valid-i?*) ))
(stest/instrument `vdelayx)

(defn initc21
  {:arglists '([ichan ictlno2 ictlno3 ictlno4 ivalue])}
  [chan ctlno2 ctlno3 ctlno4 value]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "initc21"
                      [chan ctlno2 ctlno3 ctlno4 value]
                      *global*)]
    (new out-types ast)))

(s/fdef initc21
  :args (s/cat :chan valid-i? :ctlno2 valid-i? :ctlno3 valid-i? :ctlno4 valid-i? :value valid-i? ))
(stest/instrument `initc21)

(defn sinh
  {:arglists '([aarg1] [iarg1] [iarg1Arr] [karg1] [karg1Arr])}
  [arg1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "sinh"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sinh
  :args (s/alt
         :kArr (s/cat :arg1 valid-kArr? )
         :k (s/cat :arg1 valid-kr? )
         :iArr (s/cat :arg1 valid-iArr? )
         :i (s/cat :arg1 valid-i? )
         :a (s/cat :arg1 valid-ar? )
         ))
(stest/instrument `sinh)

(defn sinh:a
  {:arglists '([aarg1])}
  [arg1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "sinh"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sinh:a
  :args (s/cat :arg1 valid-ar? ))
(stest/instrument `sinh:a)

(defn sinh:i
  {:arglists '([iarg1])}
  [arg1]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "sinh"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sinh:i
  :args (s/cat :arg1 valid-i? ))
(stest/instrument `sinh:i)

(defn sinh:iArr
  {:arglists '([iarg1Arr])}
  [arg1]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "sinh"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sinh:iArr
  :args (s/cat :arg1 valid-iArr? ))
(stest/instrument `sinh:iArr)

(defn sinh:k
  {:arglists '([karg1])}
  [arg1]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "sinh"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sinh:k
  :args (s/cat :arg1 valid-kr? ))
(stest/instrument `sinh:k)

(defn sinh:kArr
  {:arglists '([karg1Arr])}
  [arg1]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "sinh"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef sinh:kArr
  :args (s/cat :arg1 valid-kArr? ))
(stest/instrument `sinh:kArr)

(defn vdelay
  {:arglists '([asig xdel imaxdel & iskip*])}
  [sig del maxdel & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "vdelay"
                      [sig del maxdel skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef vdelay
  :args (s/cat :sig valid-ar? :del valid-x? :maxdel valid-i? :skip* (s/? valid-i?*) ))
(stest/instrument `vdelay)

(defn fmb3
  {:arglists '([kamp kfreq kc3 kc4 kvdepth kvrate & ifn1* ifn1* ifn1* ifn1* ivfn*])}
  [amp freq c3 c4 vdepth vrate & [ fn1* fn1* fn1* fn1* vfn* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "fmb3"
                      [amp freq c3 c4 vdepth vrate fn1* fn1* fn1* fn1* vfn*]
                      *global*)]
    (new out-types ast)))

(s/fdef fmb3
  :args (s/cat :amp valid-kr? :freq valid-kr? :c3 valid-kr? :c4 valid-kr? :vdepth valid-kr? :vrate valid-kr? :fn1* (s/? valid-i?*) :fn1* (s/? valid-i?*) :fn1* (s/? valid-i?*) :fn1* (s/? valid-i?*) :vfn* (s/? valid-i?*) ))
(stest/instrument `fmb3)

(defn lfo
  {:arglists '([kamp kcps & itype*] [kamp kcps & itype*])}
  [amp cps & [ type* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "lfo"
                      [amp cps type*]
                      *global*)]
    (new out-types ast)))

(s/fdef lfo
  :args (s/alt
         :kki (s/cat :amp valid-kr? :cps valid-kr? :type* (s/? valid-i?*) )
         ))
(stest/instrument `lfo)

(defn lfo:a
  {:arglists '([kamp kcps & itype*])}
  [amp cps & [ type* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "lfo"
                      [amp cps type*]
                      *global*)]
    (new out-types ast)))

(s/fdef lfo:a
  :args (s/cat :amp valid-kr? :cps valid-kr? :type* (s/? valid-i?*) ))
(stest/instrument `lfo:a)

(defn lfo:k
  {:arglists '([kamp kcps & itype*])}
  [amp cps & [ type* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "lfo"
                      [amp cps type*]
                      *global*)]
    (new out-types ast)))

(s/fdef lfo:k
  :args (s/cat :amp valid-kr? :cps valid-kr? :type* (s/? valid-i?*) ))
(stest/instrument `lfo:k)

(defn pgmassign
  {:arglists '([ipgm Sinsname & ichn*] [ipgm iinsname & ichn*])}
  [pgm insname & [ chn* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "pgmassign"
                      [pgm insname chn*]
                      *global*)]
    (new out-types ast)))

(s/fdef pgmassign
  :args (s/alt
         :iii (s/cat :pgm valid-i? :insname valid-i? :chn* (s/? valid-i?*) )
         :iSi (s/cat :pgm valid-i? :insname valid-S? :chn* (s/? valid-i?*) )
         ))
(stest/instrument `pgmassign)

(defn pindex
  {:arglists '([ipfieldIndex])}
  [pfieldIndex]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "pindex"
                      [pfieldIndex]
                      *global*)]
    (new out-types ast)))

(s/fdef pindex
  :args (s/cat :pfieldIndex valid-i? ))
(stest/instrument `pindex)

(defn deltapx
  {:arglists '([adel iwsize & iwsize*])}
  [del wsize & [ wsize* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "deltapx"
                      [del wsize wsize*]
                      *global*)]
    (new out-types ast)))

(s/fdef deltapx
  :args (s/cat :del valid-ar? :wsize valid-i? :wsize* (s/? valid-i?*) ))
(stest/instrument `deltapx)

(defn trhighest
  {:arglists '([fin1 kscal])}
  [in1 scal]
  (let [out-types-quoted '[FrequencySignal ControlSignal ControlSignal]
        out-types [FrequencySignal ControlSignal ControlSignal]
        ast (ast-node out-types-quoted
                      "trhighest"
                      [in1 scal]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef trhighest
  :args (s/cat :in1 valid-f? :scal valid-kr? ))
(stest/instrument `trhighest)

(defn sndwarp
  {:arglists '([xamp xtimewarp xresample ifn4 ibeg iwsize irandw ioverlap ifn9 itimemode])}
  [amp timewarp resample fn4 beg wsize randw overlap fn9 timemode]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "sndwarp"
                      [amp timewarp resample fn4 beg wsize randw overlap fn9 timemode]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef sndwarp
  :args (s/cat :amp valid-x? :timewarp valid-x? :resample valid-x? :fn4 valid-i? :beg valid-i? :wsize valid-i? :randw valid-i? :overlap valid-i? :fn9 valid-i? :timemode valid-i? ))
(stest/instrument `sndwarp)

(defn vco2ft
  {:arglists '([kcps & iwave* inyx*])}
  [cps & [ wave* nyx* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "vco2ft"
                      [cps wave* nyx*]
                      *global*)]
    (new out-types ast)))

(s/fdef vco2ft
  :args (s/cat :cps valid-kr? :wave* (s/? valid-i?*) :nyx* (s/? valid-i?*) ))
(stest/instrument `vco2ft)

(defn mandol
  {:arglists '([kamp kfreq kpluck kdetune kgain ksize itable & iminfreq*])}
  [amp freq pluck detune gain size table & [ minfreq* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "mandol"
                      [amp freq pluck detune gain size table minfreq*]
                      *global*)]
    (new out-types ast)))

(s/fdef mandol
  :args (s/cat :amp valid-kr? :freq valid-kr? :pluck valid-kr? :detune valid-kr? :gain valid-kr? :size valid-kr? :table valid-i? :minfreq* (s/? valid-i?*) ))
(stest/instrument `mandol)

(defn centroid
  {:arglists '([isigArr] [asig ktrig ifftsize] [ksigArr])}
  [sig]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "centroid"
                      [sig]
                      *global*)]
    (new out-types ast)))

(s/fdef centroid
  :args (s/alt
         :kArr (s/cat :sig valid-kArr? )
         :aki (s/cat :sig valid-ar? :trig valid-kr? :fftsize valid-i? )
         :iArr (s/cat :sig valid-iArr? )
         ))
(stest/instrument `centroid)

(defn centroid:i
  {:arglists '([isigArr])}
  [sig]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "centroid"
                      [sig]
                      *global*)]
    (new out-types ast)))

(s/fdef centroid:i
  :args (s/cat :sig valid-iArr? ))
(stest/instrument `centroid:i)

(defn centroid:k
  {:arglists '([asig ktrig ifftsize] [ksigArr])}
  [sig trig fftsize]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "centroid"
                      [sig trig fftsize]
                      *global*)]
    (new out-types ast)))

(s/fdef centroid:k
  :args (s/alt
         :kArr (s/cat :sig valid-kArr? )
         :aki (s/cat :sig valid-ar? :trig valid-kr? :fftsize valid-i? )
         ))
(stest/instrument `centroid:k)

(defn rfft
  {:arglists '([iinArr] [kinArr])}
  [in]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "rfft"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef rfft
  :args (s/alt
         :kArr (s/cat :in valid-kArr? )
         :iArr (s/cat :in valid-iArr? )
         ))
(stest/instrument `rfft)

(defn rfft:iArr
  {:arglists '([iinArr])}
  [in]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "rfft"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef rfft:iArr
  :args (s/cat :in valid-iArr? ))
(stest/instrument `rfft:iArr)

(defn rfft:kArr
  {:arglists '([kinArr])}
  [in]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "rfft"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef rfft:kArr
  :args (s/cat :in valid-kArr? ))
(stest/instrument `rfft:kArr)

(defn tabmorphak
  {:arglists '([aindex kweightpoint ktabnum3 ktabnum4 & ifn1* ifn2* ifn3* ifn4* ifnN5* ifnN6* ifnN7* ifnN8* ifnN9* ifnN10* ifnN11* ifnN12* ifnN13* ifnN14* ifnN15* ifnN16*])}
  [index weightpoint tabnum3 tabnum4 & [ fn1* fn2* fn3* fn4* fnN5* fnN6* fnN7* fnN8* fnN9* fnN10* fnN11* fnN12* fnN13* fnN14* fnN15* fnN16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "tabmorphak"
                      [index weightpoint tabnum3 tabnum4 fn1* fn2* fn3* fn4* fnN5* fnN6* fnN7* fnN8* fnN9* fnN10* fnN11* fnN12* fnN13* fnN14* fnN15* fnN16*]
                      *global*)]
    (new out-types ast)))

(s/fdef tabmorphak
  :args (s/cat :index valid-ar? :weightpoint valid-kr? :tabnum3 valid-kr? :tabnum4 valid-kr? :fn1* (s/? valid-i?*) :fn2* (s/? valid-i?*) :fn3* (s/? valid-i?*) :fn4* (s/? valid-i?*) :fnN5* (s/? valid-i?*) :fnN6* (s/? valid-i?*) :fnN7* (s/? valid-i?*) :fnN8* (s/? valid-i?*) :fnN9* (s/? valid-i?*) :fnN10* (s/? valid-i?*) :fnN11* (s/? valid-i?*) :fnN12* (s/? valid-i?*) :fnN13* (s/? valid-i?*) :fnN14* (s/? valid-i?*) :fnN15* (s/? valid-i?*) :fnN16* (s/? valid-i?*) ))
(stest/instrument `tabmorphak)

(defn noteondur
  {:arglists '([ichn inum ivel idur])}
  [chn num vel dur]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "noteondur"
                      [chn num vel dur]
                      *global*)]
    (new out-types ast)))

(s/fdef noteondur
  :args (s/cat :chn valid-i? :num valid-i? :vel valid-i? :dur valid-i? ))
(stest/instrument `noteondur)

(defn MixerReceive
  {:arglists '([ibuss ichannel])}
  [buss channel]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "MixerReceive"
                      [buss channel]
                      *global*)]
    (new out-types ast)))

(s/fdef MixerReceive
  :args (s/cat :buss valid-i? :channel valid-i? ))
(stest/instrument `MixerReceive)

(defn gendyx
  {:arglists '([kamp kampdist kdurdist kadpar kddpar kminfreq kmaxfreq kampscl kdurscl kcurveup kcurvedown & initcps* knum*] [kamp kampdist kdurdist kadpar kddpar kminfreq kmaxfreq kampscl kdurscl kcurveup kcurvedown & initcps* knum*])}
  [amp ampdist durdist adpar ddpar minfreq maxfreq ampscl durscl curveup curvedown & [ nitcps* num* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "gendyx"
                      [amp ampdist durdist adpar ddpar minfreq maxfreq ampscl durscl curveup curvedown nitcps* num*]
                      *global*)]
    (new out-types ast)))

(s/fdef gendyx
  :args (s/alt
         :kkkkkkkkkkkik (s/cat :amp valid-kr? :ampdist valid-kr? :durdist valid-kr? :adpar valid-kr? :ddpar valid-kr? :minfreq valid-kr? :maxfreq valid-kr? :ampscl valid-kr? :durscl valid-kr? :curveup valid-kr? :curvedown valid-kr? :nitcps* (s/? valid-i?*) :num* (s/? valid-kr?*) )
         ))
(stest/instrument `gendyx)

(defn gendyx:a
  {:arglists '([kamp kampdist kdurdist kadpar kddpar kminfreq kmaxfreq kampscl kdurscl kcurveup kcurvedown & initcps* knum*])}
  [amp ampdist durdist adpar ddpar minfreq maxfreq ampscl durscl curveup curvedown & [ nitcps* num* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "gendyx"
                      [amp ampdist durdist adpar ddpar minfreq maxfreq ampscl durscl curveup curvedown nitcps* num*]
                      *global*)]
    (new out-types ast)))

(s/fdef gendyx:a
  :args (s/cat :amp valid-kr? :ampdist valid-kr? :durdist valid-kr? :adpar valid-kr? :ddpar valid-kr? :minfreq valid-kr? :maxfreq valid-kr? :ampscl valid-kr? :durscl valid-kr? :curveup valid-kr? :curvedown valid-kr? :nitcps* (s/? valid-i?*) :num* (s/? valid-kr?*) ))
(stest/instrument `gendyx:a)

(defn gendyx:k
  {:arglists '([kamp kampdist kdurdist kadpar kddpar kminfreq kmaxfreq kampscl kdurscl kcurveup kcurvedown & initcps* knum*])}
  [amp ampdist durdist adpar ddpar minfreq maxfreq ampscl durscl curveup curvedown & [ nitcps* num* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "gendyx"
                      [amp ampdist durdist adpar ddpar minfreq maxfreq ampscl durscl curveup curvedown nitcps* num*]
                      *global*)]
    (new out-types ast)))

(s/fdef gendyx:k
  :args (s/cat :amp valid-kr? :ampdist valid-kr? :durdist valid-kr? :adpar valid-kr? :ddpar valid-kr? :minfreq valid-kr? :maxfreq valid-kr? :ampscl valid-kr? :durscl valid-kr? :curveup valid-kr? :curvedown valid-kr? :nitcps* (s/? valid-i?*) :num* (s/? valid-kr?*) ))
(stest/instrument `gendyx:k)

(defn weibull
  {:arglists '([ksigma ktau] [ksigma ktau] [ksigma ktau])}
  [sigma tau]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "weibull"
                      [sigma tau]
                      *global*)]
    (new out-types ast)))

(s/fdef weibull
  :args (s/alt
         :kk (s/cat :sigma valid-kr? :tau valid-kr? )
         ))
(stest/instrument `weibull)

(defn weibull:a
  {:arglists '([ksigma ktau])}
  [sigma tau]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "weibull"
                      [sigma tau]
                      *global*)]
    (new out-types ast)))

(s/fdef weibull:a
  :args (s/cat :sigma valid-kr? :tau valid-kr? ))
(stest/instrument `weibull:a)

(defn weibull:i
  {:arglists '([ksigma ktau])}
  [sigma tau]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "weibull"
                      [sigma tau]
                      *global*)]
    (new out-types ast)))

(s/fdef weibull:i
  :args (s/cat :sigma valid-kr? :tau valid-kr? ))
(stest/instrument `weibull:i)

(defn weibull:k
  {:arglists '([ksigma ktau])}
  [sigma tau]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "weibull"
                      [sigma tau]
                      *global*)]
    (new out-types ast)))

(s/fdef weibull:k
  :args (s/cat :sigma valid-kr? :tau valid-kr? ))
(stest/instrument `weibull:k)

(defn aresonk
  {:arglists '([ksig kcenter-frequency kbandwidth & iscale* iskip*])}
  [sig center-frequency bandwidth & [ scale* skip* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "aresonk"
                      [sig center-frequency bandwidth scale* skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef aresonk
  :args (s/cat :sig valid-kr? :center-frequency valid-kr? :bandwidth valid-kr? :scale* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `aresonk)

(defn buzz
  {:arglists '([xamp xcps knh itable & iphase*])}
  [amp cps nh table & [ phase* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "buzz"
                      [amp cps nh table phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef buzz
  :args (s/cat :amp valid-x? :cps valid-x? :nh valid-kr? :table valid-i? :phase* (s/? valid-i?*) ))
(stest/instrument `buzz)

(defn rtclock
  {:arglists '( )}
  []
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "rtclock"
                      []
                      *global*)]
    (new out-types ast)))


(defn rtclock:i
  {:arglists '()}
  []
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "rtclock"
                      []
                      *global*)]
    (new out-types ast)))


(defn rtclock:k
  {:arglists '()}
  []
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "rtclock"
                      []
                      *global*)]
    (new out-types ast)))


(defn rireturn
  {:arglists '()}
  []
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "rireturn"
                      []
                      *global*)]
    (new out-types ast)))


(defn grain3
  {:arglists '([kcps kphase kfmd kpmd kgdur kdens imaxovr ktable iwfn kfrpow kprpow & iseed* imode*])}
  [cps phase fmd pmd gdur dens maxovr table wfn frpow prpow & [ seed* mode* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "grain3"
                      [cps phase fmd pmd gdur dens maxovr table wfn frpow prpow seed* mode*]
                      *global*)]
    (new out-types ast)))

(s/fdef grain3
  :args (s/cat :cps valid-kr? :phase valid-kr? :fmd valid-kr? :pmd valid-kr? :gdur valid-kr? :dens valid-kr? :maxovr valid-i? :table valid-kr? :wfn valid-i? :frpow valid-kr? :prpow valid-kr? :seed* (s/? valid-i?*) :mode* (s/? valid-i?*) ))
(stest/instrument `grain3)

(defn doppler
  {:arglists '([asource ksourceposition kmicposition & isoundspeed* ifiltercutoff*])}
  [source sourceposition micposition & [ soundspeed* filtercutoff* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "doppler"
                      [source sourceposition micposition soundspeed* filtercutoff*]
                      *global*)]
    (new out-types ast)))

(s/fdef doppler
  :args (s/cat :source valid-ar? :sourceposition valid-kr? :micposition valid-kr? :soundspeed* (s/? valid-i?*) :filtercutoff* (s/? valid-i?*) ))
(stest/instrument `doppler)

(defn trigger
  {:arglists '([ksig kthreshold kmode])}
  [sig threshold mode]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "trigger"
                      [sig threshold mode]
                      *global*)]
    (new out-types ast)))

(s/fdef trigger
  :args (s/cat :sig valid-kr? :threshold valid-kr? :mode valid-kr? ))
(stest/instrument `trigger)

(defn bbcutm
  {:arglists '([asource ibps isubdiv ibarlength iphrasebars inumrepeats & istutterspeed* istutterchance* ienvchoice*])}
  [source bps subdiv barlength phrasebars numrepeats & [ stutterspeed* stutterchance* envchoice* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "bbcutm"
                      [source bps subdiv barlength phrasebars numrepeats stutterspeed* stutterchance* envchoice*]
                      *global*)]
    (new out-types ast)))

(s/fdef bbcutm
  :args (s/cat :source valid-ar? :bps valid-i? :subdiv valid-i? :barlength valid-i? :phrasebars valid-i? :numrepeats valid-i? :stutterspeed* (s/? valid-i?*) :stutterchance* (s/? valid-i?*) :envchoice* (s/? valid-i?*) ))
(stest/instrument `bbcutm)

(defn compileorc
  {:arglists '([Sfilename])}
  [filename]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "compileorc"
                      [filename]
                      *global*)]
    (new out-types ast)))

(s/fdef compileorc
  :args (s/cat :filename valid-S? ))
(stest/instrument `compileorc)

(defn zkmod
  {:arglists '([ksig kzkmod])}
  [sig zkmod]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "zkmod"
                      [sig zkmod]
                      *global*)]
    (new out-types ast)))

(s/fdef zkmod
  :args (s/cat :sig valid-kr? :zkmod valid-kr? ))
(stest/instrument `zkmod)

(defn vport
  {:arglists '([itable khtime ielements & ifnInit*])}
  [table htime elements & [ fnInit* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vport"
                      [table htime elements fnInit*]
                      *global*)]
    (new out-types ast)))

(s/fdef vport
  :args (s/cat :table valid-i? :htime valid-kr? :elements valid-i? :fnInit* (s/? valid-i?*) ))
(stest/instrument `vport)

(defn fof
  {:arglists '([xamp xfund xform koct kband kris kdur kdec iolaps ifna ifnb itotdur & iphase* ifmode* iskip*])}
  [amp fund form oct band ris dur dec olaps fna fnb totdur & [ phase* fmode* skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "fof"
                      [amp fund form oct band ris dur dec olaps fna fnb totdur phase* fmode* skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef fof
  :args (s/cat :amp valid-x? :fund valid-x? :form valid-x? :oct valid-kr? :band valid-kr? :ris valid-kr? :dur valid-kr? :dec valid-kr? :olaps valid-i? :fna valid-i? :fnb valid-i? :totdur valid-i? :phase* (s/? valid-i?*) :fmode* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `fof)

(defn vbapg
  {:arglists '([kazim & kelev* kspread* ilayout*] [kazim & kelev* kspread* ilayout*])}
  [azim & [ elev* spread* layout* ]]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "vbapg"
                      [azim elev* spread* layout*]
                      *global*)]
    (new out-types ast)))

(s/fdef vbapg
  :args (s/alt
         :kkki (s/cat :azim valid-kr? :elev* (s/? valid-kr?*) :spread* (s/? valid-kr?*) :layout* (s/? valid-i?*) )
         ))
(stest/instrument `vbapg)

(defn vbapg:kArr
  {:arglists '([kazim & kelev* kspread* ilayout*])}
  [azim & [ elev* spread* layout* ]]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "vbapg"
                      [azim elev* spread* layout*]
                      *global*)]
    (new out-types ast)))

(s/fdef vbapg:kArr
  :args (s/cat :azim valid-kr? :elev* (s/? valid-kr?*) :spread* (s/? valid-kr?*) :layout* (s/? valid-i?*) ))
(stest/instrument `vbapg:kArr)

(defn vbapg:k
  {:arglists '([kazim & kelev* kspread* ilayout*])}
  [azim & [ elev* spread* layout* ]]
  (let [out-types-quoted '[ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal]
        out-types [ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal ControlSignal]
        ast (ast-node out-types-quoted
                      "vbapg"
                      [azim elev* spread* layout*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef vbapg:k
  :args (s/cat :azim valid-kr? :elev* (s/? valid-kr?*) :spread* (s/? valid-kr?*) :layout* (s/? valid-i?*) ))
(stest/instrument `vbapg:k)

(defn round
  {:arglists '([aarg1] [iarg1] [iarg1Arr] [karg1] [karg1Arr])}
  [arg1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "round"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef round
  :args (s/alt
         :kArr (s/cat :arg1 valid-kArr? )
         :k (s/cat :arg1 valid-kr? )
         :iArr (s/cat :arg1 valid-iArr? )
         :i (s/cat :arg1 valid-i? )
         :a (s/cat :arg1 valid-ar? )
         ))
(stest/instrument `round)

(defn round:a
  {:arglists '([aarg1])}
  [arg1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "round"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef round:a
  :args (s/cat :arg1 valid-ar? ))
(stest/instrument `round:a)

(defn round:i
  {:arglists '([iarg1])}
  [arg1]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "round"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef round:i
  :args (s/cat :arg1 valid-i? ))
(stest/instrument `round:i)

(defn round:iArr
  {:arglists '([iarg1Arr])}
  [arg1]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "round"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef round:iArr
  :args (s/cat :arg1 valid-iArr? ))
(stest/instrument `round:iArr)

(defn round:k
  {:arglists '([karg1])}
  [arg1]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "round"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef round:k
  :args (s/cat :arg1 valid-kr? ))
(stest/instrument `round:k)

(defn round:kArr
  {:arglists '([karg1Arr])}
  [arg1]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "round"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef round:kArr
  :args (s/cat :arg1 valid-kArr? ))
(stest/instrument `round:kArr)

(defn serialFlush
  {:arglists '([iPort])}
  [Port]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "serialFlush"
                      [Port]
                      *global*)]
    (new out-types ast)))

(s/fdef serialFlush
  :args (s/cat :Port valid-i? ))
(stest/instrument `serialFlush)

(defn inh
  {:arglists '()}
  []
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "inh"
                      []
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))


(defn ephasor
  {:arglists '([xfreq kR & iR*])}
  [freq R & [ R* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "ephasor"
                      [freq R R*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef ephasor
  :args (s/cat :freq valid-x? :R valid-kr? :R* (s/? valid-i?*) ))
(stest/instrument `ephasor)

(defn sfinstr3m
  {:arglists '([ivel inotenum xamp xfreq instrnum ifilhandle & iflag* ioffset* ioffset*])}
  [vel notenum amp freq nstrnum filhandle & [ flag* offset* offset* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "sfinstr3m"
                      [vel notenum amp freq nstrnum filhandle flag* offset* offset*]
                      *global*)]
    (new out-types ast)))

(s/fdef sfinstr3m
  :args (s/cat :vel valid-i? :notenum valid-i? :amp valid-x? :freq valid-x? :nstrnum valid-i? :filhandle valid-i? :flag* (s/? valid-i?*) :offset* (s/? valid-i?*) :offset* (s/? valid-i?*) ))
(stest/instrument `sfinstr3m)

(defn crunch
  {:arglists '([iamp idettack & inum* idamp* imaxshake*])}
  [amp dettack & [ num* damp* maxshake* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "crunch"
                      [amp dettack num* damp* maxshake*]
                      *global*)]
    (new out-types ast)))

(s/fdef crunch
  :args (s/cat :amp valid-i? :dettack valid-i? :num* (s/? valid-i?*) :damp* (s/? valid-i?*) :maxshake* (s/? valid-i?*) ))
(stest/instrument `crunch)

(defn pinker
  {:arglists '()}
  []
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "pinker"
                      []
                      *global*)]
    (new out-types ast)))


(defn setrow
  {:arglists '([kinArr krow])}
  [in row]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "setrow"
                      [in row]
                      *global*)]
    (new out-types ast)))

(s/fdef setrow
  :args (s/cat :in valid-kArr? :row valid-kr? ))
(stest/instrument `setrow)

(defn outq3
  {:arglists '([asig])}
  [sig]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outq3"
                      [sig]
                      *global*)]
    (new out-types ast)))

(s/fdef outq3
  :args (s/cat :sig valid-ar? ))
(stest/instrument `outq3)

(defn scanu
  {:arglists '([init irate ifnvel ifnmass ifnstif ifncentr ifndamp kmass kstif kcentr kdamp ileft iright kpos kstrngth ain idisp id])}
  [nit rate fnvel fnmass fnstif fncentr fndamp mass stif centr damp left right pos strngth in disp d]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "scanu"
                      [nit rate fnvel fnmass fnstif fncentr fndamp mass stif centr damp left right pos strngth in disp d]
                      *global*)]
    (new out-types ast)))

(s/fdef scanu
  :args (s/cat :nit valid-i? :rate valid-i? :fnvel valid-i? :fnmass valid-i? :fnstif valid-i? :fncentr valid-i? :fndamp valid-i? :mass valid-kr? :stif valid-kr? :centr valid-kr? :damp valid-kr? :left valid-i? :right valid-i? :pos valid-kr? :strngth valid-kr? :in valid-ar? :disp valid-i? :d valid-i? ))
(stest/instrument `scanu)

(defn maxarray
  {:arglists '([iarrayArr] [karrayArr])}
  [array]
  (let [out-types-quoted '[Variable ]
        out-types [Variable ]
        ast (ast-node out-types-quoted
                      "maxarray"
                      [array]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef maxarray
  :args (s/alt
         :kArr (s/cat :array valid-kArr? )
         :iArr (s/cat :array valid-iArr? )
         ))
(stest/instrument `maxarray)

(defn oscilikt
  {:arglists '([aamp acps ktable & iphase* istor*] [aamp kcps ktable & iphase* istor*] [kamp acps ktable & iphase* istor*] [kamp kcps ktable & iphase* istor*] [kamp kcps ktable & iphase* istor*])}
  [amp cps table & [ phase* stor* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "oscilikt"
                      [amp cps table phase* stor*]
                      *global*)]
    (new out-types ast)))

(s/fdef oscilikt
  :args (s/alt
         :kkkii (s/cat :amp valid-kr? :cps valid-kr? :table valid-kr? :phase* (s/? valid-i?*) :stor* (s/? valid-i?*) )
         :kakii (s/cat :amp valid-kr? :cps valid-ar? :table valid-kr? :phase* (s/? valid-i?*) :stor* (s/? valid-i?*) )
         :akkii (s/cat :amp valid-ar? :cps valid-kr? :table valid-kr? :phase* (s/? valid-i?*) :stor* (s/? valid-i?*) )
         :aakii (s/cat :amp valid-ar? :cps valid-ar? :table valid-kr? :phase* (s/? valid-i?*) :stor* (s/? valid-i?*) )
         ))
(stest/instrument `oscilikt)

(defn oscilikt:a
  {:arglists '([aamp acps ktable & iphase* istor*] [aamp kcps ktable & iphase* istor*] [kamp acps ktable & iphase* istor*] [kamp kcps ktable & iphase* istor*])}
  [amp cps table & [ phase* stor* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "oscilikt"
                      [amp cps table phase* stor*]
                      *global*)]
    (new out-types ast)))

(s/fdef oscilikt:a
  :args (s/alt
         :kkkii (s/cat :amp valid-kr? :cps valid-kr? :table valid-kr? :phase* (s/? valid-i?*) :stor* (s/? valid-i?*) )
         :kakii (s/cat :amp valid-kr? :cps valid-ar? :table valid-kr? :phase* (s/? valid-i?*) :stor* (s/? valid-i?*) )
         :akkii (s/cat :amp valid-ar? :cps valid-kr? :table valid-kr? :phase* (s/? valid-i?*) :stor* (s/? valid-i?*) )
         :aakii (s/cat :amp valid-ar? :cps valid-ar? :table valid-kr? :phase* (s/? valid-i?*) :stor* (s/? valid-i?*) )
         ))
(stest/instrument `oscilikt:a)

(defn oscilikt:k
  {:arglists '([kamp kcps ktable & iphase* istor*])}
  [amp cps table & [ phase* stor* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "oscilikt"
                      [amp cps table phase* stor*]
                      *global*)]
    (new out-types ast)))

(s/fdef oscilikt:k
  :args (s/cat :amp valid-kr? :cps valid-kr? :table valid-kr? :phase* (s/? valid-i?*) :stor* (s/? valid-i?*) ))
(stest/instrument `oscilikt:k)

(defn midipitchbend
  {:arglists '([xpitchbend & ilow* ihigh*])}
  [pitchbend & [ low* high* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "midipitchbend"
                      [pitchbend low* high*]
                      *global*)]
    (new out-types ast)))

(s/fdef midipitchbend
  :args (s/cat :pitchbend valid-x? :low* (s/? valid-i?*) :high* (s/? valid-i?*) ))
(stest/instrument `midipitchbend)

(defn jspline
  {:arglists '([xamp kcpsMin kcpsMax] [xamp kcpsMin kcpsMax])}
  [amp cpsMin cpsMax]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "jspline"
                      [amp cpsMin cpsMax]
                      *global*)]
    (new out-types ast)))

(s/fdef jspline
  :args (s/alt
         :xkk (s/cat :amp valid-x? :cpsMin valid-kr? :cpsMax valid-kr? )
         ))
(stest/instrument `jspline)

(defn jspline:a
  {:arglists '([xamp kcpsMin kcpsMax])}
  [amp cpsMin cpsMax]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "jspline"
                      [amp cpsMin cpsMax]
                      *global*)]
    (new out-types ast)))

(s/fdef jspline:a
  :args (s/cat :amp valid-x? :cpsMin valid-kr? :cpsMax valid-kr? ))
(stest/instrument `jspline:a)

(defn jspline:k
  {:arglists '([xamp kcpsMin kcpsMax])}
  [amp cpsMin cpsMax]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "jspline"
                      [amp cpsMin cpsMax]
                      *global*)]
    (new out-types ast)))

(s/fdef jspline:k
  :args (s/cat :amp valid-x? :cpsMin valid-kr? :cpsMax valid-kr? ))
(stest/instrument `jspline:k)

(defn phasor
  {:arglists '([xcps & iphase*] [kcps & iphase*])}
  [cps & [ phase* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "phasor"
                      [cps phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef phasor
  :args (s/alt
         :ki (s/cat :cps valid-kr? :phase* (s/? valid-i?*) )
         :xi (s/cat :cps valid-x? :phase* (s/? valid-i?*) )
         ))
(stest/instrument `phasor)

(defn phasor:a
  {:arglists '([xcps & iphase*])}
  [cps & [ phase* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "phasor"
                      [cps phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef phasor:a
  :args (s/cat :cps valid-x? :phase* (s/? valid-i?*) ))
(stest/instrument `phasor:a)

(defn phasor:k
  {:arglists '([kcps & iphase*])}
  [cps & [ phase* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "phasor"
                      [cps phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef phasor:k
  :args (s/cat :cps valid-kr? :phase* (s/? valid-i?*) ))
(stest/instrument `phasor:k)

(defn looptseg
  {:arglists '([kfreq ktrig iphase & kvalue1* ktype2* ktime3* kvalue4* ktype5* ktime6* kvalue7* ktype8* ktime9* kvalueN10* ktypeN11* ktimeN12* ktimeN13* ktimeN14* ktimeN15* ktimeN16*])}
  [freq trig phase & [ value1* type2* time3* value4* type5* time6* value7* type8* time9* valueN10* typeN11* timeN12* timeN13* timeN14* timeN15* timeN16* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "looptseg"
                      [freq trig phase value1* type2* time3* value4* type5* time6* value7* type8* time9* valueN10* typeN11* timeN12* timeN13* timeN14* timeN15* timeN16*]
                      *global*)]
    (new out-types ast)))

(s/fdef looptseg
  :args (s/cat :freq valid-kr? :trig valid-kr? :phase valid-i? :value1* (s/? valid-kr?*) :type2* (s/? valid-kr?*) :time3* (s/? valid-kr?*) :value4* (s/? valid-kr?*) :type5* (s/? valid-kr?*) :time6* (s/? valid-kr?*) :value7* (s/? valid-kr?*) :type8* (s/? valid-kr?*) :time9* (s/? valid-kr?*) :valueN10* (s/? valid-kr?*) :typeN11* (s/? valid-kr?*) :timeN12* (s/? valid-kr?*) :timeN13* (s/? valid-kr?*) :timeN14* (s/? valid-kr?*) :timeN15* (s/? valid-kr?*) :timeN16* (s/? valid-kr?*) ))
(stest/instrument `looptseg)

(defn vmultv_i
  {:arglists '([ifn1 ifn2 ielements & idstoffset* isrcoffset*])}
  [fn1 fn2 elements & [ dstoffset* srcoffset* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vmultv_i"
                      [fn1 fn2 elements dstoffset* srcoffset*]
                      *global*)]
    (new out-types ast)))

(s/fdef vmultv_i
  :args (s/cat :fn1 valid-i? :fn2 valid-i? :elements valid-i? :dstoffset* (s/? valid-i?*) :srcoffset* (s/? valid-i?*) ))
(stest/instrument `vmultv_i)

(defn pwd
  {:arglists '()}
  []
  (let [out-types-quoted 'String
        out-types String
        ast (ast-node out-types-quoted
                      "pwd"
                      []
                      *global*)]
    (new out-types ast)))


(defn strrindex
  {:arglists '([Sarg1 Sarg2])}
  [arg1 arg2]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "strrindex"
                      [arg1 arg2]
                      *global*)]
    (new out-types ast)))

(s/fdef strrindex
  :args (s/cat :arg1 valid-S? :arg2 valid-S? ))
(stest/instrument `strrindex)

(defn sprintfk
  {:arglists '([Sfmt iarg2 & xarg1* xarg2* xarg3* xarg4* xarg5* xarg6* xarg7* xarg8* xarg9* xarg10* xarg11* xarg12* xarg13* xarg14* xarg15* xarg16*] [Sfmt karg2 & xarg1* xarg2* xarg3* xarg4* xarg5* xarg6* xarg7* xarg8* xarg9* xarg10* xarg11* xarg12* xarg13* xarg14* xarg15* xarg16*] [Sfmt Sarg2 & xarg1* xarg2* xarg3* xarg4* xarg5* xarg6* xarg7* xarg8* xarg9* xarg10* xarg11* xarg12* xarg13* xarg14* xarg15* xarg16*])}
  [fmt arg2 & [ arg1* arg2* arg3* arg4* arg5* arg6* arg7* arg8* arg9* arg10* arg11* arg12* arg13* arg14* arg15* arg16* ]]
  (let [out-types-quoted 'String
        out-types String
        ast (ast-node out-types-quoted
                      "sprintfk"
                      [fmt arg2 arg1* arg2* arg3* arg4* arg5* arg6* arg7* arg8* arg9* arg10* arg11* arg12* arg13* arg14* arg15* arg16*]
                      *global*)]
    (new out-types ast)))

(s/fdef sprintfk
  :args (s/alt
         :SSxxxxxxxxxxxxxxxx (s/cat :fmt valid-S? :arg2 valid-S? :arg1* (s/? valid-x?*) :arg2* (s/? valid-x?*) :arg3* (s/? valid-x?*) :arg4* (s/? valid-x?*) :arg5* (s/? valid-x?*) :arg6* (s/? valid-x?*) :arg7* (s/? valid-x?*) :arg8* (s/? valid-x?*) :arg9* (s/? valid-x?*) :arg10* (s/? valid-x?*) :arg11* (s/? valid-x?*) :arg12* (s/? valid-x?*) :arg13* (s/? valid-x?*) :arg14* (s/? valid-x?*) :arg15* (s/? valid-x?*) :arg16* (s/? valid-x?*) )
         :Skxxxxxxxxxxxxxxxx (s/cat :fmt valid-S? :arg2 valid-kr? :arg1* (s/? valid-x?*) :arg2* (s/? valid-x?*) :arg3* (s/? valid-x?*) :arg4* (s/? valid-x?*) :arg5* (s/? valid-x?*) :arg6* (s/? valid-x?*) :arg7* (s/? valid-x?*) :arg8* (s/? valid-x?*) :arg9* (s/? valid-x?*) :arg10* (s/? valid-x?*) :arg11* (s/? valid-x?*) :arg12* (s/? valid-x?*) :arg13* (s/? valid-x?*) :arg14* (s/? valid-x?*) :arg15* (s/? valid-x?*) :arg16* (s/? valid-x?*) )
         :Sixxxxxxxxxxxxxxxx (s/cat :fmt valid-S? :arg2 valid-i? :arg1* (s/? valid-x?*) :arg2* (s/? valid-x?*) :arg3* (s/? valid-x?*) :arg4* (s/? valid-x?*) :arg5* (s/? valid-x?*) :arg6* (s/? valid-x?*) :arg7* (s/? valid-x?*) :arg8* (s/? valid-x?*) :arg9* (s/? valid-x?*) :arg10* (s/? valid-x?*) :arg11* (s/? valid-x?*) :arg12* (s/? valid-x?*) :arg13* (s/? valid-x?*) :arg14* (s/? valid-x?*) :arg15* (s/? valid-x?*) :arg16* (s/? valid-x?*) )
         ))
(stest/instrument `sprintfk)

(defn slicearray
  {:arglists '([ainarrayArr istart iend & istride*] [kinarrayArr istart iend & istride*] [SinarrayArr istart iend & istride*] [iinarrayArr istart iend & istride*])}
  [inarray start end & [ stride* ]]
  (let [out-types-quoted 'AudioArray
        out-types AudioArray
        ast (ast-node out-types-quoted
                      "slicearray"
                      [inarray start end stride*]
                      *global*)]
    (new out-types ast)))

(s/fdef slicearray
  :args (s/alt
         :iArriii (s/cat :inarray valid-iArr? :start valid-i? :end valid-i? :stride* (s/? valid-i?*) )
         :SArriii (s/cat :inarray valid-SArr? :start valid-i? :end valid-i? :stride* (s/? valid-i?*) )
         :kArriii (s/cat :inarray valid-kArr? :start valid-i? :end valid-i? :stride* (s/? valid-i?*) )
         :aArriii (s/cat :inarray valid-aArr? :start valid-i? :end valid-i? :stride* (s/? valid-i?*) )
         ))
(stest/instrument `slicearray)

(defn slicearray:aArr
  {:arglists '([ainarrayArr istart iend & istride*])}
  [inarray start end & [ stride* ]]
  (let [out-types-quoted 'AudioArray
        out-types AudioArray
        ast (ast-node out-types-quoted
                      "slicearray"
                      [inarray start end stride*]
                      *global*)]
    (new out-types ast)))

(s/fdef slicearray:aArr
  :args (s/cat :inarray valid-aArr? :start valid-i? :end valid-i? :stride* (s/? valid-i?*) ))
(stest/instrument `slicearray:aArr)

(defn slicearray:kArr
  {:arglists '([kinarrayArr istart iend & istride*])}
  [inarray start end & [ stride* ]]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "slicearray"
                      [inarray start end stride*]
                      *global*)]
    (new out-types ast)))

(s/fdef slicearray:kArr
  :args (s/cat :inarray valid-kArr? :start valid-i? :end valid-i? :stride* (s/? valid-i?*) ))
(stest/instrument `slicearray:kArr)

(defn slicearray:SArr
  {:arglists '([SinarrayArr istart iend & istride*])}
  [inarray start end & [ stride* ]]
  (let [out-types-quoted 'StringArray
        out-types StringArray
        ast (ast-node out-types-quoted
                      "slicearray"
                      [inarray start end stride*]
                      *global*)]
    (new out-types ast)))

(s/fdef slicearray:SArr
  :args (s/cat :inarray valid-SArr? :start valid-i? :end valid-i? :stride* (s/? valid-i?*) ))
(stest/instrument `slicearray:SArr)

(defn slicearray:iArr
  {:arglists '([iinarrayArr istart iend & istride*])}
  [inarray start end & [ stride* ]]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "slicearray"
                      [inarray start end stride*]
                      *global*)]
    (new out-types ast)))

(s/fdef slicearray:iArr
  :args (s/cat :inarray valid-iArr? :start valid-i? :end valid-i? :stride* (s/? valid-i?*) ))
(stest/instrument `slicearray:iArr)

(defn noteoff
  {:arglists '([ichn inum ivel])}
  [chn num vel]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "noteoff"
                      [chn num vel]
                      *global*)]
    (new out-types ast)))

(s/fdef noteoff
  :args (s/cat :chn valid-i? :num valid-i? :vel valid-i? ))
(stest/instrument `noteoff)

(defn sfinstr3
  {:arglists '([ivel inotenum xamp xfreq instrnum ifilhandle & iflag* ioffset* ioffset*])}
  [vel notenum amp freq nstrnum filhandle & [ flag* offset* offset* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "sfinstr3"
                      [vel notenum amp freq nstrnum filhandle flag* offset* offset*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef sfinstr3
  :args (s/cat :vel valid-i? :notenum valid-i? :amp valid-x? :freq valid-x? :nstrnum valid-i? :filhandle valid-i? :flag* (s/? valid-i?*) :offset* (s/? valid-i?*) :offset* (s/? valid-i?*) ))
(stest/instrument `sfinstr3)

(defn outletf
  {:arglists '([Sname fsignal])}
  [name signal]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outletf"
                      [name signal]
                      *global*)]
    (new out-types ast)))

(s/fdef outletf
  :args (s/cat :name valid-S? :signal valid-f? ))
(stest/instrument `outletf)

(defn vco2
  {:arglists '([kamp kcps & imode* kpw* kphase* inyx*])}
  [amp cps & [ mode* pw* phase* nyx* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "vco2"
                      [amp cps mode* pw* phase* nyx*]
                      *global*)]
    (new out-types ast)))

(s/fdef vco2
  :args (s/cat :amp valid-kr? :cps valid-kr? :mode* (s/? valid-i?*) :pw* (s/? valid-kr?*) :phase* (s/? valid-kr?*) :nyx* (s/? valid-i?*) ))
(stest/instrument `vco2)

(defn copya2ftab
  {:arglists '([iftblArr iab] [kftblArr kab])}
  [ftbl ab]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "copya2ftab"
                      [ftbl ab]
                      *global*)]
    (new out-types ast)))

(s/fdef copya2ftab
  :args (s/alt
         :kArrk (s/cat :ftbl valid-kArr? :ab valid-kr? )
         :iArri (s/cat :ftbl valid-iArr? :ab valid-i? )
         ))
(stest/instrument `copya2ftab)

(defn mdelay
  {:arglists '([kstatus kchan kd3 kd4 kdelay])}
  [status chan d3 d4 delay]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "mdelay"
                      [status chan d3 d4 delay]
                      *global*)]
    (new out-types ast)))

(s/fdef mdelay
  :args (s/cat :status valid-kr? :chan valid-kr? :d3 valid-kr? :d4 valid-kr? :delay valid-kr? ))
(stest/instrument `mdelay)

(defn trigseq
  {:arglists '([ktrig_in kstart kloop kinitndx kfn_values & kout1* kout2* kout3* kout4* kout5* kout6* kout7* kout8* kout9* kout10* kout11* kout12* kout13* kout14* kout15* kout16*])}
  [trig_in start loop initndx fn_values & [ out1* out2* out3* out4* out5* out6* out7* out8* out9* out10* out11* out12* out13* out14* out15* out16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "trigseq"
                      [trig_in start loop initndx fn_values out1* out2* out3* out4* out5* out6* out7* out8* out9* out10* out11* out12* out13* out14* out15* out16*]
                      *global*)]
    (new out-types ast)))

(s/fdef trigseq
  :args (s/cat :trig_in valid-kr? :start valid-kr? :loop valid-kr? :initndx valid-kr? :fn_values valid-kr? :out1* (s/? valid-kr?*) :out2* (s/? valid-kr?*) :out3* (s/? valid-kr?*) :out4* (s/? valid-kr?*) :out5* (s/? valid-kr?*) :out6* (s/? valid-kr?*) :out7* (s/? valid-kr?*) :out8* (s/? valid-kr?*) :out9* (s/? valid-kr?*) :out10* (s/? valid-kr?*) :out11* (s/? valid-kr?*) :out12* (s/? valid-kr?*) :out13* (s/? valid-kr?*) :out14* (s/? valid-kr?*) :out15* (s/? valid-kr?*) :out16* (s/? valid-kr?*) ))
(stest/instrument `trigseq)

(defn mfb
  {:arglists '([iinArr ilow ihigh ibands] [kinArr klow khigh ibands])}
  [in low high bands]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "mfb"
                      [in low high bands]
                      *global*)]
    (new out-types ast)))

(s/fdef mfb
  :args (s/alt
         :kArrkki (s/cat :in valid-kArr? :low valid-kr? :high valid-kr? :bands valid-i? )
         :iArriii (s/cat :in valid-iArr? :low valid-i? :high valid-i? :bands valid-i? )
         ))
(stest/instrument `mfb)

(defn mfb:iArr
  {:arglists '([iinArr ilow ihigh ibands])}
  [in low high bands]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "mfb"
                      [in low high bands]
                      *global*)]
    (new out-types ast)))

(s/fdef mfb:iArr
  :args (s/cat :in valid-iArr? :low valid-i? :high valid-i? :bands valid-i? ))
(stest/instrument `mfb:iArr)

(defn mfb:kArr
  {:arglists '([kinArr klow khigh ibands])}
  [in low high bands]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "mfb"
                      [in low high bands]
                      *global*)]
    (new out-types ast)))

(s/fdef mfb:kArr
  :args (s/cat :in valid-kArr? :low valid-kr? :high valid-kr? :bands valid-i? ))
(stest/instrument `mfb:kArr)

(defn mxadsr
  {:arglists '([iatt idec islev irel & idel* ireltim*] [iatt idec islev irel & idel* ireltim*])}
  [att dec slev rel & [ del* reltim* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "mxadsr"
                      [att dec slev rel del* reltim*]
                      *global*)]
    (new out-types ast)))

(s/fdef mxadsr
  :args (s/alt
         :iiiiii (s/cat :att valid-i? :dec valid-i? :slev valid-i? :rel valid-i? :del* (s/? valid-i?*) :reltim* (s/? valid-i?*) )
         ))
(stest/instrument `mxadsr)

(defn mxadsr:a
  {:arglists '([iatt idec islev irel & idel* ireltim*])}
  [att dec slev rel & [ del* reltim* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "mxadsr"
                      [att dec slev rel del* reltim*]
                      *global*)]
    (new out-types ast)))

(s/fdef mxadsr:a
  :args (s/cat :att valid-i? :dec valid-i? :slev valid-i? :rel valid-i? :del* (s/? valid-i?*) :reltim* (s/? valid-i?*) ))
(stest/instrument `mxadsr:a)

(defn mxadsr:k
  {:arglists '([iatt idec islev irel & idel* ireltim*])}
  [att dec slev rel & [ del* reltim* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "mxadsr"
                      [att dec slev rel del* reltim*]
                      *global*)]
    (new out-types ast)))

(s/fdef mxadsr:k
  :args (s/cat :att valid-i? :dec valid-i? :slev valid-i? :rel valid-i? :del* (s/? valid-i?*) :reltim* (s/? valid-i?*) ))
(stest/instrument `mxadsr:k)

(defn loopseg
  {:arglists '([kfreq ktrig iphase & kvalue1* ktime2* kvalue3* ktime4* kvalue5* ktime6* ktime7* ktime8* ktime9* ktime10* ktime11* ktime12* ktime13* ktime14* ktime15* ktime16*])}
  [freq trig phase & [ value1* time2* value3* time4* value5* time6* time7* time8* time9* time10* time11* time12* time13* time14* time15* time16* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "loopseg"
                      [freq trig phase value1* time2* value3* time4* value5* time6* time7* time8* time9* time10* time11* time12* time13* time14* time15* time16*]
                      *global*)]
    (new out-types ast)))

(s/fdef loopseg
  :args (s/cat :freq valid-kr? :trig valid-kr? :phase valid-i? :value1* (s/? valid-kr?*) :time2* (s/? valid-kr?*) :value3* (s/? valid-kr?*) :time4* (s/? valid-kr?*) :value5* (s/? valid-kr?*) :time6* (s/? valid-kr?*) :time7* (s/? valid-kr?*) :time8* (s/? valid-kr?*) :time9* (s/? valid-kr?*) :time10* (s/? valid-kr?*) :time11* (s/? valid-kr?*) :time12* (s/? valid-kr?*) :time13* (s/? valid-kr?*) :time14* (s/? valid-kr?*) :time15* (s/? valid-kr?*) :time16* (s/? valid-kr?*) ))
(stest/instrument `loopseg)

(defn grain2
  {:arglists '([kcps kfmd kgdur iovrlp ktable iwfn & irpow* iseed* imode*])}
  [cps fmd gdur ovrlp table wfn & [ rpow* seed* mode* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "grain2"
                      [cps fmd gdur ovrlp table wfn rpow* seed* mode*]
                      *global*)]
    (new out-types ast)))

(s/fdef grain2
  :args (s/cat :cps valid-kr? :fmd valid-kr? :gdur valid-kr? :ovrlp valid-i? :table valid-kr? :wfn valid-i? :rpow* (s/? valid-i?*) :seed* (s/? valid-i?*) :mode* (s/? valid-i?*) ))
(stest/instrument `grain2)

(defn vphaseseg
  {:arglists '([kphase ioutab ielems & itab1* idist2* itab3* idist4* itab5* idistN-6* itabN7* itabN8* itabN9* itabN10* itabN11* itabN12* itabN13* itabN14* itabN15* itabN16*])}
  [phase outab elems & [ tab1* dist2* tab3* dist4* tab5* distN-6* tabN7* tabN8* tabN9* tabN10* tabN11* tabN12* tabN13* tabN14* tabN15* tabN16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vphaseseg"
                      [phase outab elems tab1* dist2* tab3* dist4* tab5* distN-6* tabN7* tabN8* tabN9* tabN10* tabN11* tabN12* tabN13* tabN14* tabN15* tabN16*]
                      *global*)]
    (new out-types ast)))

(s/fdef vphaseseg
  :args (s/cat :phase valid-kr? :outab valid-i? :elems valid-i? :tab1* (s/? valid-i?*) :dist2* (s/? valid-i?*) :tab3* (s/? valid-i?*) :dist4* (s/? valid-i?*) :tab5* (s/? valid-i?*) :distN-6* (s/? valid-i?*) :tabN7* (s/? valid-i?*) :tabN8* (s/? valid-i?*) :tabN9* (s/? valid-i?*) :tabN10* (s/? valid-i?*) :tabN11* (s/? valid-i?*) :tabN12* (s/? valid-i?*) :tabN13* (s/? valid-i?*) :tabN14* (s/? valid-i?*) :tabN15* (s/? valid-i?*) :tabN16* (s/? valid-i?*) ))
(stest/instrument `vphaseseg)

(defn vtablewk
  {:arglists '([kindex ktable ixmode & kinarg1* kinarg2* kinarg3* kinargN4* kinargN5* kinargN6* kinargN7* kinargN8* kinargN9* kinargN10* kinargN11* kinargN12* kinargN13* kinargN14* kinargN15* kinargN16*])}
  [index table xmode & [ inarg1* inarg2* inarg3* inargN4* inargN5* inargN6* inargN7* inargN8* inargN9* inargN10* inargN11* inargN12* inargN13* inargN14* inargN15* inargN16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vtablewk"
                      [index table xmode inarg1* inarg2* inarg3* inargN4* inargN5* inargN6* inargN7* inargN8* inargN9* inargN10* inargN11* inargN12* inargN13* inargN14* inargN15* inargN16*]
                      *global*)]
    (new out-types ast)))

(s/fdef vtablewk
  :args (s/cat :index valid-kr? :table valid-kr? :xmode valid-i? :inarg1* (s/? valid-kr?*) :inarg2* (s/? valid-kr?*) :inarg3* (s/? valid-kr?*) :inargN4* (s/? valid-kr?*) :inargN5* (s/? valid-kr?*) :inargN6* (s/? valid-kr?*) :inargN7* (s/? valid-kr?*) :inargN8* (s/? valid-kr?*) :inargN9* (s/? valid-kr?*) :inargN10* (s/? valid-kr?*) :inargN11* (s/? valid-kr?*) :inargN12* (s/? valid-kr?*) :inargN13* (s/? valid-kr?*) :inargN14* (s/? valid-kr?*) :inargN15* (s/? valid-kr?*) :inargN16* (s/? valid-kr?*) ))
(stest/instrument `vtablewk)

(defn loscil
  {:arglists '([xamp kcps & itable* ibas* imod1* ibeg1* iend1* imod1* ibeg1* iend1*])}
  [amp cps & [ table* bas* mod1* beg1* end1* mod1* beg1* end1* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "loscil"
                      [amp cps table* bas* mod1* beg1* end1* mod1* beg1* end1*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef loscil
  :args (s/cat :amp valid-x? :cps valid-kr? :table* (s/? valid-i?*) :bas* (s/? valid-i?*) :mod1* (s/? valid-i?*) :beg1* (s/? valid-i?*) :end1* (s/? valid-i?*) :mod1* (s/? valid-i?*) :beg1* (s/? valid-i?*) :end1* (s/? valid-i?*) ))
(stest/instrument `loscil)

(defn monitor
  {:arglists '( )}
  []
  (let [out-types-quoted 'AudioArray
        out-types AudioArray
        ast (ast-node out-types-quoted
                      "monitor"
                      []
                      *global*)]
    (new out-types ast)))


(defn monitor:aArr
  {:arglists '()}
  []
  (let [out-types-quoted 'AudioArray
        out-types AudioArray
        ast (ast-node out-types-quoted
                      "monitor"
                      []
                      *global*)]
    (new out-types ast)))


(defn monitor:a
  {:arglists '()}
  []
  (let [out-types-quoted '[AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "monitor"
                      []
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))


(defn rezzy
  {:arglists '([asig xcutoff-frequency xresonance & imode* iskip*])}
  [sig cutoff-frequency resonance & [ mode* skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "rezzy"
                      [sig cutoff-frequency resonance mode* skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef rezzy
  :args (s/cat :sig valid-ar? :cutoff-frequency valid-x? :resonance valid-x? :mode* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `rezzy)

(defn chani
  {:arglists '([kchan] [kchan])}
  [chan]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "chani"
                      [chan]
                      *global*)]
    (new out-types ast)))

(s/fdef chani
  :args (s/alt
         :k (s/cat :chan valid-kr? )
         ))
(stest/instrument `chani)

(defn chani:a
  {:arglists '([kchan])}
  [chan]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "chani"
                      [chan]
                      *global*)]
    (new out-types ast)))

(s/fdef chani:a
  :args (s/cat :chan valid-kr? ))
(stest/instrument `chani:a)

(defn chani:k
  {:arglists '([kchan])}
  [chan]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "chani"
                      [chan]
                      *global*)]
    (new out-types ast)))

(s/fdef chani:k
  :args (s/cat :chan valid-kr? ))
(stest/instrument `chani:k)

(defn inch
  {:arglists '([kchan1] [& kchan1* kchan2* kchan3* kchan4* kchan5* kchan6* kchan7* kchan8* kchan9* kchan10* kchan11* kchan12* kchan13* kchan14* kchan15* kchan16*])}
  [chan1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "inch"
                      [chan1]
                      *global*)]
    (new out-types ast)))

(s/fdef inch
  :args (s/alt
         :kkkkkkkkkkkkkkkk (s/cat :chan1* (s/? valid-kr?*) :chan2* (s/? valid-kr?*) :chan3* (s/? valid-kr?*) :chan4* (s/? valid-kr?*) :chan5* (s/? valid-kr?*) :chan6* (s/? valid-kr?*) :chan7* (s/? valid-kr?*) :chan8* (s/? valid-kr?*) :chan9* (s/? valid-kr?*) :chan10* (s/? valid-kr?*) :chan11* (s/? valid-kr?*) :chan12* (s/? valid-kr?*) :chan13* (s/? valid-kr?*) :chan14* (s/? valid-kr?*) :chan15* (s/? valid-kr?*) :chan16* (s/? valid-kr?*) )
         :k (s/cat :chan1 valid-kr? )
         ))
(stest/instrument `inch)

(defn inch:a
  {:arglists '([kchan1] [& kchan1* kchan2* kchan3* kchan4* kchan5* kchan6* kchan7* kchan8* kchan9* kchan10* kchan11* kchan12* kchan13* kchan14* kchan15* kchan16*])}
  [chan1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "inch"
                      [chan1]
                      *global*)]
    (new out-types ast)))

(s/fdef inch:a
  :args (s/alt
         :kkkkkkkkkkkkkkkk (s/cat :chan1* (s/? valid-kr?*) :chan2* (s/? valid-kr?*) :chan3* (s/? valid-kr?*) :chan4* (s/? valid-kr?*) :chan5* (s/? valid-kr?*) :chan6* (s/? valid-kr?*) :chan7* (s/? valid-kr?*) :chan8* (s/? valid-kr?*) :chan9* (s/? valid-kr?*) :chan10* (s/? valid-kr?*) :chan11* (s/? valid-kr?*) :chan12* (s/? valid-kr?*) :chan13* (s/? valid-kr?*) :chan14* (s/? valid-kr?*) :chan15* (s/? valid-kr?*) :chan16* (s/? valid-kr?*) )
         :k (s/cat :chan1 valid-kr? )
         ))
(stest/instrument `inch:a)

(defn fft
  {:arglists '([iinArr] [kinArr])}
  [in]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "fft"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef fft
  :args (s/alt
         :kArr (s/cat :in valid-kArr? )
         :iArr (s/cat :in valid-iArr? )
         ))
(stest/instrument `fft)

(defn fft:iArr
  {:arglists '([iinArr])}
  [in]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "fft"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef fft:iArr
  :args (s/cat :in valid-iArr? ))
(stest/instrument `fft:iArr)

(defn fft:kArr
  {:arglists '([kinArr])}
  [in]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "fft"
                      [in]
                      *global*)]
    (new out-types ast)))

(s/fdef fft:kArr
  :args (s/cat :in valid-kArr? ))
(stest/instrument `fft:kArr)

(defn rms
  {:arglists '([asig & ihp* iskip*])}
  [sig & [ hp* skip* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "rms"
                      [sig hp* skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef rms
  :args (s/cat :sig valid-ar? :hp* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `rms)

(defn strcpyk
  {:arglists '([Ssrc] [ksrc])}
  [src]
  (let [out-types-quoted 'String
        out-types String
        ast (ast-node out-types-quoted
                      "strcpyk"
                      [src]
                      *global*)]
    (new out-types ast)))

(s/fdef strcpyk
  :args (s/alt
         :k (s/cat :src valid-kr? )
         :S (s/cat :src valid-S? )
         ))
(stest/instrument `strcpyk)

(defn pitch
  {:arglists '([asig iupdte ilo ihi idbthresh & ifrqs* iconf* istrt* iocts* iq* inptls* irolloff* iskip*])}
  [sig updte lo hi dbthresh & [ frqs* conf* strt* octs* q* nptls* rolloff* skip* ]]
  (let [out-types-quoted '[ControlSignal ControlSignal]
        out-types [ControlSignal ControlSignal]
        ast (ast-node out-types-quoted
                      "pitch"
                      [sig updte lo hi dbthresh frqs* conf* strt* octs* q* nptls* rolloff* skip*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef pitch
  :args (s/cat :sig valid-ar? :updte valid-i? :lo valid-i? :hi valid-i? :dbthresh valid-i? :frqs* (s/? valid-i?*) :conf* (s/? valid-i?*) :strt* (s/? valid-i?*) :octs* (s/? valid-i?*) :q* (s/? valid-i?*) :nptls* (s/? valid-i?*) :rolloff* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `pitch)

(defn midinoteoncps
  {:arglists '([xcps xvelocity])}
  [cps velocity]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "midinoteoncps"
                      [cps velocity]
                      *global*)]
    (new out-types ast)))

(s/fdef midinoteoncps
  :args (s/cat :cps valid-x? :velocity valid-x? ))
(stest/instrument `midinoteoncps)

(defn serialRead
  {:arglists '([iPort])}
  [Port]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "serialRead"
                      [Port]
                      *global*)]
    (new out-types ast)))

(s/fdef serialRead
  :args (s/cat :Port valid-i? ))
(stest/instrument `serialRead)

(defn printk
  {:arglists '([itime kval & ispace*])}
  [time val & [ space* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "printk"
                      [time val space*]
                      *global*)]
    (new out-types ast)))

(s/fdef printk
  :args (s/cat :time valid-i? :val valid-kr? :space* (s/? valid-i?*) ))
(stest/instrument `printk)

(defn hvs2
  {:arglists '([kx ky inumParms inumPointsX inumPointsY iOutTab iPositionsTab iSnapTab & iConfigTab*])}
  [x y numParms numPointsX numPointsY OutTab PositionsTab SnapTab & [ ConfigTab* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "hvs2"
                      [x y numParms numPointsX numPointsY OutTab PositionsTab SnapTab ConfigTab*]
                      *global*)]
    (new out-types ast)))

(s/fdef hvs2
  :args (s/cat :x valid-kr? :y valid-kr? :numParms valid-i? :numPointsX valid-i? :numPointsY valid-i? :OutTab valid-i? :PositionsTab valid-i? :SnapTab valid-i? :ConfigTab* (s/? valid-i?*) ))
(stest/instrument `hvs2)

(defn fareylen
  {:arglists '([ktable])}
  [table]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "fareylen"
                      [table]
                      *global*)]
    (new out-types ast)))

(s/fdef fareylen
  :args (s/cat :table valid-kr? ))
(stest/instrument `fareylen)

(defn expsegb
  {:arglists '([ia itim2 & ib1* itim2* ic3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*] [ia itim2 & ib1* itim2* ic3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a tim2 & [ b1* tim2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "expsegb"
                      [a tim2 b1* tim2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef expsegb
  :args (s/alt
         :iiiiiiiiiiiiiiiiii (s/cat :a valid-i? :tim2 valid-i? :b1* (s/? valid-i?*) :tim2* (s/? valid-i?*) :c3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) )
         ))
(stest/instrument `expsegb)

(defn expsegb:a
  {:arglists '([ia itim2 & ib1* itim2* ic3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a tim2 & [ b1* tim2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "expsegb"
                      [a tim2 b1* tim2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef expsegb:a
  :args (s/cat :a valid-i? :tim2 valid-i? :b1* (s/? valid-i?*) :tim2* (s/? valid-i?*) :c3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) ))
(stest/instrument `expsegb:a)

(defn expsegb:k
  {:arglists '([ia itim2 & ib1* itim2* ic3* ic4* ic5* ic6* ic7* ic8* ic9* ic10* ic11* ic12* ic13* ic14* ic15* ic16*])}
  [a tim2 & [ b1* tim2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "expsegb"
                      [a tim2 b1* tim2* c3* c4* c5* c6* c7* c8* c9* c10* c11* c12* c13* c14* c15* c16*]
                      *global*)]
    (new out-types ast)))

(s/fdef expsegb:k
  :args (s/cat :a valid-i? :tim2 valid-i? :b1* (s/? valid-i?*) :tim2* (s/? valid-i?*) :c3* (s/? valid-i?*) :c4* (s/? valid-i?*) :c5* (s/? valid-i?*) :c6* (s/? valid-i?*) :c7* (s/? valid-i?*) :c8* (s/? valid-i?*) :c9* (s/? valid-i?*) :c10* (s/? valid-i?*) :c11* (s/? valid-i?*) :c12* (s/? valid-i?*) :c13* (s/? valid-i?*) :c14* (s/? valid-i?*) :c15* (s/? valid-i?*) :c16* (s/? valid-i?*) ))
(stest/instrument `expsegb:k)

(defn maxabsaccum
  {:arglists '([aAccumulator aInput])}
  [Accumulator Input]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "maxabsaccum"
                      [Accumulator Input]
                      *global*)]
    (new out-types ast)))

(s/fdef maxabsaccum
  :args (s/cat :Accumulator valid-ar? :Input valid-ar? ))
(stest/instrument `maxabsaccum)

(defn zkw
  {:arglists '([ksig kindex])}
  [sig index]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "zkw"
                      [sig index]
                      *global*)]
    (new out-types ast)))

(s/fdef zkw
  :args (s/cat :sig valid-kr? :index valid-kr? ))
(stest/instrument `zkw)

(defn resyn
  {:arglists '([fin kscal kpitch kmaxtracks itable & itable*])}
  [in scal pitch maxtracks table & [ table* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "resyn"
                      [in scal pitch maxtracks table table*]
                      *global*)]
    (new out-types ast)))

(s/fdef resyn
  :args (s/cat :in valid-f? :scal valid-kr? :pitch valid-kr? :maxtracks valid-kr? :table valid-i? :table* (s/? valid-i?*) ))
(stest/instrument `resyn)

(defn ntrpol
  {:arglists '([asig1 asig2 kpoint & imin* imax*] [isig1 isig2 ipoint & imin* imax*] [ksig1 ksig2 kpoint & imin* imax*])}
  [sig1 sig2 point & [ min* max* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "ntrpol"
                      [sig1 sig2 point min* max*]
                      *global*)]
    (new out-types ast)))

(s/fdef ntrpol
  :args (s/alt
         :kkkii (s/cat :sig1 valid-kr? :sig2 valid-kr? :point valid-kr? :min* (s/? valid-i?*) :max* (s/? valid-i?*) )
         :iiiii (s/cat :sig1 valid-i? :sig2 valid-i? :point valid-i? :min* (s/? valid-i?*) :max* (s/? valid-i?*) )
         :aakii (s/cat :sig1 valid-ar? :sig2 valid-ar? :point valid-kr? :min* (s/? valid-i?*) :max* (s/? valid-i?*) )
         ))
(stest/instrument `ntrpol)

(defn ntrpol:a
  {:arglists '([asig1 asig2 kpoint & imin* imax*])}
  [sig1 sig2 point & [ min* max* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "ntrpol"
                      [sig1 sig2 point min* max*]
                      *global*)]
    (new out-types ast)))

(s/fdef ntrpol:a
  :args (s/cat :sig1 valid-ar? :sig2 valid-ar? :point valid-kr? :min* (s/? valid-i?*) :max* (s/? valid-i?*) ))
(stest/instrument `ntrpol:a)

(defn ntrpol:i
  {:arglists '([isig1 isig2 ipoint & imin* imax*])}
  [sig1 sig2 point & [ min* max* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "ntrpol"
                      [sig1 sig2 point min* max*]
                      *global*)]
    (new out-types ast)))

(s/fdef ntrpol:i
  :args (s/cat :sig1 valid-i? :sig2 valid-i? :point valid-i? :min* (s/? valid-i?*) :max* (s/? valid-i?*) ))
(stest/instrument `ntrpol:i)

(defn ntrpol:k
  {:arglists '([ksig1 ksig2 kpoint & imin* imax*])}
  [sig1 sig2 point & [ min* max* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "ntrpol"
                      [sig1 sig2 point min* max*]
                      *global*)]
    (new out-types ast)))

(s/fdef ntrpol:k
  :args (s/cat :sig1 valid-kr? :sig2 valid-kr? :point valid-kr? :min* (s/? valid-i?*) :max* (s/? valid-i?*) ))
(stest/instrument `ntrpol:k)

(defn imagecreate
  {:arglists '([iwidth iheight])}
  [width height]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "imagecreate"
                      [width height]
                      *global*)]
    (new out-types ast)))

(s/fdef imagecreate
  :args (s/cat :width valid-i? :height valid-i? ))
(stest/instrument `imagecreate)

(defn dcblock2
  {:arglists '([ain & iorder* iskip*])}
  [in & [ order* skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "dcblock2"
                      [in order* skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef dcblock2
  :args (s/cat :in valid-ar? :order* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `dcblock2)

(defn mvclpf2
  {:arglists '([ain acenter-frequency aresonance & istor*] [ain acenter-frequency kresonance & istor*] [ain kcenter-frequency aresonance & istor*] [ain kcenter-frequency kresonance & istor*])}
  [in center-frequency resonance & [ stor* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "mvclpf2"
                      [in center-frequency resonance stor*]
                      *global*)]
    (new out-types ast)))

(s/fdef mvclpf2
  :args (s/alt
         :akki (s/cat :in valid-ar? :center-frequency valid-kr? :resonance valid-kr? :stor* (s/? valid-i?*) )
         :akai (s/cat :in valid-ar? :center-frequency valid-kr? :resonance valid-ar? :stor* (s/? valid-i?*) )
         :aaki (s/cat :in valid-ar? :center-frequency valid-ar? :resonance valid-kr? :stor* (s/? valid-i?*) )
         :aaai (s/cat :in valid-ar? :center-frequency valid-ar? :resonance valid-ar? :stor* (s/? valid-i?*) )
         ))
(stest/instrument `mvclpf2)

(defn zkr
  {:arglists '([kindex])}
  [index]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "zkr"
                      [index]
                      *global*)]
    (new out-types ast)))

(s/fdef zkr
  :args (s/cat :index valid-kr? ))
(stest/instrument `zkr)

(defn tanh
  {:arglists '([aarg1] [iarg1] [iarg1Arr] [karg1] [karg1Arr])}
  [arg1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "tanh"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef tanh
  :args (s/alt
         :kArr (s/cat :arg1 valid-kArr? )
         :k (s/cat :arg1 valid-kr? )
         :iArr (s/cat :arg1 valid-iArr? )
         :i (s/cat :arg1 valid-i? )
         :a (s/cat :arg1 valid-ar? )
         ))
(stest/instrument `tanh)

(defn tanh:a
  {:arglists '([aarg1])}
  [arg1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "tanh"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef tanh:a
  :args (s/cat :arg1 valid-ar? ))
(stest/instrument `tanh:a)

(defn tanh:i
  {:arglists '([iarg1])}
  [arg1]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "tanh"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef tanh:i
  :args (s/cat :arg1 valid-i? ))
(stest/instrument `tanh:i)

(defn tanh:iArr
  {:arglists '([iarg1Arr])}
  [arg1]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "tanh"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef tanh:iArr
  :args (s/cat :arg1 valid-iArr? ))
(stest/instrument `tanh:iArr)

(defn tanh:k
  {:arglists '([karg1])}
  [arg1]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "tanh"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef tanh:k
  :args (s/cat :arg1 valid-kr? ))
(stest/instrument `tanh:k)

(defn tanh:kArr
  {:arglists '([karg1Arr])}
  [arg1]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "tanh"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef tanh:kArr
  :args (s/cat :arg1 valid-kArr? ))
(stest/instrument `tanh:kArr)

(defn pvstencil
  {:arglists '([fsigin kgain klevel iftable])}
  [sigin gain level ftable]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvstencil"
                      [sigin gain level ftable]
                      *global*)]
    (new out-types ast)))

(s/fdef pvstencil
  :args (s/cat :sigin valid-f? :gain valid-kr? :level valid-kr? :ftable valid-i? ))
(stest/instrument `pvstencil)

(defn pluck
  {:arglists '([kamp kcps icps itable imeth & iparm1* iparm1*])}
  [amp cps cps table meth & [ parm1* parm1* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "pluck"
                      [amp cps cps table meth parm1* parm1*]
                      *global*)]
    (new out-types ast)))

(s/fdef pluck
  :args (s/cat :amp valid-kr? :cps valid-kr? :cps valid-i? :table valid-i? :meth valid-i? :parm1* (s/? valid-i?*) :parm1* (s/? valid-i?*) ))
(stest/instrument `pluck)

(defn babo
  {:arglists '([asig ksrcx ksrcy ksrcz irx iry irz & idiff* ifno*])}
  [sig srcx srcy srcz rx ry rz & [ diff* fno* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "babo"
                      [sig srcx srcy srcz rx ry rz diff* fno*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef babo
  :args (s/cat :sig valid-ar? :srcx valid-kr? :srcy valid-kr? :srcz valid-kr? :rx valid-i? :ry valid-i? :rz valid-i? :diff* (s/? valid-i?*) :fno* (s/? valid-i?*) ))
(stest/instrument `babo)

(defn xyscale
  {:arglists '([kx ky iZeroZero iOneZero iZeroOne iOneOne] [kx ky kZeroZero kOneZero kZeroOne kOneOne])}
  [x y ZeroZero OneZero ZeroOne OneOne]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "xyscale"
                      [x y ZeroZero OneZero ZeroOne OneOne]
                      *global*)]
    (new out-types ast)))

(s/fdef xyscale
  :args (s/alt
         :kkkkkk (s/cat :x valid-kr? :y valid-kr? :ZeroZero valid-kr? :OneZero valid-kr? :ZeroOne valid-kr? :OneOne valid-kr? )
         :kkiiii (s/cat :x valid-kr? :y valid-kr? :ZeroZero valid-i? :OneZero valid-i? :ZeroOne valid-i? :OneOne valid-i? )
         ))
(stest/instrument `xyscale)

(defn lpreson
  {:arglists '([asig])}
  [sig]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "lpreson"
                      [sig]
                      *global*)]
    (new out-types ast)))

(s/fdef lpreson
  :args (s/cat :sig valid-ar? ))
(stest/instrument `lpreson)

(defn gain
  {:arglists '([asig krms & ihp* iskip*])}
  [sig rms & [ hp* skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "gain"
                      [sig rms hp* skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef gain
  :args (s/cat :sig valid-ar? :rms valid-kr? :hp* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `gain)

(defn sfpassign
  {:arglists '([istartindex ifilhandle & imsgs*])}
  [startindex filhandle & [ msgs* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "sfpassign"
                      [startindex filhandle msgs*]
                      *global*)]
    (new out-types ast)))

(s/fdef sfpassign
  :args (s/cat :startindex valid-i? :filhandle valid-i? :msgs* (s/? valid-i?*) ))
(stest/instrument `sfpassign)

(defn flanger
  {:arglists '([asig adel kfeedback imaxd])}
  [sig del feedback maxd]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "flanger"
                      [sig del feedback maxd]
                      *global*)]
    (new out-types ast)))

(s/fdef flanger
  :args (s/cat :sig valid-ar? :del valid-ar? :feedback valid-kr? :maxd valid-i? ))
(stest/instrument `flanger)

(defn pvadd
  {:arglists '([ktimpnt kfmod Sfilcod itable ibins & ibinoffset* ibinincr* iextractmode* ifreqlim* igatefn*] [ktimpnt kfmod ifilcod itable ibins & ibinoffset* ibinincr* iextractmode* ifreqlim* igatefn*])}
  [timpnt fmod filcod table bins & [ binoffset* binincr* extractmode* freqlim* gatefn* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "pvadd"
                      [timpnt fmod filcod table bins binoffset* binincr* extractmode* freqlim* gatefn*]
                      *global*)]
    (new out-types ast)))

(s/fdef pvadd
  :args (s/alt
         :kkiiiiiiii (s/cat :timpnt valid-kr? :fmod valid-kr? :filcod valid-i? :table valid-i? :bins valid-i? :binoffset* (s/? valid-i?*) :binincr* (s/? valid-i?*) :extractmode* (s/? valid-i?*) :freqlim* (s/? valid-i?*) :gatefn* (s/? valid-i?*) )
         :kkSiiiiiii (s/cat :timpnt valid-kr? :fmod valid-kr? :filcod valid-S? :table valid-i? :bins valid-i? :binoffset* (s/? valid-i?*) :binincr* (s/? valid-i?*) :extractmode* (s/? valid-i?*) :freqlim* (s/? valid-i?*) :gatefn* (s/? valid-i?*) )
         ))
(stest/instrument `pvadd)

(defn reverbsc
  {:arglists '([ainL ainR kfblvl kcutoff-frequency & israte* ipitchm* iskip*])}
  [inL inR fblvl cutoff-frequency & [ srate* pitchm* skip* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "reverbsc"
                      [inL inR fblvl cutoff-frequency srate* pitchm* skip*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef reverbsc
  :args (s/cat :inL valid-ar? :inR valid-ar? :fblvl valid-kr? :cutoff-frequency valid-kr? :srate* (s/? valid-i?*) :pitchm* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `reverbsc)

(defn binit
  {:arglists '([fin isize])}
  [in size]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "binit"
                      [in size]
                      *global*)]
    (new out-types ast)))

(s/fdef binit
  :args (s/cat :in valid-f? :size valid-i? ))
(stest/instrument `binit)

(defn ATSreadnz
  {:arglists '([ktimepnt Satsfile iband] [ktimepnt iatsfile iband])}
  [timepnt atsfile band]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "ATSreadnz"
                      [timepnt atsfile band]
                      *global*)]
    (new out-types ast)))

(s/fdef ATSreadnz
  :args (s/alt
         :kii (s/cat :timepnt valid-kr? :atsfile valid-i? :band valid-i? )
         :kSi (s/cat :timepnt valid-kr? :atsfile valid-S? :band valid-i? )
         ))
(stest/instrument `ATSreadnz)

(defn log2
  {:arglists '([aarg1] [iarg1] [iarg1Arr] [karg1] [karg1Arr])}
  [arg1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "log2"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef log2
  :args (s/alt
         :kArr (s/cat :arg1 valid-kArr? )
         :k (s/cat :arg1 valid-kr? )
         :iArr (s/cat :arg1 valid-iArr? )
         :i (s/cat :arg1 valid-i? )
         :a (s/cat :arg1 valid-ar? )
         ))
(stest/instrument `log2)

(defn log2:a
  {:arglists '([aarg1])}
  [arg1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "log2"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef log2:a
  :args (s/cat :arg1 valid-ar? ))
(stest/instrument `log2:a)

(defn log2:i
  {:arglists '([iarg1])}
  [arg1]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "log2"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef log2:i
  :args (s/cat :arg1 valid-i? ))
(stest/instrument `log2:i)

(defn log2:iArr
  {:arglists '([iarg1Arr])}
  [arg1]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "log2"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef log2:iArr
  :args (s/cat :arg1 valid-iArr? ))
(stest/instrument `log2:iArr)

(defn log2:k
  {:arglists '([karg1])}
  [arg1]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "log2"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef log2:k
  :args (s/cat :arg1 valid-kr? ))
(stest/instrument `log2:k)

(defn log2:kArr
  {:arglists '([karg1Arr])}
  [arg1]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "log2"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef log2:kArr
  :args (s/cat :arg1 valid-kArr? ))
(stest/instrument `log2:kArr)

(defn shaker
  {:arglists '([kamp kfreq kbeans kdamp ktimes & idecay*])}
  [amp freq beans damp times & [ decay* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "shaker"
                      [amp freq beans damp times decay*]
                      *global*)]
    (new out-types ast)))

(s/fdef shaker
  :args (s/cat :amp valid-kr? :freq valid-kr? :beans valid-kr? :damp valid-kr? :times valid-kr? :decay* (s/? valid-i?*) ))
(stest/instrument `shaker)

(defn plltrack
  {:arglists '([asig kd & kloopf* kloopq* klf* khf* kthresh*])}
  [sig d & [ loopf* loopq* lf* hf* thresh* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "plltrack"
                      [sig d loopf* loopq* lf* hf* thresh*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef plltrack
  :args (s/cat :sig valid-ar? :d valid-kr? :loopf* (s/? valid-kr?*) :loopq* (s/? valid-kr?*) :lf* (s/? valid-kr?*) :hf* (s/? valid-kr?*) :thresh* (s/? valid-kr?*) ))
(stest/instrument `plltrack)

(defn oscil1i
  {:arglists '([idel kamp idur & itable*])}
  [del amp dur & [ table* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "oscil1i"
                      [del amp dur table*]
                      *global*)]
    (new out-types ast)))

(s/fdef oscil1i
  :args (s/cat :del valid-i? :amp valid-kr? :dur valid-i? :table* (s/? valid-i?*) ))
(stest/instrument `oscil1i)

(defn oscils
  {:arglists '([iamp icps iphase & iflg*])}
  [amp cps phase & [ flg* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "oscils"
                      [amp cps phase flg*]
                      *global*)]
    (new out-types ast)))

(s/fdef oscils
  :args (s/cat :amp valid-i? :cps valid-i? :phase valid-i? :flg* (s/? valid-i?*) ))
(stest/instrument `oscils)

(defn mididefault
  {:arglists '([xdefault xvalue])}
  [default value]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "mididefault"
                      [default value]
                      *global*)]
    (new out-types ast)))

(s/fdef mididefault
  :args (s/cat :default valid-x? :value valid-x? ))
(stest/instrument `mididefault)

(defn zdf_2pole
  {:arglists '([ain xcenter-frequency xQ & kmode* istor*])}
  [in center-frequency Q & [ mode* stor* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "zdf_2pole"
                      [in center-frequency Q mode* stor*]
                      *global*)]
    (new out-types ast)))

(s/fdef zdf_2pole
  :args (s/cat :in valid-ar? :center-frequency valid-x? :Q valid-x? :mode* (s/? valid-kr?*) :stor* (s/? valid-i?*) ))
(stest/instrument `zdf_2pole)

(defn hrtfstat
  {:arglists '([asrc iAz iElev Sfilel Sfiler & iradius* isr*])}
  [src Az Elev filel filer & [ radius* sr* ]]
  (let [out-types-quoted '[AudioSignal AudioSignal]
        out-types [AudioSignal AudioSignal]
        ast (ast-node out-types-quoted
                      "hrtfstat"
                      [src Az Elev filel filer radius* sr*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef hrtfstat
  :args (s/cat :src valid-ar? :Az valid-i? :Elev valid-i? :filel valid-S? :filer valid-S? :radius* (s/? valid-i?*) :sr* (s/? valid-i?*) ))
(stest/instrument `hrtfstat)

(defn fofilter
  {:arglists '([ain xcenter-frequency xris xdec & istor*])}
  [in center-frequency ris dec & [ stor* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "fofilter"
                      [in center-frequency ris dec stor*]
                      *global*)]
    (new out-types ast)))

(s/fdef fofilter
  :args (s/cat :in valid-ar? :center-frequency valid-x? :ris valid-x? :dec valid-x? :stor* (s/? valid-i?*) ))
(stest/instrument `fofilter)

(defn vosim
  {:arglists '([kamp kFund kForm kDecay kPulseCount kPulseFactor itable & iskip*])}
  [amp Fund Form Decay PulseCount PulseFactor table & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "vosim"
                      [amp Fund Form Decay PulseCount PulseFactor table skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef vosim
  :args (s/cat :amp valid-kr? :Fund valid-kr? :Form valid-kr? :Decay valid-kr? :PulseCount valid-kr? :PulseFactor valid-kr? :table valid-i? :skip* (s/? valid-i?*) ))
(stest/instrument `vosim)

(defn mrtmsg
  {:arglists '([imsgtype])}
  [msgtype]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "mrtmsg"
                      [msgtype]
                      *global*)]
    (new out-types ast)))

(s/fdef mrtmsg
  :args (s/cat :msgtype valid-i? ))
(stest/instrument `mrtmsg)

(defn foscili
  {:arglists '([xamp kcps xcar xmod kindex & itable* iphase*])}
  [amp cps car mod index & [ table* phase* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "foscili"
                      [amp cps car mod index table* phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef foscili
  :args (s/cat :amp valid-x? :cps valid-kr? :car valid-x? :mod valid-x? :index valid-kr? :table* (s/? valid-i?*) :phase* (s/? valid-i?*) ))
(stest/instrument `foscili)

(defn tablexkt
  {:arglists '([xindex ktable kwarp iwsize & ixmode* ixoff* iwrap*])}
  [index table warp wsize & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "tablexkt"
                      [index table warp wsize xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef tablexkt
  :args (s/cat :index valid-x? :table valid-kr? :warp valid-kr? :wsize valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) ))
(stest/instrument `tablexkt)

(defn outkat
  {:arglists '([kchn kvalue kmin kmax])}
  [chn value min max]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "outkat"
                      [chn value min max]
                      *global*)]
    (new out-types ast)))

(s/fdef outkat
  :args (s/cat :chn valid-kr? :value valid-kr? :min valid-kr? :max valid-kr? ))
(stest/instrument `outkat)

(defn vpowv_i
  {:arglists '([ifn1 ifn2 ielements & idstoffset* isrcoffset*])}
  [fn1 fn2 elements & [ dstoffset* srcoffset* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vpowv_i"
                      [fn1 fn2 elements dstoffset* srcoffset*]
                      *global*)]
    (new out-types ast)))

(s/fdef vpowv_i
  :args (s/cat :fn1 valid-i? :fn2 valid-i? :elements valid-i? :dstoffset* (s/? valid-i?*) :srcoffset* (s/? valid-i?*) ))
(stest/instrument `vpowv_i)

(defn tradsyn
  {:arglists '([fin kscal kpitch kmaxtracks itable & itable*])}
  [in scal pitch maxtracks table & [ table* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "tradsyn"
                      [in scal pitch maxtracks table table*]
                      *global*)]
    (new out-types ast)))

(s/fdef tradsyn
  :args (s/cat :in valid-f? :scal valid-kr? :pitch valid-kr? :maxtracks valid-kr? :table valid-i? :table* (s/? valid-i?*) ))
(stest/instrument `tradsyn)

(defn ftom
  {:arglists '([ifreq] [kfreq])}
  [freq]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "ftom"
                      [freq]
                      *global*)]
    (new out-types ast)))

(s/fdef ftom
  :args (s/alt
         :k (s/cat :freq valid-kr? )
         :i (s/cat :freq valid-i? )
         ))
(stest/instrument `ftom)

(defn ftom:i
  {:arglists '([ifreq])}
  [freq]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "ftom"
                      [freq]
                      *global*)]
    (new out-types ast)))

(s/fdef ftom:i
  :args (s/cat :freq valid-i? ))
(stest/instrument `ftom:i)

(defn ftom:k
  {:arglists '([kfreq])}
  [freq]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "ftom"
                      [freq]
                      *global*)]
    (new out-types ast)))

(s/fdef ftom:k
  :args (s/cat :freq valid-kr? ))
(stest/instrument `ftom:k)

(defn polynomial
  {:arglists '([ain & karg1* karg2* karg3* karg4* karg5* karg6* karg7* karg8* karg9* karg10* karg11* karg12* karg13* karg14* karg15* karg16*])}
  [in & [ arg1* arg2* arg3* arg4* arg5* arg6* arg7* arg8* arg9* arg10* arg11* arg12* arg13* arg14* arg15* arg16* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "polynomial"
                      [in arg1* arg2* arg3* arg4* arg5* arg6* arg7* arg8* arg9* arg10* arg11* arg12* arg13* arg14* arg15* arg16*]
                      *global*)]
    (new out-types ast)))

(s/fdef polynomial
  :args (s/cat :in valid-ar? :arg1* (s/? valid-kr?*) :arg2* (s/? valid-kr?*) :arg3* (s/? valid-kr?*) :arg4* (s/? valid-kr?*) :arg5* (s/? valid-kr?*) :arg6* (s/? valid-kr?*) :arg7* (s/? valid-kr?*) :arg8* (s/? valid-kr?*) :arg9* (s/? valid-kr?*) :arg10* (s/? valid-kr?*) :arg11* (s/? valid-kr?*) :arg12* (s/? valid-kr?*) :arg13* (s/? valid-kr?*) :arg14* (s/? valid-kr?*) :arg15* (s/? valid-kr?*) :arg16* (s/? valid-kr?*) ))
(stest/instrument `polynomial)

(defn strget
  {:arglists '([iindex])}
  [index]
  (let [out-types-quoted 'String
        out-types String
        ast (ast-node out-types-quoted
                      "strget"
                      [index]
                      *global*)]
    (new out-types ast)))

(s/fdef strget
  :args (s/cat :index valid-i? ))
(stest/instrument `strget)

(defn comb
  {:arglists '([asig krvt ilpt & iskip* insmps*])}
  [sig rvt lpt & [ skip* nsmps* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "comb"
                      [sig rvt lpt skip* nsmps*]
                      *global*)]
    (new out-types ast)))

(s/fdef comb
  :args (s/cat :sig valid-ar? :rvt valid-kr? :lpt valid-i? :skip* (s/? valid-i?*) :nsmps* (s/? valid-i?*) ))
(stest/instrument `comb)

(defn button
  {:arglists '([knum])}
  [num]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "button"
                      [num]
                      *global*)]
    (new out-types ast)))

(s/fdef button
  :args (s/cat :num valid-kr? ))
(stest/instrument `button)

(defn zkcl
  {:arglists '([kfirst klast])}
  [first last]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "zkcl"
                      [first last]
                      *global*)]
    (new out-types ast)))

(s/fdef zkcl
  :args (s/cat :first valid-kr? :last valid-kr? ))
(stest/instrument `zkcl)

(defn tableshuffle
  {:arglists '([kitablenum])}
  [itablenum]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "tableshuffle"
                      [itablenum]
                      *global*)]
    (new out-types ast)))

(s/fdef tableshuffle
  :args (s/cat :itablenum valid-kr? ))
(stest/instrument `tableshuffle)

(defn remoteport
  {:arglists '([iportnum])}
  [portnum]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "remoteport"
                      [portnum]
                      *global*)]
    (new out-types ast)))

(s/fdef remoteport
  :args (s/cat :portnum valid-i? ))
(stest/instrument `remoteport)

(defn cosinv
  {:arglists '([aarg1] [iarg1] [iarg1Arr] [karg1] [karg1Arr])}
  [arg1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "cosinv"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef cosinv
  :args (s/alt
         :kArr (s/cat :arg1 valid-kArr? )
         :k (s/cat :arg1 valid-kr? )
         :iArr (s/cat :arg1 valid-iArr? )
         :i (s/cat :arg1 valid-i? )
         :a (s/cat :arg1 valid-ar? )
         ))
(stest/instrument `cosinv)

(defn cosinv:a
  {:arglists '([aarg1])}
  [arg1]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "cosinv"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef cosinv:a
  :args (s/cat :arg1 valid-ar? ))
(stest/instrument `cosinv:a)

(defn cosinv:i
  {:arglists '([iarg1])}
  [arg1]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "cosinv"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef cosinv:i
  :args (s/cat :arg1 valid-i? ))
(stest/instrument `cosinv:i)

(defn cosinv:iArr
  {:arglists '([iarg1Arr])}
  [arg1]
  (let [out-types-quoted 'VariableArray
        out-types VariableArray
        ast (ast-node out-types-quoted
                      "cosinv"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef cosinv:iArr
  :args (s/cat :arg1 valid-iArr? ))
(stest/instrument `cosinv:iArr)

(defn cosinv:k
  {:arglists '([karg1])}
  [arg1]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "cosinv"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef cosinv:k
  :args (s/cat :arg1 valid-kr? ))
(stest/instrument `cosinv:k)

(defn cosinv:kArr
  {:arglists '([karg1Arr])}
  [arg1]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "cosinv"
                      [arg1]
                      *global*)]
    (new out-types ast)))

(s/fdef cosinv:kArr
  :args (s/cat :arg1 valid-kArr? ))
(stest/instrument `cosinv:kArr)

(defn filevalid
  {:arglists '([Sfilcod] [ifilcod])}
  [filcod]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "filevalid"
                      [filcod]
                      *global*)]
    (new out-types ast)))

(s/fdef filevalid
  :args (s/alt
         :i (s/cat :filcod valid-i? )
         :S (s/cat :filcod valid-S? )
         ))
(stest/instrument `filevalid)

(defn tabplay
  {:arglists '([ktrig knumtics ktable & kout1* kout2* koutN3* koutN4* koutN5* koutN6* koutN7* koutN8* koutN9* koutN10* koutN11* koutN12* koutN13* koutN14* koutN15* koutN16*])}
  [trig numtics table & [ out1* out2* outN3* outN4* outN5* outN6* outN7* outN8* outN9* outN10* outN11* outN12* outN13* outN14* outN15* outN16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "tabplay"
                      [trig numtics table out1* out2* outN3* outN4* outN5* outN6* outN7* outN8* outN9* outN10* outN11* outN12* outN13* outN14* outN15* outN16*]
                      *global*)]
    (new out-types ast)))

(s/fdef tabplay
  :args (s/cat :trig valid-kr? :numtics valid-kr? :table valid-kr? :out1* (s/? valid-kr?*) :out2* (s/? valid-kr?*) :outN3* (s/? valid-kr?*) :outN4* (s/? valid-kr?*) :outN5* (s/? valid-kr?*) :outN6* (s/? valid-kr?*) :outN7* (s/? valid-kr?*) :outN8* (s/? valid-kr?*) :outN9* (s/? valid-kr?*) :outN10* (s/? valid-kr?*) :outN11* (s/? valid-kr?*) :outN12* (s/? valid-kr?*) :outN13* (s/? valid-kr?*) :outN14* (s/? valid-kr?*) :outN15* (s/? valid-kr?*) :outN16* (s/? valid-kr?*) ))
(stest/instrument `tabplay)

(defn biquad
  {:arglists '([asig kb2 kb3 kb4 ka5 ka6 ka7 & iskip*])}
  [sig b2 b3 b4 a5 a6 a7 & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "biquad"
                      [sig b2 b3 b4 a5 a6 a7 skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef biquad
  :args (s/cat :sig valid-ar? :b2 valid-kr? :b3 valid-kr? :b4 valid-kr? :a5 valid-kr? :a6 valid-kr? :a7 valid-kr? :skip* (s/? valid-i?*) ))
(stest/instrument `biquad)

(defn sleighbells
  {:arglists '([kamp idettack & inum* idamp* imaxshake* ifreq* ifreq1* ifreq1*])}
  [amp dettack & [ num* damp* maxshake* freq* freq1* freq1* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "sleighbells"
                      [amp dettack num* damp* maxshake* freq* freq1* freq1*]
                      *global*)]
    (new out-types ast)))

(s/fdef sleighbells
  :args (s/cat :amp valid-kr? :dettack valid-i? :num* (s/? valid-i?*) :damp* (s/? valid-i?*) :maxshake* (s/? valid-i?*) :freq* (s/? valid-i?*) :freq1* (s/? valid-i?*) :freq1* (s/? valid-i?*) ))
(stest/instrument `sleighbells)

(defn in
  {:arglists '( )}
  []
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "in"
                      []
                      *global*)]
    (new out-types ast)))


(defn in:a
  {:arglists '()}
  []
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "in"
                      []
                      *global*)]
    (new out-types ast)))


(defn in:aArr
  {:arglists '()}
  []
  (let [out-types-quoted 'AudioArray
        out-types AudioArray
        ast (ast-node out-types-quoted
                      "in"
                      []
                      *global*)]
    (new out-types ast)))


(defn getseed
  {:arglists '( )}
  []
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "getseed"
                      []
                      *global*)]
    (new out-types ast)))


(defn getseed:i
  {:arglists '()}
  []
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "getseed"
                      []
                      *global*)]
    (new out-types ast)))


(defn getseed:k
  {:arglists '()}
  []
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "getseed"
                      []
                      *global*)]
    (new out-types ast)))


(defn strlowerk
  {:arglists '([Ssrc])}
  [src]
  (let [out-types-quoted 'String
        out-types String
        ast (ast-node out-types-quoted
                      "strlowerk"
                      [src]
                      *global*)]
    (new out-types ast)))

(s/fdef strlowerk
  :args (s/cat :src valid-S? ))
(stest/instrument `strlowerk)

(defn passign
  {:arglists '([& istart*])}
  [& [ start* ]]
  (let [out-types-quoted '[                       ]
        out-types [                       ]
        ast (ast-node out-types-quoted
                      "passign"
                      [start*]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef passign
  :args (s/cat :start* (s/? valid-i?*) ))
(stest/instrument `passign)

(defn fmmetal
  {:arglists '([kamp kfreq kc3 kc4 kvdepth kvrate ifn7 ifn8 ifn9 ifn10 ivfn])}
  [amp freq c3 c4 vdepth vrate fn7 fn8 fn9 fn10 vfn]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "fmmetal"
                      [amp freq c3 c4 vdepth vrate fn7 fn8 fn9 fn10 vfn]
                      *global*)]
    (new out-types ast)))

(s/fdef fmmetal
  :args (s/cat :amp valid-kr? :freq valid-kr? :c3 valid-kr? :c4 valid-kr? :vdepth valid-kr? :vrate valid-kr? :fn7 valid-i? :fn8 valid-i? :fn9 valid-i? :fn10 valid-i? :vfn valid-i? ))
(stest/instrument `fmmetal)

(defn cepsinv
  {:arglists '([kepsArr])}
  [eps]
  (let [out-types-quoted 'ControlArray
        out-types ControlArray
        ast (ast-node out-types-quoted
                      "cepsinv"
                      [eps]
                      *global*)]
    (new out-types ast)))

(s/fdef cepsinv
  :args (s/cat :eps valid-kArr? ))
(stest/instrument `cepsinv)

(defn foutir
  {:arglists '([ihandle iformat iflag & iout1* iout2* iout3* ioutN4* ioutN5* ioutN6* ioutN7* ioutN8* ioutN9* ioutN10* ioutN11* ioutN12* ioutN13* ioutN14* ioutN15* ioutN16*])}
  [handle format flag & [ out1* out2* out3* outN4* outN5* outN6* outN7* outN8* outN9* outN10* outN11* outN12* outN13* outN14* outN15* outN16* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "foutir"
                      [handle format flag out1* out2* out3* outN4* outN5* outN6* outN7* outN8* outN9* outN10* outN11* outN12* outN13* outN14* outN15* outN16*]
                      *global*)]
    (new out-types ast)))

(s/fdef foutir
  :args (s/cat :handle valid-i? :format valid-i? :flag valid-i? :out1* (s/? valid-i?*) :out2* (s/? valid-i?*) :out3* (s/? valid-i?*) :outN4* (s/? valid-i?*) :outN5* (s/? valid-i?*) :outN6* (s/? valid-i?*) :outN7* (s/? valid-i?*) :outN8* (s/? valid-i?*) :outN9* (s/? valid-i?*) :outN10* (s/? valid-i?*) :outN11* (s/? valid-i?*) :outN12* (s/? valid-i?*) :outN13* (s/? valid-i?*) :outN14* (s/? valid-i?*) :outN15* (s/? valid-i?*) :outN16* (s/? valid-i?*) ))
(stest/instrument `foutir)

(defn strcat
  {:arglists '([Ssrc1 Ssrc2])}
  [src1 src2]
  (let [out-types-quoted 'String
        out-types String
        ast (ast-node out-types-quoted
                      "strcat"
                      [src1 src2]
                      *global*)]
    (new out-types ast)))

(s/fdef strcat
  :args (s/cat :src1 valid-S? :src2 valid-S? ))
(stest/instrument `strcat)

(defn pvswarp
  {:arglists '([fsigin kscal kshift & klowest* kmeth* kgain* kcoefs*])}
  [sigin scal shift & [ lowest* meth* gain* coefs* ]]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "pvswarp"
                      [sigin scal shift lowest* meth* gain* coefs*]
                      *global*)]
    (new out-types ast)))

(s/fdef pvswarp
  :args (s/cat :sigin valid-f? :scal valid-kr? :shift valid-kr? :lowest* (s/? valid-kr?*) :meth* (s/? valid-kr?*) :gain* (s/? valid-kr?*) :coefs* (s/? valid-kr?*) ))
(stest/instrument `pvswarp)

(defn clfilt
  {:arglists '([asig kfreq itype inpol & ikind* ipbr* isba* iskip*])}
  [sig freq type npol & [ kind* pbr* sba* skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "clfilt"
                      [sig freq type npol kind* pbr* sba* skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef clfilt
  :args (s/cat :sig valid-ar? :freq valid-kr? :type valid-i? :npol valid-i? :kind* (s/? valid-i?*) :pbr* (s/? valid-i?*) :sba* (s/? valid-i?*) :skip* (s/? valid-i?*) ))
(stest/instrument `clfilt)

(defn endop
  {:arglists '()}
  []
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "endop"
                      []
                      *global*)]
    (new out-types ast)))


(defn cmp
  {:arglists '([aL S_operator aR] [aL S_operator kR])}
  [L _operator R]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "cmp"
                      [L _operator R]
                      *global*)]
    (new out-types ast)))

(s/fdef cmp
  :args (s/alt
         :aSk (s/cat :L valid-ar? :_operator valid-S? :R valid-kr? )
         :aSa (s/cat :L valid-ar? :_operator valid-S? :R valid-ar? )
         ))
(stest/instrument `cmp)

(defn tablei
  {:arglists '([xindex itable & ixmode* ixoff* iwrap*] [iindex itable & ixmode* ixoff* iwrap*] [xindex itable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "tablei"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef tablei
  :args (s/alt
         :iiiii (s/cat :index valid-i? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) )
         :xiiii (s/cat :index valid-x? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) )
         ))
(stest/instrument `tablei)

(defn tablei:a
  {:arglists '([xindex itable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "tablei"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef tablei:a
  :args (s/cat :index valid-x? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) ))
(stest/instrument `tablei:a)

(defn tablei:i
  {:arglists '([iindex itable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'Variable
        out-types Variable
        ast (ast-node out-types-quoted
                      "tablei"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef tablei:i
  :args (s/cat :index valid-i? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) ))
(stest/instrument `tablei:i)

(defn tablei:k
  {:arglists '([xindex itable & ixmode* ixoff* iwrap*])}
  [index table & [ xmode* xoff* wrap* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "tablei"
                      [index table xmode* xoff* wrap*]
                      *global*)]
    (new out-types ast)))

(s/fdef tablei:k
  :args (s/cat :index valid-x? :table valid-i? :xmode* (s/? valid-i?*) :xoff* (s/? valid-i?*) :wrap* (s/? valid-i?*) ))
(stest/instrument `tablei:k)

(defn vmap
  {:arglists '([ifn1 ifn2 ielements & idstoffset* isrcoffset*])}
  [fn1 fn2 elements & [ dstoffset* srcoffset* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "vmap"
                      [fn1 fn2 elements dstoffset* srcoffset*]
                      *global*)]
    (new out-types ast)))

(s/fdef vmap
  :args (s/cat :fn1 valid-i? :fn2 valid-i? :elements valid-i? :dstoffset* (s/? valid-i?*) :srcoffset* (s/? valid-i?*) ))
(stest/instrument `vmap)

(defn ftmorf
  {:arglists '([kftndx iftfn iresfn])}
  [ftndx ftfn resfn]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "ftmorf"
                      [ftndx ftfn resfn]
                      *global*)]
    (new out-types ast)))

(s/fdef ftmorf
  :args (s/cat :ftndx valid-kr? :ftfn valid-i? :resfn valid-i? ))
(stest/instrument `ftmorf)

(defn jacktransport
  {:arglists '([icommand & ilocation*])}
  [command & [ location* ]]
  (let [out-types-quoted 'IO
        out-types IO
        ast (ast-node out-types-quoted
                      "jacktransport"
                      [command location*]
                      *global*)]
    (new out-types ast)))

(s/fdef jacktransport
  :args (s/cat :command valid-i? :location* (s/? valid-i?*) ))
(stest/instrument `jacktransport)

(defn barmodel
  {:arglists '([kbcL kbcR iK ib kscan iT6 ipos ivel iwid])}
  [bcL bcR K b scan T6 pos vel wid]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "barmodel"
                      [bcL bcR K b scan T6 pos vel wid]
                      *global*)]
    (new out-types ast)))

(s/fdef barmodel
  :args (s/cat :bcL valid-kr? :bcR valid-kr? :K valid-i? :b valid-i? :scan valid-kr? :T6 valid-i? :pos valid-i? :vel valid-i? :wid valid-i? ))
(stest/instrument `barmodel)

(defn randh
  {:arglists '([xamp xcps iseed & isize* ioffset*] [xamp xcps iseed & isize* ioffset*])}
  [amp cps seed & [ size* offset* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "randh"
                      [amp cps seed size* offset*]
                      *global*)]
    (new out-types ast)))

(s/fdef randh
  :args (s/alt
         :xxiii (s/cat :amp valid-x? :cps valid-x? :seed valid-i? :size* (s/? valid-i?*) :offset* (s/? valid-i?*) )
         ))
(stest/instrument `randh)

(defn randh:a
  {:arglists '([xamp xcps iseed & isize* ioffset*])}
  [amp cps seed & [ size* offset* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "randh"
                      [amp cps seed size* offset*]
                      *global*)]
    (new out-types ast)))

(s/fdef randh:a
  :args (s/cat :amp valid-x? :cps valid-x? :seed valid-i? :size* (s/? valid-i?*) :offset* (s/? valid-i?*) ))
(stest/instrument `randh:a)

(defn randh:k
  {:arglists '([xamp xcps iseed & isize* ioffset*])}
  [amp cps seed & [ size* offset* ]]
  (let [out-types-quoted 'ControlSignal
        out-types ControlSignal
        ast (ast-node out-types-quoted
                      "randh"
                      [amp cps seed size* offset*]
                      *global*)]
    (new out-types ast)))

(s/fdef randh:k
  :args (s/cat :amp valid-x? :cps valid-x? :seed valid-i? :size* (s/? valid-i?*) :offset* (s/? valid-i?*) ))
(stest/instrument `randh:k)

(defn pvsbuffer
  {:arglists '([fsig ilen])}
  [sig len]
  (let [out-types-quoted '[Variable ControlSignal]
        out-types [Variable ControlSignal]
        ast (ast-node out-types-quoted
                      "pvsbuffer"
                      [sig len]
                      *global*)]
    (mapv #(new %1 %2) out-types ast)))

(s/fdef pvsbuffer
  :args (s/cat :sig valid-f? :len valid-i? ))
(stest/instrument `pvsbuffer)

(defn median
  {:arglists '([asig ksize imaxsize & iskip*])}
  [sig size maxsize & [ skip* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "median"
                      [sig size maxsize skip*]
                      *global*)]
    (new out-types ast)))

(s/fdef median
  :args (s/cat :sig valid-ar? :size valid-kr? :maxsize valid-i? :skip* (s/? valid-i?*) ))
(stest/instrument `median)

(defn lposcila
  {:arglists '([aamp kfreqratio kloop kend ift & iphase*])}
  [amp freqratio loop end ft & [ phase* ]]
  (let [out-types-quoted 'AudioSignal
        out-types AudioSignal
        ast (ast-node out-types-quoted
                      "lposcila"
                      [amp freqratio loop end ft phase*]
                      *global*)]
    (new out-types ast)))

(s/fdef lposcila
  :args (s/cat :amp valid-ar? :freqratio valid-kr? :loop valid-kr? :end valid-kr? :ft valid-i? :phase* (s/? valid-i?*) ))
(stest/instrument `lposcila)

(defn trfilter
  {:arglists '([fin kamnt itable])}
  [in amnt table]
  (let [out-types-quoted 'FrequencySignal
        out-types FrequencySignal
        ast (ast-node out-types-quoted
                      "trfilter"
                      [in amnt table]
                      *global*)]
    (new out-types ast)))

(s/fdef trfilter
  :args (s/cat :in valid-f? :amnt valid-kr? :table valid-i? ))
(stest/instrument `trfilter)
